game.Players.LocalPlayer:LoadCharacter()
wait()

_G.ScriptSettings = {
	Auto_Chat_Enabled = true, 
	Fling_Players_On_Chat = true,
	HRP_Position_On_Sky = false
}

-- fd fix
CloneCharacterName = game:GetService("HttpService"):GenerateGUID()

local lplr = game:GetService("Players").LocalPlayer
local char = lplr.Character
char.Archivable = true
for _,v in pairs(char:GetDescendants()) do
	v.Archivable = true
end
local cloneChar = char:Clone()
cloneChar.Name = CloneCharacterName
char.Parent = game
cloneChar.Parent = workspace
lplr.Character = cloneChar
-- :skull:

--pcall(function()
	print("(HSE) Preparing FE Controller!")
	SCRIPTVERSION = "v1.6.3.8x5"

	FEController, Options, CharClones, Funcs, Movement, Welds, Timing, Services = {}, {ChatEnabled = _G.ScriptSettings.Auto_Chat_Enabled, ChatEventFling = _G.ScriptSettings.Fling_Players_On_Chat, HRPPosToggle = _G.ScriptSettings.HRP_Position_On_Sky}, {}, {Attack = false, FEAttack = false}, {}, {Defaults = {Neck = {C0 = CFrame.new(0, 1, 0) * CFrame.Angles(math.rad(-90), 0, math.rad(180))}, RootJoint = {C0 = CFrame.new() * CFrame.Angles(math.rad(-90), 0, math.rad(180))}, RightShoulder = {C0 = CFrame.new(-0.5, 0, 0) * CFrame.Angles(0, math.rad(90), 0)}, LeftShoulder = {C0 = CFrame.new(0.5, 0, 0) * CFrame.Angles(0, math.rad(-90), 0)}}}, {Sine = 0, FastSine = 0}, {"RunService","GuiService","Stats","SoundService","LogService","ContentProvider","KeyframeSequenceProvider","Chat","MarketplaceService","Players","PointsService","AdService","NotificationService","ReplicatedFirst","HttpRbxApiService","TweenService","TextService","StarterPlayer","StarterPack","StarterGui","LocalizationService","PolicyService","TeleportService","JointsService","CollectionService","PhysicsService","BadgeService","Geometry","ReplicatedStorage","InsertService","GamePassService","Debris","TimerService","CookiesService","UserInputService","KeyboardService","MouseService","VRService","ContextActionService","ScriptService","AssetService","TouchInputService","BrowserService","AnalyticsService","ScriptContext","Selection","HttpService","MeshContentProvider","Lighting","SolidModelContentProvider","GamepadService","ControllerService","RuntimeScriptService","HapticService","ChangeHistoryService","Visit","GuidRegistryService","PermissionsService","Teams","ReplicatedStorage","TestService","SocialService","MemStorageService","GroupService","PathfindingService","VirtualUser"}

	RunService, Debris = game:GetService("RunService"), game:GetService("Debris")
	Plrs = game.Players; Plr = Plrs.LocalPlayer; Player = Plrs.LocalPlayer; Char = Plr.Character

	_G.SCRIPT_LOADED = false; _G.REANIMATE_DONE = false

	function Funcs.Notify(Text, Delay)
		local Message

		coroutine.resume(coroutine.create(function()
			local NEWSOUND = Instance.new("Sound")
			NEWSOUND.Parent = workspace
			NEWSOUND.Volume = 10
			NEWSOUND.Pitch = 1
			NEWSOUND.EmitterSize = 9000000
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id=5035412139"
			NEWSOUND:play()
			repeat
				wait(1)
			until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end))

		coroutine.resume(coroutine.create(function()
			Message = Instance.new("Message", Funcs.Serv("Workspace"))
			Message.Text = Text
			wait(Delay or 1)
			Message:Destroy()
		end))

		return Message
	end

	function Funcs.Hint(Text, Delay)
		local Hint

		coroutine.resume(coroutine.create(function()
			Hint = Instance.new("Hint", Funcs.Serv("Workspace"))
			Hint.Text = Text
			wait(Delay or 1)
			Hint:Destroy()
		end))

		return Hint
	end

	function Funcs.FixCamera(part, min, max)
		workspace.CurrentCamera.CameraSubject = part
		workspace.CurrentCamera.CameraType = "Custom"
		
		game.Players.LocalPlayer.CameraMinZoomDistance = min
		game.Players.LocalPlayer.CameraMaxZoomDistance = max
		game.Players.LocalPlayer.CameraMode = "Classic"
		game.Players.LocalPlayer.Character.Head.Anchored = false
	end

	function Funcs.Noclip()
		repeat wait() until game.Players.LocalPlayer.Character ~= nil
		
		Funcs.Serv('RunService').Stepped:connect(function()
		game:GetService("RunService").Stepped:Wait()
			if game.Players.LocalPlayer.Character ~= nil then
				for _, child in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
					if child:IsA("BasePart") and child.CanCollide == true then
						child.CanCollide = false
					end
				end
			end
		end)
	end
	
	function Funcs.Serv(Name)
		return game:GetService(Name)
	end
	
	function Funcs.Debris(Instance, Delay)
		Funcs.Serv("Debris"):AddItem(Instance, Delay)
	end

	function Funcs.HyperSkiddedServiceNameChange()
		if true then return end
		HSEChangesL = {}
		HSEChangesL[1] = "Hyperskidded Cannon: "
		HSEChangesL[2] = "hYpEr sKidDed cAnNon: "
		HSEChangesL[3] = "Hyperskidded Cannon: "
		HSEChangesL[4] = "Hyperskidded Cannon: "
		HSEChangesL[5] = "hYPer skDDidEd: "
		HSEChangesL[6] = ""
		HSEChangesL[7] = "hyperSkiDed cAnNon: "
		HSEChangesL[8] = "H\225\131\167\207\129\210\189\201\190S\198\153\206\185\212\131\212\131\210\189\212\131 C\206\177\201\179\201\179\207\131\201\179: "
		HSEChangesL[9] = "uouu\201\144\198\134 p\199\157pp\196\177\202\158S\201\185\199\157d\202\142H: "
		HSEChangesL[10] = "\226\132\140\240\157\148\182\240\157\148\173\240\157\148\162\240\157\148\175\240\157\148\150\240\157\148\168\240\157\148\166\240\157\148\161\240\157\148\161\240\157\148\162\240\157\148\161 \226\132\173\240\157\148\158\240\157\148\171\240\157\148\171\240\157\148\172\240\157\148\171: "
		HSEChangesL[11] = "\240\159\133\183\240\159\134\136\240\159\133\191\240\159\133\180\240\159\134\129\240\159\134\130\240\159\133\186\240\159\133\184\240\159\133\179\240\159\133\179\240\159\133\180\240\159\133\179 \240\159\133\178\240\159\133\176\240\159\133\189\240\159\133\189\240\159\133\190\240\159\133\189: "
		HSEChangesL[12] = "\240\157\144\135\240\157\144\178\240\157\144\169\240\157\144\158\240\157\144\171\240\157\144\146\240\157\144\164\240\157\144\162\240\157\144\157\240\157\144\157\240\157\144\158\240\157\144\157 \240\157\144\130\240\157\144\154\240\157\144\167\240\157\144\167\240\157\144\168\240\157\144\167: "
		HSEChangesL[13] = "\226\137\139H\226\137\139y\226\137\139p\226\137\139e\226\137\139r\226\137\139S\226\137\139k\226\137\139i\226\137\139d\226\137\139d\226\137\139e\226\137\139d\226\137\139: "
		HSEChangesL[14] = "\226\146\189\226\147\168\226\147\159\226\147\148\226\147\161\226\147\136\226\147\154\226\147\152\226\147\147\226\147\147\226\147\148\226\147\147 \226\146\184\226\147\144\226\147\157\226\147\157\226\147\158\226\147\157: "
		HSEChangesL[15] = "H\226\153\165y\226\153\165p\226\153\165e\226\153\165r\226\153\165S\226\153\165k\226\153\165i\226\153\165d\226\153\165d\226\153\165e\226\153\165d\226\153\165 \226\153\165C\226\153\165a\226\153\165n\226\153\165n\226\153\165o\226\153\165n: "
		HSEChangesL[16] = "H\204\189\205\147y\204\189\205\147p\204\189\205\147e\204\189\205\147r\204\189\205\147S\204\189\205\147k\204\189\205\147i\204\189\205\147d\204\189\205\147d\204\189\205\147e\204\189\205\147d\204\189\205\147 \204\189\205\147C\204\189\205\147a\204\189\205\147n\204\189\205\147n\204\189\205\147o\204\189\205\147n\204\189\205\147: "
		HSEChangesL[17] = "\226\152\159\239\184\142\226\141\147\239\184\142\226\151\187\239\184\142\226\153\143\239\184\142\226\157\146\239\184\142\240\159\146\167\239\184\142\240\159\153\181\226\153\147\239\184\142\226\153\142\239\184\142\226\153\142\239\184\142\226\153\143\239\184\142\226\153\142\239\184\142 \240\159\145\141\239\184\142\226\153\139\239\184\142\226\150\160\239\184\142\226\150\160\239\184\142\226\150\161\239\184\142\226\150\160\239\184\142: "
		HSEChangesL[18] = "\229\141\132\208\142\226\147\133\240\157\148\162\240\157\144\171\226\147\162\240\157\149\130\240\157\149\154\196\144\239\189\132\240\157\146\134\240\157\147\173 \240\157\147\172\240\157\148\158\224\184\160\197\135\240\157\144\142\240\157\149\159: "
		HSEChangesL[19] = "\240\157\147\151\240\157\144\152\207\129\209\148\240\157\147\161\240\157\148\176\240\157\149\156\239\189\137\196\145\239\189\132\226\130\172\239\189\132 \207\130\224\184\132\239\188\174\240\157\149\159\240\157\147\158\226\147\131: "
		HSEChangesL[20] = "\196\166\240\157\149\144\198\164\240\157\146\134\208\179\209\149\240\157\147\180\206\185\196\144\240\157\146\185\239\189\133\224\185\148 \240\157\146\184\225\181\131\225\145\142\240\157\147\183\225\187\150\240\157\144\141 "
		HSEChangesL[21] = "\239\188\168\240\157\149\170\225\181\150\240\157\144\132\208\179\240\157\149\138\208\140\239\188\169\240\157\146\185\225\151\170\225\186\184\224\185\148 \240\157\148\160\240\157\148\184\226\132\149\225\182\176\240\157\149\160\229\135\160: "
		HSEChangesL[22] = "\240\157\147\177\210\175\239\188\176\240\157\145\146\226\147\135\240\157\149\164\226\147\154\198\151\196\144\239\188\164\226\146\186\196\144 \240\157\146\184\226\146\182\206\183\240\157\148\171\240\157\145\156\226\132\149: "
		HSEChangesL[23] = "\196\166\240\157\149\144\198\164\240\157\146\134\208\179\209\149\240\157\147\180\206\185\196\144\240\157\146\185\239\189\133\224\185\148 \240\157\146\184\225\181\131\225\145\142\240\157\147\183\225\187\150\240\157\144\141 "
		
		HSEChanges2 = {}
		HSEChanges2[1] = "[Hyperskidded Cannon]: "
		
		Funcs.Serv("RunService").Heartbeat:Connect(function()
		game:GetService("RunService").Heartbeat:Wait()
			for i,v in pairs(game:GetChildren()) do
				pcall(function()
					v.Name = HSEChangesL[math.random(1,#HSEChangesL)]
				end)
			end
		end)
	end

	function FEController.Teleport(Part, Position)
		local TPBodyGyro = Instance.new("BodyGyro", Part)
		TPBodyGyro.D = 175
		TPBodyGyro.P = 20000
		TPBodyGyro.MaxTorque = Vector3.new(0,9000,0)
		TPBodyGyro.CFrame = CFrame.new(Part.Position, (Position * CFrame.new(0, 3, 0)).p)
	
		Funcs.Serv("Debris"):AddItem(TPBodyGyro, .05)
		Part.CFrame = CFrame.new((Position * CFrame.new(0, 3, 0)).p)
	end

	function FEController.Reanimate(Type)
		local Bypass = Type

		if not Bypass then Bypass = "limbs" end
		HumanDied = false
	
		CountSCIFIMOVIELOL = 1
		function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
			local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
			AlignPos.ApplyAtCenterOfMass = true;
			AlignPos.MaxForce = 67752;
			AlignPos.MaxVelocity = math.huge/9e110;
			AlignPos.ReactionForceEnabled = false;
			AlignPos.Responsiveness = 200;
			AlignPos.RigidityEnabled = false;
			local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
			AlignOri.MaxAngularVelocity = math.huge/9e110;
			AlignOri.MaxTorque = 67752;
			AlignOri.PrimaryAxisOnly = false;
			AlignOri.ReactionTorqueEnabled = false;
			AlignOri.Responsiveness = 200;
			AlignOri.RigidityEnabled = false;
			local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOL
			local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOL
			local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOL
			local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOL
			AttachmentC.Orientation = Angle
			AttachmentA.Position = Position
			AlignPos.Attachment1 = AttachmentA;
			AlignPos.Attachment0 = AttachmentB;
			AlignOri.Attachment1 = AttachmentC;
			AlignOri.Attachment0 = AttachmentD;
			CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
		end
	
		coroutine.wrap(function()
			local player = game.Players.LocalPlayer
			local char = player.Character or player.CharacterAdded:wait()
			if sethiddenproperty then
				while true do
					Funcs.Serv("RunService").RenderStepped:Wait()
					settings().Physics.AllowSleep = false
					local TBL = Funcs.Serv("Players"):GetChildren() 
					for _ = 1,#TBL do local Players = TBL[_]
						if Players ~= Funcs.Serv("Players").LocalPlayer then
							Players.MaximumSimulationRadius = 0
							sethiddenproperty(Players,"SimulationRadius",0) 
						end 
					end
					Funcs.Serv("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
					sethiddenproperty(Funcs.Serv("Players").LocalPlayer,"SimulationRadius",math.pow(math.huge,math.huge)*math.huge)
					if HumanDied then break end
				end
			else
				while true do
					Funcs.Serv("RunService").RenderStepped:Wait()
					settings().Physics.AllowSleep = false
					local TBL = Funcs.Serv("Players"):GetChildren() 
					for _ = 1,#TBL do local Players = TBL[_]
						if Players ~= Funcs.Serv("Players").LocalPlayer then
							Players.MaximumSimulationRadius = 0
						end 
					end
					Funcs.Serv("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
					if HumanDied then break end
				end
			end
		end)()
	
		if Funcs.Serv("Players").LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
			if Bypass == "limbs" then --------------------------------------------------------------------------------------------------------------------
				Funcs.Serv("Players").LocalPlayer["Character"].Archivable = true 
				local CloneChar = Funcs.Serv("Players").LocalPlayer["Character"]:Clone()
				CloneChar.Parent = workspace 
				CloneChar.HumanoidRootPart.CFrame = Funcs.Serv("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,2,0)
				wait() 
				CloneChar.Humanoid.BreakJointsOnDeath = false
				workspace.Camera.CameraSubject = CloneChar.Humanoid
				CloneChar.Name = CloneCharacterName 
				CloneChar.Humanoid.DisplayDistanceType = "None"
				if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
				if workspace[Funcs.Serv("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[Funcs.Serv("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end
	
				local DeadChar = workspace[Funcs.Serv("Players").LocalPlayer.Name]
				DeadChar.HumanoidRootPart:Destroy()
	
				local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
				local CONVEC
				local function VECTORUNIT()
					if HumanDied then CONVEC:Disconnect(); return end
					local lookVec = workspace.Camera.CFrame.lookVector
					local Root = CloneChar["HumanoidRootPart"]
					LVecPart.Position = Root.Position
					LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
				end
				CONVEC = Funcs.Serv("RunService").Heartbeat:Connect(VECTORUNIT)
	game:GetService("RunService").Heartbeat:Wait()
				local CONDOWN
				local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
				local function KEYDOWN(_,Processed) 
					if HumanDied then CONDOWN:Disconnect(); return end
					if Processed ~= true then
						local Key = _.KeyCode
						if Key == Enum.KeyCode.W then
							WDown = true end
						if Key == Enum.KeyCode.A then
							ADown = true end
						if Key == Enum.KeyCode.S then
							SDown = true end
						if Key == Enum.KeyCode.D then
							DDown = true end
						if Key == Enum.KeyCode.Space then
							SpaceDown = true end end end
				CONDOWN = Funcs.Serv("UserInputService").InputBegan:Connect(KEYDOWN)
	game:GetService("RunService").RenderStepped:Wait()
				local CONUP
				local function KEYUP(_)
					if HumanDied then CONUP:Disconnect(); return end
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = false end
					if Key == Enum.KeyCode.A then
						ADown = false end
					if Key == Enum.KeyCode.S then
						SDown = false end
					if Key == Enum.KeyCode.D then
						DDown = false end
					if Key == Enum.KeyCode.Space then
						SpaceDown = false end end
				CONUP = Funcs.Serv("UserInputService").InputEnded:Connect(KEYUP)
	game:GetService("RunService").RenderStepped:Wait()
				local function MoveClone(X,Y,Z)
					LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
					workspace[CloneCharacterName].Humanoid.WalkToPoint = LVecPart.Position
				end
	
				coroutine.wrap(function() 
					while true do Funcs.Serv("RunService").RenderStepped:Wait()
						if HumanDied then break end
						if WDown then MoveClone(0,0,1e4) end
						if ADown then MoveClone(1e4,0,0) end
						if SDown then MoveClone(0,0,-1e4) end
						if DDown then MoveClone(-1e4,0,0) end
						if SpaceDown then CloneChar["Humanoid"].Jump = true end
						if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
							workspace[CloneCharacterName].Humanoid.WalkToPoint = workspace[CloneCharacterName].HumanoidRootPart.Position end
					end 
				end)()
	
				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, CloneChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false 
						end 
					end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = Funcs.Serv("RunService").Stepped:Connect(UnCollide)
	game:GetService("RunService").Stepped:Wait()
				local resetBindable = Instance.new("BindableEvent")
				resetBindable.Event:connect(function()
				game:GetService("RunService").RenderStepped:Wait()
					Funcs.Serv("StarterGui"):SetCore("ResetButtonCallback", true)
					resetBindable:Destroy()
					pcall(function()
						CloneChar.Humanoid.Health = 0
						DeadChar.Humanoid.Health = 0
					end)
				end)
				Funcs.Serv("StarterGui"):SetCore("ResetButtonCallback", resetBindable)
	
				coroutine.wrap(function()
					while true do
						Funcs.Serv("RunService").RenderStepped:wait()
						if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 or not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								game.Players.LocalPlayer.Character = CloneChar
								CloneChar:Destroy()
								game.Players.LocalPlayer.Character = DeadChar
								if resetBindable then
									Funcs.Serv("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()
	
				SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
	
				coroutine.wrap(function()
					while true do
						Funcs.Serv("RunService").RenderStepped:wait()
						if HumanDied then break end
						DeadChar["Torso"].CFrame = CloneChar["Torso"].CFrame
					end
				end)()
	
				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
					end
				end
	
				for _,BodyParts in next, CloneChar:GetDescendants() do
					if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
						BodyParts.Transparency = 1 end end
	
				DeadChar.Torso["Left Shoulder"]:Destroy()
				DeadChar.Torso["Right Shoulder"]:Destroy()
				DeadChar.Torso["Left Hip"]:Destroy()
				DeadChar.Torso["Right Hip"]:Destroy()
	
			elseif Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
				Funcs.Serv("Players").LocalPlayer["Character"].Archivable = true 
				local CloneChar = Funcs.Serv("Players").LocalPlayer["Character"]:Clone()
				Funcs.Serv("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
				Funcs.Serv("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
				Funcs.Serv("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
				local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
				Instance.new("Part",FalseChar).Name = "Head" 
				Instance.new("Part",FalseChar).Name = "Torso" 
				Instance.new("Humanoid",FalseChar).Name = "Humanoid"
				Funcs.Serv("Players").LocalPlayer["Character"] = FalseChar
				Funcs.Serv("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
				local Clone = Funcs.Serv("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
				Clone.Parent = Funcs.Serv("Players").LocalPlayer["Character"]
				Clone.Name = "Humanoid"
				Funcs.Serv("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
				Funcs.Serv("Players").LocalPlayer["Character"].Humanoid.Health = 0 
				Funcs.Serv("Players").LocalPlayer["Character"] = workspace[Funcs.Serv("Players").LocalPlayer.Name] 
				wait(5.65) 
				Funcs.Serv("Players").LocalPlayer["Character"].Humanoid.Health = 0
				CloneChar.Parent = workspace 
				CloneChar.HumanoidRootPart.CFrame = Funcs.Serv("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,2,0)
				wait() 
				CloneChar.Humanoid.BreakJointsOnDeath = false
				workspace.Camera.CameraSubject = CloneChar.Humanoid 
				CloneChar.Name = CloneCharacterName
				CloneChar.Humanoid.DisplayDistanceType = "None"
				if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
				if workspace[Funcs.Serv("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[Funcs.Serv("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end
	
				FalseChar:Destroy()
	
				local DeadChar = workspace[Funcs.Serv("Players").LocalPlayer.Name]
	
				local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
				local CONVEC
				local function VECTORUNIT()
					if HumanDied then CONVEC:Disconnect(); return end
					local lookVec = workspace.Camera.CFrame.lookVector
					local Root = CloneChar["HumanoidRootPart"]
					LVecPart.Position = Root.Position
					LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
				end
				CONVEC = Funcs.Serv("RunService").Heartbeat:Connect(VECTORUNIT)
	game:GetService("RunService").Heartbeat:Wait()
				local CONDOWN
				local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
				local function KEYDOWN(_,Processed) 
					if HumanDied then CONDOWN:Disconnect(); return end
					if Processed ~= true then
						local Key = _.KeyCode
						if Key == Enum.KeyCode.W then
							WDown = true end
						if Key == Enum.KeyCode.A then
							ADown = true end
						if Key == Enum.KeyCode.S then
							SDown = true end
						if Key == Enum.KeyCode.D then
							DDown = true end
						if Key == Enum.KeyCode.Space then
							SpaceDown = true end end end
				CONDOWN = Funcs.Serv("UserInputService").InputBegan:Connect(KEYDOWN)
	game:GetService("RunService").RenderStepped:Wait()
				local CONUP
				local function KEYUP(_)
					if HumanDied then CONUP:Disconnect(); return end
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = false end
					if Key == Enum.KeyCode.A then
						ADown = false end
					if Key == Enum.KeyCode.S then
						SDown = false end
					if Key == Enum.KeyCode.D then
						DDown = false end
					if Key == Enum.KeyCode.Space then
						SpaceDown = false end end
				CONUP = Funcs.Serv("UserInputService").InputEnded:Connect(KEYUP)
	game:GetService("RunService").RenderStepped:Wait()
				local function MoveClone(X,Y,Z)
					LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
					workspace[CloneCharacterName].Humanoid.WalkToPoint = LVecPart.Position
				end
	
				coroutine.wrap(function() 
					while true do Funcs.Serv("RunService").RenderStepped:Wait()
						if HumanDied then break end
						if WDown then MoveClone(0,0,1e4) end
						if ADown then MoveClone(1e4,0,0) end
						if SDown then MoveClone(0,0,-1e4) end
						if DDown then MoveClone(-1e4,0,0) end
						if SpaceDown then CloneChar["Humanoid"].Jump = true end
						if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
							workspace[CloneCharacterName].Humanoid.WalkToPoint = workspace[CloneCharacterName].HumanoidRootPart.Position end
					end 
				end)()
	
				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, CloneChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false 
						end 
					end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = Funcs.Serv("RunService").Stepped:Connect(UnCollide)
	game:GetService("RunService").Stepped:Wait()
				local resetBindable = Instance.new("BindableEvent")
				resetBindable.Event:connect(function()
				game:GetService("RunService").RenderStepped:Wait()
					Funcs.Serv("StarterGui"):SetCore("ResetButtonCallback", true)
					resetBindable:Destroy()
					CloneChar.Humanoid.Health = 0
				end)
				Funcs.Serv("StarterGui"):SetCore("ResetButtonCallback", resetBindable)
	
				coroutine.wrap(function()
					while true do
						Funcs.Serv("RunService").RenderStepped:wait()
						if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								game.Players.LocalPlayer.Character = CloneChar
								CloneChar:Destroy()
								game.Players.LocalPlayer.Character = DeadChar
								if resetBindable then
									Funcs.Serv("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()
	
				SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))
	
				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
					end
				end
	
				for _,BodyParts in next, CloneChar:GetDescendants() do
					if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
						BodyParts.Transparency = 1 end end
			elseif Bypass == "hats" then
				Funcs.Serv("Players").LocalPlayer["Character"].Archivable = true 
				local DeadChar = game.Players.LocalPlayer.Character
				DeadChar.Name = CloneCharacterName
				local HatPosition = Vector3.new(0,0,0)
				local HatName = "MediHood"
				local HatsLimb = {
					Rarm = DeadChar:FindFirstChild("Hat1"),
					Larm = DeadChar:FindFirstChild("Pink Hair"),
					Rleg = DeadChar:FindFirstChild("Robloxclassicred"),
					Lleg = DeadChar:FindFirstChild("Kate Hair"),
					Torso1 = DeadChar:FindFirstChild("Pal Hair"),
					Torso2 = DeadChar:FindFirstChild("LavanderHair")
				}
				HatName = DeadChar:FindFirstChild(HatName)
	
				coroutine.wrap(function()
					while true do
						Funcs.Serv("RunService").RenderStepped:wait()
						if not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								if resetBindable then
									Funcs.Serv("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()
	
				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = Funcs.Serv("RunService").Stepped:Connect(UnCollide)
	game:GetService("RunService").Stepped:Wait()
				SCIFIMOVIELOL(HatName.Handle,DeadChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(HatsLimb.Torso1.Handle,DeadChar["Torso"],Vector3.new(0.5,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Torso2.Handle,DeadChar["Torso"],Vector3.new(-0.5,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Larm.Handle,DeadChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Rarm.Handle,DeadChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Lleg.Handle,DeadChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Rleg.Handle,DeadChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))
	
				for i,v in pairs(HatsLimb) do
					v.Handle:FindFirstChild("AccessoryWeld"):Destroy()
					if v.Handle:FindFirstChild("Mesh") then v.Handle:FindFirstChild("Mesh"):Destroy() end
					if v.Handle:FindFirstChild("SpecialMesh") then v.Handle:FindFirstChild("SpecialMesh"):Destroy() end
				end
				HatName.Handle:FindFirstChild("AccessoryWeld"):Destroy()
			end
		else
			if Bypass == "limbs" then --------------------------------------------------------------------------------------------------------------------
				Funcs.Serv("Players").LocalPlayer["Character"].Archivable = true 
				local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
				CloneChar.Parent = workspace 
				CloneChar.HumanoidRootPart.CFrame = Funcs.Serv("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,0.5,0.1)
				CloneChar.Humanoid.BreakJointsOnDeath = false
				workspace.Camera.CameraSubject = CloneChar.Humanoid 
				CloneChar.Name = CloneCharacterName 
				CloneChar.Humanoid.DisplayDistanceType = "None"
				if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
				if workspace[Funcs.Serv("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[Funcs.Serv("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end
	
				local DeadChar = workspace[Funcs.Serv("Players").LocalPlayer.Name]
				DeadChar.HumanoidRootPart:Destroy()
	
				local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
				local CONVEC
				local function VECTORUNIT()
					if HumanDied then CONVEC:Disconnect(); return end
					local lookVec = workspace.Camera.CFrame.lookVector
					local Root = CloneChar["HumanoidRootPart"]
					LVecPart.Position = Root.Position
					LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
				end
				CONVEC = Funcs.Serv("RunService").Heartbeat:Connect(VECTORUNIT)
	game:GetService("RunService").Heartbeat:Wait()
				local CONDOWN
				local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
				local function KEYDOWN(_,Processed) 
					if HumanDied then CONDOWN:Disconnect(); return end
					if Processed ~= true then
						local Key = _.KeyCode
						if Key == Enum.KeyCode.W then
							WDown = true end
						if Key == Enum.KeyCode.A then
							ADown = true end
						if Key == Enum.KeyCode.S then
							SDown = true end
						if Key == Enum.KeyCode.D then
							DDown = true end
						if Key == Enum.KeyCode.Space then
							SpaceDown = true end end end
				CONDOWN = Funcs.Serv("UserInputService").InputBegan:Connect(KEYDOWN)
	
				local CONUP
				local function KEYUP(_)
					if HumanDied then CONUP:Disconnect(); return end
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = false end
					if Key == Enum.KeyCode.A then
						ADown = false end
					if Key == Enum.KeyCode.S then
						SDown = false end
					if Key == Enum.KeyCode.D then
						DDown = false end
					if Key == Enum.KeyCode.Space then
						SpaceDown = false end end
				CONUP = Funcs.Serv("UserInputService").InputEnded:Connect(KEYUP)
	
				local function MoveClone(X,Y,Z)
					LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
					workspace[CloneCharacterName].Humanoid.WalkToPoint = LVecPart.Position
				end
	
				coroutine.wrap(function() 
					while true do Funcs.Serv("RunService").RenderStepped:Wait()
						if HumanDied then break end
						if WDown then MoveClone(0,0,1e4) end
						if ADown then MoveClone(1e4,0,0) end
						if SDown then MoveClone(0,0,-1e4) end
						if DDown then MoveClone(-1e4,0,0) end
						if SpaceDown then CloneChar["Humanoid"].Jump = true end
						if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
							workspace[CloneCharacterName].Humanoid.WalkToPoint = workspace[CloneCharacterName].HumanoidRootPart.Position end
					end 
				end)()
	
				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, CloneChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false 
						end 
					end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = Funcs.Serv("RunService").Stepped:Connect(UnCollide)
	game:GetService("RunService").Stepped:Wait()
				local resetBindable = Instance.new("BindableEvent")
				resetBindable.Event:connect(function()
				game:GetService("RunService").RenderStepped:Wait()
					Funcs.Serv("StarterGui"):SetCore("ResetButtonCallback", true)
					resetBindable:Destroy()
					CloneChar.Humanoid.Health = 0
				end)
				Funcs.Serv("StarterGui"):SetCore("ResetButtonCallback", resetBindable)
	
				coroutine.wrap(function()
					while true do
						Funcs.Serv("RunService").RenderStepped:wait()
						if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 or not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								game.Players.LocalPlayer.Character = CloneChar
								CloneChar:Destroy()
								game.Players.LocalPlayer.Character = DeadChar
								if resetBindable then
									Funcs.Serv("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()
	
				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						v:Clone().Parent = CloneChar
					end
				end
	
				for _,v in next, DeadChar:GetDescendants() do
					if v:IsA("Motor6D") and v.Name ~= "Neck" then
						v:Destroy()
					end
				end
	
				SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.2,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
	
				SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
	
				coroutine.wrap(function()
					while true do
						Funcs.Serv("RunService").RenderStepped:wait()
						if HumanDied then break end
						DeadChar["UpperTorso"].CFrame = CloneChar["Torso"].CFrame * CFrame.new(0,0.2,0)
					end
				end)()
	
				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
					end
				end
	
				for _,BodyParts in next, CloneChar:GetDescendants() do
					if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
						BodyParts.Transparency = 1 end end
	
			elseif Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
				Funcs.Serv("Players").LocalPlayer["Character"].Archivable = true 
				local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
				Funcs.Serv("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
				Funcs.Serv("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
				Funcs.Serv("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
				local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
				Instance.new("Part",FalseChar).Name = "Head" 
				Instance.new("Part",FalseChar).Name = "UpperTorso"
				Instance.new("Humanoid",FalseChar).Name = "Humanoid"
				Funcs.Serv("Players").LocalPlayer["Character"] = FalseChar
				Funcs.Serv("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
				local Clone = Funcs.Serv("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
				Clone.Parent = Funcs.Serv("Players").LocalPlayer["Character"]
				Clone.Name = "Humanoid"
				Funcs.Serv("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
				Funcs.Serv("Players").LocalPlayer["Character"].Humanoid.Health = 0 
				Funcs.Serv("Players").LocalPlayer["Character"] = workspace[Funcs.Serv("Players").LocalPlayer.Name] 
				wait(5.65) 
				Funcs.Serv("Players").LocalPlayer["Character"].Humanoid.Health = 0
				CloneChar.Parent = workspace 
				CloneChar.HumanoidRootPart.CFrame = Funcs.Serv("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,0.5,0.1)
				wait() 
				CloneChar.Humanoid.BreakJointsOnDeath = false
				workspace.Camera.CameraSubject = CloneChar.Humanoid
				CloneChar.Name = CloneCharacterName
				CloneChar.Humanoid.DisplayDistanceType = "None"
				if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
				if workspace[Funcs.Serv("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[Funcs.Serv("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end
	
				FalseChar:Destroy()
	
				local DeadChar = workspace[Funcs.Serv("Players").LocalPlayer.Name]
	
				local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
				local CONVEC
				local function VECTORUNIT()
					if HumanDied then CONVEC:Disconnect(); return end
					local lookVec = workspace.Camera.CFrame.lookVector
					local Root = CloneChar["HumanoidRootPart"]
					LVecPart.Position = Root.Position
					LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
				end
				CONVEC = Funcs.Serv("RunService").Heartbeat:Connect(VECTORUNIT)
	game:GetService("RunService").Heartbeat:Wait()
				local CONDOWN
				local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
				local function KEYDOWN(_,Processed) 
					if HumanDied then CONDOWN:Disconnect(); return end
					if Processed ~= true then
						local Key = _.KeyCode
						if Key == Enum.KeyCode.W then
							WDown = true end
						if Key == Enum.KeyCode.A then
							ADown = true end
						if Key == Enum.KeyCode.S then
							SDown = true end
						if Key == Enum.KeyCode.D then
							DDown = true end
						if Key == Enum.KeyCode.Space then
							SpaceDown = true end end end
				CONDOWN = Funcs.Serv("UserInputService").InputBegan:Connect(KEYDOWN)
	game:GetService("RunService").RenderStepped:Wait()
				local CONUP
				local function KEYUP(_)
					if HumanDied then CONUP:Disconnect(); return end
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = false end
					if Key == Enum.KeyCode.A then
						ADown = false end
					if Key == Enum.KeyCode.S then
						SDown = false end
					if Key == Enum.KeyCode.D then
						DDown = false end
					if Key == Enum.KeyCode.Space then
						SpaceDown = false end end
				CONUP = Funcs.Serv("UserInputService").InputEnded:Connect(KEYUP)
	game:GetService("RunService").RenderStepped:Wait()
				local function MoveClone(X,Y,Z)
					LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
					workspace[CloneCharacterName].Humanoid.WalkToPoint = LVecPart.Position
				end
	
				coroutine.wrap(function() 
					while true do Funcs.Serv("RunService").RenderStepped:Wait()
						if HumanDied then break end
						if WDown then MoveClone(0,0,1e4) end
						if ADown then MoveClone(1e4,0,0) end
						if SDown then MoveClone(0,0,-1e4) end
						if DDown then MoveClone(-1e4,0,0) end
						if SpaceDown then CloneChar["Humanoid"].Jump = true end
						if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
							workspace[CloneCharacterName].Humanoid.WalkToPoint = workspace[CloneCharacterName].HumanoidRootPart.Position end
					end 
				end)()
	
				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, CloneChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false 
						end 
					end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = Funcs.Serv("RunService").Stepped:Connect(UnCollide)
	game:GetService("RunService").RenderStepped:Wait()
				resetBindable = Instance.new("BindableEvent")
				resetBindable.Event:connect(function()
				game:GetService("RunService").RenderStepped:Wait()
					Funcs.Serv("StarterGui"):SetCore("ResetButtonCallback", true)
					resetBindable:Destroy()
					CloneChar.Humanoid.Health = 0
				end)
				Funcs.Serv("StarterGui"):SetCore("ResetButtonCallback", resetBindable)
	
				coroutine.wrap(function()
					while true do
						Funcs.Serv("RunService").RenderStepped:wait()
						if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								game.Players.LocalPlayer.Character = CloneChar
								CloneChar:Destroy()
								game.Players.LocalPlayer.Character = DeadChar
								if resetBindable then
									Funcs.Serv("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()
	
				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						v:Clone().Parent = CloneChar
					end
				end
	
				SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.2,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
	
				SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
	
				SCIFIMOVIELOL(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))
	
				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
					end
				end
	
				for _,BodyParts in next, CloneChar:GetDescendants() do
					if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
						BodyParts.Transparency = 1 end end
				if DeadChar.Head:FindFirstChild("Neck") then
					game.Players.LocalPlayer.Character:BreakJoints()
				end
			end
		end
	end
	
	function FEController.AntiAFK()
		local GC = getconnections or get_signal_cons
		for i,v in pairs(GC(Plr.Idled)) do
			if v["Disable"] then
				v["Disable"](v)
			elseif v["Disconnect"] then
				v["Disconnect"](v)
			end
		end
	end
	
	function FEController.AntiClientKick()
		local mt = getrawmetatable(game)
		local old = mt.__namecall
		local protect = newcclosure or protect_function
	
		if not protect then
			notify("Incompatible Exploit Warning", "Your exploit does not support protection against stack trace errors, resulting to fallback function")
			protect = function(f) return f end
		end
	
		setreadonly(mt, false)
	
		mt.__namecall = protect(function(self, ...)
			local method = getnamecallmethod()
			if method == "Kick" then
				wait(9e9)
				return
			end
			return old(self, ...)
		end)
	
		hookfunction(Plrs.LocalPlayer.Kick,protect(function() wait(9e9) end))
	end

	function FEController.AntiClientTeleport()
		local TeleportService, tp, tptpi = Funcs.Serv("TeleportService")
		tp = hookfunction(TeleportService.Teleport, function(id, ...)
			if allow_rj and id == game.Placeid then
				return tp(id, ...)
			end
			return wait(9e9)
		end)
	
		tptpi = hookfunction(TeleportService.TeleportToPlaceInstance, function(id, server, ...)
			if allow_rj and id == game.Placeid and server == game.JobId then
				return tp(id, server, ...)
			end
			return wait(9e9)
		end)
	end
	
	function FEController.AntiLGR() 
		if true then return end
		Funcs.Notify("AntiLGR v1 Loaded!")
	
		wait(1)
	
		v11:Destroy()
	
		RunService.RenderStepped:Connect(function()
		game:GetService("RunService").RenderStepped:Wait()
			local RAntiLGRPart = Instance.new("Part")
	
			RAntiLGRPart.Name = "FuckingStopPlease"
			RAntiLGRPart.Parent = workspace
			RAntiLGRPart.Transparency = 1
			RAntiLGRPart.CanCollide = false
	
			Debris:AddItem(RAntiLGRPart, 0.03)
		end)
	
		coroutine.resume(coroutine.create(function() 
			while true do
				RunService.RenderStepped:Wait()
	
				local CAntiLGRPart = Instance.new("Part")
	
				CAntiLGRPart.Name = "CanYouFuckingStopPls"
				CAntiLGRPart.Parent = workspace
				CAntiLGRPart.Transparency = 1
				CAntiLGRPart.CanCollide = false
	
				Debris:AddItem(CAntiLGRPart, 0.03)
			end
		end))
	end

	function FEController.AntiSkid()
		if true then return end
		Funcs.Hint("Shadow's Anti Skid(FE IY Fling, FE HRP Fling etc..) Loaded. Nothing can stop me! - HSE " .. SCRIPTVERSION, 5)
	
		coroutine.resume(coroutine.create(function()
			while true do
				RunService.RenderStepped:Wait()
		
				pcall(function()	
					for o, b in pairs(Plrs:GetChildren()) do
						RunService.RenderStepped:Wait()
		
						local PlrsHRP = b.Character:FindFirstChild("HumanoidRootPart")
						
						if PlrsHRP and PlrsHRP:IsA("BasePart") and PlrsHRP.Name == "HumanoidRootPart" and not PlrsHRP:FindFirstChildOfClass("Attachment") and PlrsHRP.Parent.Name ~= Plr.Name and PlrsHRP.Parent.Name ~= CloneCharacterName then
							PlrsHRP:Destroy()
							when("when1")
						end
					end
				end)
			end
		end))
		
		coroutine.resume(coroutine.create(function()
			while true do
				RunService.RenderStepped:Wait()
		
				pcall(function()	
					for o, b in pairs(Plrs:GetChildren()) do
						RunService.RenderStepped:Wait()
		
						local PlrsTorso = b.Character:FindFirstChild("Torso")
						
						if PlrsTorso and PlrsTorso:IsA("BasePart") and PlrsTorso.Name == "Torso" and PlrsTorso.RotVelocity.Magnitude > 65 and PlrsTorso.Parent.Name ~= Plr.Name and PlrsTorso.Parent.Name ~= CloneCharacterName then
							PlrsTorso:Destroy()
						end
					end
				end)
			end
		end))
	end
	
	function FEController.AntiSpam()
		Funcs.Serv("CoreGui").PurchasePromptApp.Enabled = false
	end
	
	function FEController.AntiCheatBypasser() 
		if true then return end
		Funcs.Hint("Shadow's Anti Cheat Bypasser loaded. Enjoy ur skidded script.")
	
		coroutine.resume(coroutine.create(function()
			for i, v in pairs(game:GetChildren()) do
				if v.Name ~= "Chat" and v.Name ~= "Teams" and v.Name ~= "CoreGui" then  
					coroutine.resume(coroutine.create(function()
						while true do
							pcall(function()
								RunService.RenderStepped:Wait()
		                            				
								for o, b in pairs(v:GetDescendants()) do
									RunService.RenderStepped:Wait()
									
									if b:IsA("LocalScript") and b.Name ~= "Animate" and b.Name ~= "BubbleChat" and b.Name ~= "ChatScript" then
										b.Disabled = true
									end
								end
							end)
						end
					end))
				end
			end
		end))
		
		coroutine.resume(coroutine.create(function()
			for i, v in pairs(game:GetChildren()) do
				if v.Name ~= "Chat" and v.Name ~= "Teams" and v.Name ~= "CoreGui" then  
					coroutine.resume(coroutine.create(function()
						while true do
							pcall(function()
								RunService.RenderStepped:Wait()
		                            				
								for o, b in pairs(v:GetDescendants()) do
									RunService.RenderStepped:Wait()
		                                					
									if b:IsA("Tool") then
										b:Destroy()
									end
								end
							end)
						end
					end))
				end
			end
		end))
	
		_G.ANTICHEAT_BYPASS_DONE = true
	end
	
	coroutine.resume(coroutine.create(function()
		OriginArchivable = Char.Archivable
		Char.Archivable = true
		
		CharClones.CharacterCloneLoading = workspace[Plr.Name]:Clone()
		Char.Archivable = OriginArchivable
	end))
	
	for i, v in pairs(game:GetChildren()) do
		if v.Name ~= "Chat" and v.Name ~= "Teams" and v.Name ~= "CoreGui" then  
			for o, b in pairs(v:GetDescendants()) do
				if b:IsA("LocalScript") and b.Name ~= "Animate" and b.Name ~= "BubbleChat" and b.Name ~= "ChatScript" then
					b.Disabled = true
				elseif b:IsA("RemoteEvent") then
					if b.Parent and b.Parent.Name == "DefaultChatSystemChatEvents" then
						continue
					end
					
					b:Destroy()
				elseif b:IsA("RemoteFunction") then
					if b.Parent and b.Parent.Name == "DefaultChatSystemChatEvents" then
						continue
					end
					
					b:Destroy()
				elseif b:IsA("Tool") then
					b:Destroy()
				end
			end
		end
	end
	
	for i, v in pairs(game.Players.LocalPlayer.PlayerGui:GetChildren()) do
		if v.Name ~= "Chat" and v.Name ~= "BubbleChat" then
			v:Destroy()
		end
	end

	CharClones.CharacterCloneLoading.Parent = workspace
	CharClones.CharacterCloneLoading.Name = tostring(math.random())
	
	workspace.CurrentCamera.CameraSubject = CharClones.CharacterCloneLoading.Humanoid
	workspace.CurrentCamera.CameraType = "Custom"

	coroutine.resume(coroutine.create(function() 
		while not _G.REANIMATE_DONE do
			RunService.RenderStepped:Wait()
			CharClones.CharacterCloneLoading.HumanoidRootPart.Velocity = Vector3.new(-18, 0, -18)
			CharClones.CharacterCloneLoading.HumanoidRootPart.CFrame = CFrame.new(1000000, 1000000, 1000000)
		end
	end))
	
	for i, v in next, Char:GetDescendants() do
		if (v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("Part")) and v.Name ~= "Left Leg" and v.Name ~= "Right Leg" then
			Funcs.Serv("RunService").Heartbeat:connect(function()
			game:GetService("RunService").RenderStepped:Wait()
				v.Velocity = Vector3.new(-18, 0, -18)
			end)
		elseif (v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("Part")) and (v.Name == "Left Leg" or v.Name == "Right Leg") then
			Funcs.Serv("RunService").Heartbeat:connect(function()
			game:GetService("RunService").RenderStepped:Wait()
				v.Velocity = Vector3.new(35, 0, -3.5)
			end)
		end
		
		if v:IsA("Accessory") then
			Funcs.Serv("RunService").Heartbeat:connect(function()
			game:GetService("RunService").RenderStepped:Wait()
				v.Handle.Velocity = Vector3.new(-18, 0, -18)
			end)
		end
	end
	
	local index = 1
	
	for _,v in pairs(Funcs.Serv("Players").LocalPlayer.Character:GetChildren()) do
		if v.Name == "MeshPartAccessory" and v.Handle.Size == Vector3.new(4, 4, 1) then
			v.Name = "MPASword" .. index
			index = index + 1
		elseif v.Name == "MeshPartAccessory" and v.Handle.Size == Vector3.new(2.5,2.5,2.5) then
			if v.Handle.SpecialMesh.MeshId == "rbxassetid://5507041951" then
				v.Name = "MPAWing1"
			elseif v.Handle.SpecialMesh.MeshId == "rbxassetid://5507042353" then
				v.Name = "MPAWing2"
			end
		elseif v.Name == "MeshPartAccessory" and v.Handle.Size == Vector3.new(3,3,3) then
			v.Name = "MPAAura"
		end
	end
	
	if Char:FindFirstChild("BladeMasterAccessory") ~= nil then
		if Char:FindFirstChild("BladeMasterAccessory").Handle:FindFirstChildOfClass("SpecialMesh") ~= nil then
			Char:FindFirstChild("BladeMasterAccessory").Handle.Transparency = 1
			Char:FindFirstChild("BladeMasterAccessory").Handle:FindFirstChildOfClass("SpecialMesh"):Destroy()
		end
	end
	
	if Char:FindFirstChild("MeshPartAccessory") ~= nil then
		if Char:FindFirstChild("MeshPartAccessory").Handle:FindFirstChildOfClass("SpecialMesh") ~= nil then
			Char:FindFirstChild("MeshPartAccessory").Handle:FindFirstChildOfClass("SpecialMesh"):Destroy()
		end
	end
	
	if Char:FindFirstChild("TwitterBird") ~= nil then
		if Char:FindFirstChild("TwitterBird").Handle:FindFirstChildOfClass("SpecialMesh") ~= nil then
			Char:FindFirstChild("TwitterBird").Handle:FindFirstChildOfClass("SpecialMesh"):Destroy()
		end
	end
	
	for i, v in pairs(Char:GetDescendants()) do
		if v:IsA("Decal") and v.Name == 'face' then
			v:Destroy()
		end
	end
	
	RunService.RenderStepped:Connect(function()
	game:GetService("RunService").RenderStepped:Wait()
		setsimulationradius(1000)
		Char.Parent = workspace
		Plr.PlayerScripts:FindFirstChild("BubbleChat").Disabled = true
	end)
	
	local ANCHOR_PLAYER = Funcs.Serv("Players").LocalPlayer
	local PLAYER_HRP = ANCHOR_PLAYER.Character.HumanoidRootPart
	
	ORIGIN_POS = PLAYER_HRP.CFrame
	
	Char.Archivable = true
	
	Clone_Character = workspace[Plr.Name]:Clone()
	Clone_Character2 = workspace[Plr.Name]:Clone()
	Clone_Character3 = workspace[Plr.Name]:Clone()
	
	Clone_Character.Parent = Funcs.Serv("Chat")
	Clone_Character2.Parent = Funcs.Serv("Chat")
	Clone_Character3.Parent = Funcs.Serv("Chat")
	
	Clone_Character.Name = "Main_Character"
	Clone_Character2.Name = "Main_Character"
	Clone_Character3.Name = "Main_Character"
	
	Char.Archivable = OriginArchivable
	
	coroutine.resume(coroutine.create(function()
		Clone_Character.HumanoidRootPart.Anchored = true
		Clone_Character.HumanoidRootPart.CFrame = CFrame.new(ORIGIN_POS.Position.X, ORIGIN_POS.Position.Y + 125, ORIGIN_POS.Position.Z)

		Clone_Character2.HumanoidRootPart.Anchored = true
		Clone_Character2.HumanoidRootPart.CFrame = CFrame.new(ORIGIN_POS.Position.X, ORIGIN_POS.Position.Y + 125, ORIGIN_POS.Position.Z)

		Clone_Character3.HumanoidRootPart.Anchored = true
		Clone_Character3.HumanoidRootPart.CFrame = CFrame.new(ORIGIN_POS.Position.X, ORIGIN_POS.Position.Y + 125, ORIGIN_POS.Position.Z)
	end))
	
	coroutine.resume(coroutine.create(function() 
		while not _G.REANIMATE_DONE do
			PLAYER_HRP.CFrame = CFrame.new(ORIGIN_POS.Position.X, 500, ORIGIN_POS.Position.Z)
			RunService.RenderStepped:Wait()
		end
	end))
	
	coroutine.resume(coroutine.create(function() 
	--	FEController.AntiSkid()
	--	FEController.AntiCheatBypasser()
		FEController.AntiAFK()
		FEController.AntiClientKick()
		FEController.AntiClientTeleport()
		FEController.AntiSpam()
	end))
	
	wait(0.8)
	
	--FEController.Reanimate("limbs") -- loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
	_G.REANIMATE_DONE = true
	
	wait(.1)
	
	print("(HSE) FE Controller and engine fired up...")
	local Hint = Funcs.Notify("Hyperskidded Cannon) FE Controller and engine fired up...", math.huge)
	local Useless = Instance.new("Part",Funcs.Serv("Workspace"))
	Useless.Anchored = false
	Useless.CanCollide = false
	Useless.Transparency = 1
	Useless.CanCollide = false
	Useless.CanTouch = false
	Useless.Locked = false
	Useless.Name = "qwertyuiop"
	script.Name = math.random()

	MainCharacter = workspace[Plr.Name]
	MainRootPart = MainCharacter.HumanoidRootPart
	MainTorso = MainCharacter.Torso
	MainLeftArm = MainCharacter["Left Arm"]
	MainRightArm = MainCharacter["Right Arm"]
	MainLeftLeg = MainCharacter["Left Leg"]
	MainRightLeg = MainCharacter["Right Leg"]
	
	ReanimCharacter = workspace[CloneCharacterName]
	ReanimRootPart = ReanimCharacter.HumanoidRootPart
	ReanimTorso = ReanimCharacter.Torso
	ReanimLeftArm = ReanimCharacter["Left Arm"]
	ReanimRightArm = ReanimCharacter["Right Arm"]
	ReanimLeftArm = ReanimCharacter["Left Leg"]
	ReanimRightArm = ReanimCharacter["Right Leg"]

	FEController.Teleport(ReanimCharacter.HumanoidRootPart, ORIGIN_POS * CFrame.new(0, 50, 0))
	
	wait(.1)
	Hint:Destroy()
	
	wait(.1)
	print("(HSE) FE Controller system fired up...")
	Funcs.Notify("(Hyperskidded Cannon) FE Controller system fired up...", .5)
	
	wait(.5)
	Funcs.Serv("Chat").BubbleChatEnabled = false

	Funcs.HyperSkiddedServiceNameChange()
	
	IsDead = false
	StateMover = true
	
	CannonAcc = nil
	MPAAuraAcc = nil
	MPASwordAcc1 = nil
	MPASwordAcc2 = nil
	MPASwordAcc3 = nil
	MPASwordAcc4 = nil
	MPAWingAcc1 = nil
	MPAWingAcc2 = nil
	OrbAcc = nil
	MasterSwordAcc = nil
	
	if ReanimCharacter:FindFirstChild("Starslayer Railgun") then
		CannonAcc = ReanimCharacter["Starslayer Railgun"].Handle
	end
	
	if ReanimCharacter:FindFirstChild("MPAAura") then
		MPAAuraAcc = ReanimCharacter["MPAAura"].Handle
	end
	
	if ReanimCharacter:FindFirstChild("MPASword1") then
		MPASwordAcc1 = ReanimCharacter["MPASword1"].Handle
	end
	
	if ReanimCharacter:FindFirstChild("MPASword2") then
		MPASwordAcc2 = ReanimCharacter["MPASword2"].Handle
	end
	
	if ReanimCharacter:FindFirstChild("MPASword3") then
		MPASwordAcc3 = ReanimCharacter["MPASword3"].Handle
	end
	
	if ReanimCharacter:FindFirstChild("MPASword4") then
		MPASwordAcc4 = ReanimCharacter["MPASword4"].Handle
	end
	
	if ReanimCharacter:FindFirstChild("MPAWing1") then
		MPAWingAcc1 = ReanimCharacter["MPAWing1"].Handle
	end
	
	if ReanimCharacter:FindFirstChild("MPAWing2") then
		MPAWingAcc2 = ReanimCharacter["MPAWing2"].Handle
	end
	
	if ReanimCharacter:FindFirstChild("MeshPartAccessory") then
		OrbAcc = ReanimCharacter["MeshPartAccessory"].Handle
	end
	
	if ReanimCharacter:FindFirstChild("BladeMasterAccessory") then
	    MasterSwordAcc = ReanimCharacter["BladeMasterAccessory"].Handle
	end
	
	bbv = nil; bullet = nil
	
	bullet = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	bullet.Transparency = 0.25
	bullet.Material = Enum.Material.Neon
	bullet.BrickColor = BrickColor.new("White")
	bullet.Massless = true
	
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end
	
	bbv = Instance.new("BodyPosition",bullet)
	bbv.Position = ReanimCharacter.Torso.CFrame.p
	
	if CannonAcc then
		CannonAcc:FindFirstChildOfClass("AlignPosition").Name = "AlignPosition2"
		CannonAcc:FindFirstChildOfClass("AlignOrientation").Name = "AlignOrientation2"
	end
	
	if MPAAuraAcc then
		MPAAuraAcc:FindFirstChildOfClass("AlignPosition").Name = "AlignPosition2"
		MPAAuraAcc:FindFirstChildOfClass("AlignOrientation").Name = "AlignOrientation2"
	end
	
	if MPASwordAcc1 then
		MPASwordAcc1:FindFirstChildOfClass("AlignPosition").Name = "AlignPosition2"
		MPASwordAcc1:FindFirstChildOfClass("AlignOrientation").Name = "AlignOrientation2"
	end
	
	if MPASwordAcc2 then
		MPASwordAcc2:FindFirstChildOfClass("AlignPosition").Name = "AlignPosition2"
		MPASwordAcc2:FindFirstChildOfClass("AlignOrientation").Name = "AlignOrientation2"
	end
	
	if MPASwordAcc3 then
		MPASwordAcc3:FindFirstChildOfClass("AlignPosition").Name = "AlignPosition2"
		MPASwordAcc3:FindFirstChildOfClass("AlignOrientation").Name = "AlignOrientation2"
	end
	
	if MPASwordAcc4 then
		MPASwordAcc4:FindFirstChildOfClass("AlignPosition").Name = "AlignPosition2"
		MPASwordAcc4:FindFirstChildOfClass("AlignOrientation").Name = "AlignOrientation2"
	end
	
	if MPAWingAcc1 then
		MPAWingAcc1:FindFirstChildOfClass("AlignPosition").Name = "AlignPosition2"
		MPAWingAcc1:FindFirstChildOfClass("AlignOrientation").Name = "AlignOrientation2"
	end
	
	if MPAWingAcc2 then
		MPAWingAcc2:FindFirstChildOfClass("AlignPosition").Name = "AlignPosition2"
		MPAWingAcc2:FindFirstChildOfClass("AlignOrientation").Name = "AlignOrientation2"
	end
	
	if OrbAcc then
		OrbAcc:FindFirstChildOfClass("AlignPosition").Name = "AlignPosition2"
		OrbAcc:FindFirstChildOfClass("AlignOrientation").Name = "AlignOrientation2"
	end
	
	if MasterSwordAcc then
		MasterSwordAcc:FindFirstChildOfClass("AlignPosition").Name = "AlignPosition2"
		MasterSwordAcc:FindFirstChildOfClass("AlignOrientation").Name = "AlignOrientation2"
	end
	
	ReanimCharacter.Torso.WaistBackAttachment.Position = Vector3.new(-0, -0, 0.6)
	ReanimCharacter.Torso.WaistBackAttachment.Orientation = Vector3.new(-0, -0, 0)
	
	coroutine.wrap(function()
		while true do
			Funcs.Serv("RunService").RenderStepped:wait()
	
			if IsDead then
				break
			end
	
			pcall(function()
				if not ReanimCharacter or not ReanimCharacter:FindFirstChildOfClass("Humanoid") or ReanimCharacter:FindFirstChildOfClass("Humanoid").Health <= 0 then 
					IsDead = true; 
					return 
				end
	
				if StateMover then
					if Options.HRPPosToggle then
						bbv.Position = (CFrame.new(ReanimCharacter.Torso.CFrame.Position.X, 500, ReanimCharacter.Torso.CFrame.Position.Z)).p -- ReanimCharacter.Torso.CFrame.p
						bullet.Position = (CFrame.new(ReanimCharacter.Torso.CFrame.Position.X, 500, ReanimCharacter.Torso.CFrame.Position.Z)).p -- (ReanimCharacter.Torso.CFrame * CFrame.new(0, 500, 0)).p
					else
						bbv.Position = ReanimCharacter.Torso.CFrame.p
						bullet.Position = ReanimCharacter.Torso.CFrame.p
					end
				end
			end)
		end
	end)()
	
	Funcs.Serv("RunService").RenderStepped:Connect(function() 
	game:GetService("RunService").RenderStepped:Wait()
		pcall(function()
			bbav = Instance.new("BodyAngularVelocity",bullet)
			bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
			bbav.P = 9799999999999999999999999999999999999
			bbav.AngularVelocity = Vector3.new(9799999999999999999999999999999999999, 9799999999999999999999999999999999999, 9799999999999999999999999999999999999)
	
			Funcs.Serv("Debris"):AddItem(bbav, 0.1)
		end)
	end)
	
	CDDF = {}
	
	function FEController.DamageFling(DmgPer)
		if IsDead or (DmgPer.Name == ReanimCharacter.Name and DmgPer.Name == CloneCharacterName) or CDDF[DmgPer] or not DmgPer or not DmgPer:FindFirstChildOfClass("Humanoid") or DmgPer:FindFirstChildOfClass("Humanoid").Health <= 0 then return end
	
		CDDF[DmgPer] = true; StateMover = false
		local PosFling = (DmgPer:FindFirstChild("HumanoidRootPart") and DmgPer:FindFirstChild("HumanoidRootPart").CFrame.p) or (DmgPer:FindFirstChildOfClass("Part") and DmgPer:FindFirstChildOfClass("Part").CFrame.p)
	
		bullet.Rotation = ReanimCharacter.Torso.Rotation
	
		for _=1,15 do
			bbv.Position = PosFling
			bullet.Position = PosFling
	
			Funcs.Serv("RunService").RenderStepped:wait()
		end
	
		StateMover = true
	
		bbv.Position = ReanimCharacter.Torso.CFrame.p
		bullet.Position = ReanimCharacter.Torso.CFrame.p
	
		CDDF[DmgPer] = false
	end
	
	workspace.CurrentCamera:remove()
	wait(.1)
	Funcs.Noclip()
--end)

---- Hyperskidded Echo by SUPER_TIGERPRO/super_tiger123456 (Originally edited by coldredtea) ----
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
NOMORELAGPLSAAAA = true
	do
        local script = Funcs.Serv("InsertService"):LoadLocalAsset("rbxassetid://7718123468"):FindFirstChild("irofociukwijofdwfjwod", true)
        --print(e)
        --print(script)
        local Replicatorranwarn = Instance.new("Hint", Funcs.Serv("Workspace"))
		Replicatorranwarn.Text = "(Hyperskidded Echo) Replicator and engine fired up...."
		local Useless = Instance.new("Part",Funcs.Serv("Workspace"))
		Useless.Anchored = false
		Useless.CanCollide = false
		Useless.Transparency = 1
		Useless.CanCollide = false
		Useless.CanTouch = false
		Useless.Locked = false
		Useless.Name = "qwertyuiop"
		--script.Name = math.random()
		local VISUALS = Funcs.Serv("Lighting")
		local VISUALSSz = Funcs.Serv("Lighting")
		local ColorCorrection = script["d8(*#*YRF@(diod2"]["C-Correction"]:Clone()
		local Co_Correction = ColorCorrection
		local C_Correction = ColorCorrection
		local CC = ColorCorrection
		local TerrainCol = true
		CC.Parent = Funcs.Serv("Lighting")
		local Skybox = script["d8(*#*YRF@(diod2"]["Skybox"]:Clone()
		Skybox.Parent = Funcs.Serv("Lighting")
		local lit = Funcs.Serv("Lighting")
		local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
		local SCRIPTVERSION = "v1.0x3"
		local SECURITYPATCHDATE = "23.7.2021"
		local repStorage = Funcs.Serv("ReplicatedStorage")
		local Username_ = game.Players.LocalPlayer.Name
		local Player = Funcs.Serv("Players"):FindFirstChild(Username_)
		local lplr = Funcs.Serv("Players").LocalPlayer
		local Plrs = S.Players
		local stopeverything = false
		local fonts = {"Antique","Arcade","Arial","ArialBold","Bodoni","Cartoon","Code","Fantasy","Garamond","Gotham","GothamBlack","GothamBold","GothamSemibold","Highway","SciFi","SourceSans","SourceSansBold","SourceSansItalic","SourceSansLight","SourceSansSemibold"}
		local FONTS = fonts
		local Fonts = fonts
		local alreadyfixing = false
		local FXFolder = script["d8(*#*YRF@(diod2"]["EfffeFeffefecTss"]
		FXFolder.Parent = nil

		local FolderForImportantStuffs = Instance.new("Folder", workspace)

		if FolderForImportantStuffs == nil then
			FolderForImportantStuffs = Funcs.Serv("TestService"):FindFirstChild("FDFQGFF")
		end
		if FolderForImportantStuffs == nil then
			FolderForImportantStuffs = Funcs.Serv("SoundService"):FindFirstChild("")	
		end
		if FolderForImportantStuffs == nil then
			FolderForImportantStuffs = Funcs.Serv("SoundService"):FindFirstChild("FDFQGFF")	
		end
		if FolderForImportantStuffs == nil then
			FolderForImportantStuffs = Funcs.Serv("Chat"):FindFirstChild("")
		end
		if FolderForImportantStuffs == nil then
			FolderForImportantStuffs = Funcs.Serv("Chat"):FindFirstChild("FDFQGFF")
		end
		warn("-------------------------------------------------------------------------------------------------------------------------")
		print([[
               
       
         
                           
  

  
                           
         
       
               
                                       
]])
		warn("-------------------------------------------------------------------------------------------------------------------------")
		warn("Hyperskidded Echo has been started")
		warn("(HSE) Current version: "..SCRIPTVERSION.."")
		warn("(HSE) Security patch level: "..SECURITYPATCHDATE.."")
		warn("(HSE) Current user: "..Username_.."")
		warn("(HSE) List of objects inside FolderForImportantStuffs")
		warn("-------------------------------------------------------------------------------------------------")
		for i,v in pairs(FolderForImportantStuffs:GetChildren()) do
			print("This object '"..v.Name.."' is from FolderForImportantStuffs")
		end
		warn("-------------------------------------------------------------------------------------------------")
		warn("-------------------------------------------------------------------------------------------------------------------------")
		--
		Funcs.Serv("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = "Hyperskidded Echo (HSE) "..SCRIPTVERSION.." Loaded. USE Edit by SUPER_TIGERPRO/super_tiger123456"})
		Funcs.Serv("StarterGui"):SetCore("SendNotification", {
			Title = "Hyperskidded Echo";
			Text = "Still can get killed by LC's damage...";
			Duration = 5;
			Button1 = "Okay :D";
		})
		Funcs.Serv("StarterGui"):SetCore("SendNotification", {
			Title = "Hyperskidded Echo";
			Text = "Please mind that this script is not as powerful as Hyperskidded Cannon.";
			Duration = 5;
			Button1 = "Okay :D";
		})
		local SyncFolder = Instance.new("Folder", FolderForImportantStuffs)
		local LoopType = Instance.new("StringValue", FolderForImportantStuffs)
        LoopType.Value = "Custom"
		--local DamageRemote = FolderForImportantStuffs["&*@r18r9!Y@$(R"]
		local SongLooped = Instance.new("NumberValue", FolderForImportantStuffs)
        SongLooped.Value = 9e9
		local SongVol = Instance.new("NumberValue", FolderForImportantStuffs)
        SongVol.Value = 9e9
		--local Movement = FolderForImportantStuffs["*(@#*R&$*(@*R!Yrj291r"]
		local SongMXDistance = Instance.new("NumberValue")
		SongMXDistance.Name = "&*!#$19491UU--1=$!*("
		SongMXDistance.Value = 9e9
		SongMXDistance.Parent = FolderForImportantStuffs
		local MoveType = Instance.new("StringValue")
		MoveType.Name = "!*(YR*R891rU@!(*Rde3()#"
		MoveType.Value = "Remote" -- I switched it to remote instead of smooth cuz idk 
		MoveType.Parent = FolderForImportantStuffs
        local MusID = Instance.new("NumberValue")
		MusID.Name = "&*(&*93229r8u8r27*(&&*^&*&@#(2093e2098"
		MusID.Value = 0
		MusID.Parent = FolderForImportantStuffs
		--local ChatRemote = FolderForImportantStuffs["F#@R9829rU#@(*R@#RKU)(#"]
		if stopeverything then wait(math.huge) end
		if Player and type(Player) ~= "table" then
			if lplr.Name == Username_ then
				Player.Chatted:Connect(function(teckz)
				game:GetService("RunService").RenderStepped:Wait()
					if stopeverything then wait(math.huge) end
					--ChatRemote:FireServer(teckz)
				end)
			end
		end
		Character = ReanimCharacter
		char = Character
		RealRoot = game.Players.LocalPlayer.Character.Head
        Mouse = Player:GetMouse()
		if lplr == Player then
			--[[local lMouse = Player:GetMouse()
			local HB = Funcs.Serv("RunService").Heartbeat
			local Remote = FolderForImportantStuffs["#*(R()R9r2R*U!)(@Rr21r"]
			local Remote2 = FolderForImportantStuffs["R!(!R!(*R)@IR!@R()UR(@!(RU01"]

			lMouse.KeyDown:Connect(function(Key)
			game:GetService("RunService").RenderStepped:Wait()
				Remote:FireServer("KeyDown", Key)
			end)
			lMouse.KeyUp:Connect(function(Key)
			game:GetService("RunService").RenderStepped:Wait()
				Remote:FireServer("KeyUp", Key)
			end)
			lMouse.Button1Down:Connect(function(Key)
			game:GetService("RunService").RenderStepped:Wait()
				Remote:FireServer("MouseButton1Down", Key)
			end)
			lMouse.Button1Up:Connect(function(Key)
			game:GetService("RunService").RenderStepped:Wait()
				Remote:FireServer("MouseButton1Up", Key)
			end)

			spawn(function()
				while true do
					for i = 1,1000,1 do
						HB:wait()
						Remote2["r"..i]:FireServer(lMouse.Hit, lMouse.Target)
					end
				end
			end)
		end

		local Mouse = {}

		do
			local Remote = FolderForImportantStuffs["#*(R()R9r2R*U!)(@Rr21r"]
			local Hits = FolderForImportantStuffs["R!(!R!(*R)@IR!@R()UR(@!(RU01"]
			local KeyDown = Instance.new("BindableEvent")
			local KeyUp = Instance.new("BindableEvent")
			local MouseButton1Down = Instance.new("BindableEvent")
			local MouseButton1Up = Instance.new("BindableEvent")
			local Hit = FolderForImportantStuffs["ewfqwur89eqer83(Y*(#@!RJ!@(*"]
			local Target = FolderForImportantStuffs["67$#*(@!*R(@RE=2"]
			Mouse.KeyDown = KeyDown.Event
			Mouse.KeyUp = KeyUp.Event
			Mouse.Button1Down = MouseButton1Down.Event
			Mouse.Button1Up = MouseButton1Up.Event
			Remote.OnClientEvent:Connect(function(request, ...)
			game:GetService("RunService").RenderStepped:Wait()
				if request == "KeyDown" then
					KeyDown:Fire(...)
				end
				if request == "KeyUp" then
					KeyUp:Fire(...)
				end
				if request == "MouseButton1Down" then
					MouseButton1Down:Fire(...)
				end
				if request == "MouseButton1Up" then
					MouseButton1Up:Fire(...)
				end
			end)

			Mouse.Hit = Hit.Value
			Mouse.Target = Target.Value
			if Player then
				if lplr ~= Player then
					local FakeGui = Instance.new("Folder")
					FakeGui.Name = "PlayerGui"
					FakeGui.Parent = Player
					local FakeBackpack = Instance.new("Folder")
					FakeBackpack.Name = "Backpack"
					FakeBackpack.Parent = Player
				end
			end
			local ArtificialHB = Instance.new("BindableEvent", script)
			ArtificialHB.Name = "ArtificialHB2"
			script:WaitForChild("ArtificialHB2")
			frame = 1/60
			tf = 5
			allowframeloss = false
			tossremainder = true
			lastframe = tick()
			ArtificialHB:Fire()
			Funcs.Serv("RunService").Heartbeat:connect(function(s, p)
			game:GetService("RunService").Heartbeat:Wait()
				tf = tf + s
				if tf >= frame then
					if allowframeloss then
						ArtificialHB:Fire()
						lastframe = tick()
					else
						for i = 1, math.floor(tf / frame) do
							ArtificialHB:Fire()
						end
						lastframe = tick()
					end
					if tossremainder then
						tf = 0
					else
						tf = tf - frame * math.floor(tf / frame)
					end
				end
			end)

			function BaseWait(NUMBER)
				if NUMBER == 0 or NUMBER == nil then
					if LoopType.Value == "Server" then
						SyncFolder.ChildAdded:wait()
					elseif LoopType.Value == "RenderStepped" then
						Funcs.Serv("RunService").RenderStepped:wait()
					elseif LoopType.Value == "Stepped" then
						Funcs.Serv("RunService").Stepped:wait()
					elseif LoopType.Value == "Heartbeat" then
						Funcs.Serv("RunService").Heartbeat:wait()
					elseif LoopType.Value == "Custom" then
						ArtificialHB.Event:wait()
					elseif LoopType.Value == "DefWait" then
						wait()
					end
				else
					for i = 1, NUMBER do
						if LoopType.Value == "Server" then
							SyncFolder.ChildAdded:wait()
						elseif LoopType.Value == "RenderStepped" then
							Funcs.Serv("RunService").RenderStepped:wait()
						elseif LoopType.Value == "Stepped" then
							Funcs.Serv("RunService").Stepped:wait()
						elseif LoopType.Value == "Heartbeat" then
							Funcs.Serv("RunService").Heartbeat:wait()
						elseif LoopType.Value == "Custom" then
							ArtificialHB.Event:wait()
						elseif LoopType.Value == "DefWait" then
							wait()
						end
					end
				end
			end
			swait = BaseWait
			Swait = BaseWait
			ArtificialHB.Event:Connect(function()
			game:GetService("RunService").RenderStepped:Wait()
				Mouse.Hit = Hit.Value
				Mouse.Target = Target.Value
				if Swait ~= BaseWait then
					Swait = BaseWait
				end
				if swait ~= BaseWait then
					swait = BaseWait
				end
			end)]]
		end
		Cam = Funcs.Serv("Workspace").CurrentCamera
		if lplr == Player then
			Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
		end
		--[[ if lplr == Player then
			Funcs.Serv("RunService").Heartbeat:Connect(function()
			game:GetService("RunService").RenderStepped:Wait()
				Player.Character = Character
				Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
			end)
		end --]]
		Character.Parent = Funcs.Serv("Workspace")
        lighter = Instance.new("PointLight", Character.Head)
		RootV3 = Character:WaitForChild("HumanoidRootPart")
		TorsV3 = Character:WaitForChild("Torso")
		local ActualVelocity = Vector3.new(0,0,0)
		--[[if lplr == Player then
			spawn(function()
				while true do
					local Positions = {}
					local Speeds = {}
					for i = 1,10 do
						table.insert(Positions, RootV3.CFrame)
						table.insert(Speeds, RootV3.Velocity)
						ArtificialHB.Event:wait()
					end
					Movement:FireServer(Positions, Speeds)
				end
			end)
			spawn(function()
				while true do
					Funcs.Serv("RunService").Heartbeat:wait()
					RealRoot = Funcs.Serv("Workspace").Terrain:WaitForChild(Username_.."'s REjiiwodjiwqoferhiuweuhAAUIAHuiweei")
					RealRoot.CFrame = RootV3.CFrame
				end
			end)
			Movement.OnClientEvent:Connect(function()
game:GetService("RunService").RenderStepped:Wait()
			end)
		end]]

		if lplr ~= Player then
			local Last = RootV3.Position
			Movement.OnClientEvent:Connect(function(v, Speed)
			game:GetService("RunService").RenderStepped:Wait()
				for i,v2 in pairs(v) do
					ActualVelocity = Speed[i]
					if v[i].p ~= Last then
						if MoveType.Value == "Remote" then
							print("(HSE) MoveType: Remote")
							RootV3.CFrame = v[i]
						end
						Last = v[i].p
						ArtificialHB.Event:wait()
					end
				end
			end)
			spawn(function()
				while true do
					Funcs.Serv("RunService").Heartbeat:wait()
					RealRoot = Funcs.Serv("Workspace").Terrain:WaitForChild(Username_.."'s REjiiwodjiwqoferhiuweuhAAUIAHuiweei")
					if MoveType.Value == "Smooth" then
						print("(HSE) MoveType: Smooth")
						RootV3.CFrame = RealRoot.CFrame
					end
				end
			end)
		end

		local function randomstring()
			local length = math.random(10,20)
			local array = {}
			for i = 1,length do
				array[i] = string.char(math.random(32,126))
			end
			return table.concat(array)
		end

		Shield = Instance.new("UnionOperation",Funcs.Serv("Workspace"))
		Shield.Name = "EnCorrupt"
		Shield.CanCollide = false
		Shield.Transparency = 1
		Shield.Material = "Neon"
		Shield.Color = Color3.fromRGB(0,0,0)
		Shield.Massless = true
		Shield.Size = Vector3.new(12.715, 12.9, 11.447)
		Shield.CFrame = TorsV3.CFrame
		Shield.Locked = true
		GlitchWeld = Instance.new("Weld",Shield)
		GlitchWeld.Part0 = Shield
		GlitchWeld.Part1 = TorsV3
		Shield2 = Instance.new("UnionOperation", Funcs.Serv("Workspace"))
		Shield2.Name = Username_.."Shield Anti Banish Bullets"
		Shield2.CanCollide = false
		Shield2.Transparency = 1
		Shield2.Material = "Neon"
		Shield2.Size = Vector3.new(5.3,6.3,5.3)
		Shield2.CFrame = TorsV3.CFrame
		Shield2.Locked = true
		Wed = Instance.new("Weld", Shield2)
		Wed.Part0 = Shield2
		Wed.Part1 = TorsV3
		--[[Funcs.Serv("RunService").Heartbeat:Connect(function()
		game:GetService("RunService").RenderStepped:Wait()
			if Shield.Parent~=Funcs.Serv("Workspace") then
				pcall(function()
					Shield:Remove()
				end)
				Shield = Instance.new("UnionOperation",Funcs.Serv("Workspace"))
				Shield.Name = "EnCorrupt"
				Shield.CanCollide = true
				Shield.Transparency = 1
				Shield.Material = "Neon"
				Shield.Color = Color3.fromRGB(0,0,0)
				Shield.Massless = true
				Shield.Size = Vector3.new(12.715, 12.9, 11.447)
				Shield.CFrame = TorsV3.CFrame
				Shield.Locked = true
				GlitchWeld = Instance.new("Weld",Shield)
				GlitchWeld.Part0 = Shield
				GlitchWeld.Part1 = TorsV3
			end
			if Shield2.Parent~=Funcs.Serv("Workspace") then
				pcall(function()
					Shield2:Remove()
				end)
				Shield2 = Instance.new("UnionOperation", Funcs.Serv("Workspace"))
				Shield2.Name = Username_.."Shield Anti Banish Bullets"
				Shield2.CanCollide = true
				Shield2.Transparency = 1
				Shield2.Material = "Neon"
				Shield2.Size = Vector3.new(5.3,6.3,5.3)
				Shield2.CFrame = TorsV3.CFrame
				Shield2.Locked = true
				Wed = Instance.new("Weld", Shield2)
				Wed.Part0 = Shield2
				Wed.Part1 = TorsV3
			end
			for i,v in pairs(Character:GetChildren()) do
				if v:IsA("BasePart") and v.Anchored == false and v.Position.Y < (Funcs.Serv("Workspace").FallenPartsDestroyHeight + 60) then
					local flot = Instance.new("BodyPosition")
					local spen = Instance.new("BodyGyro")
					local hu = math.huge
					flot.MaxForce = Vector3.new(hu,hu,hu)
					spen.MaxTorque = Vector3.new(hu,hu,hu)
					local spown = nil
					for o,b in pairs(Funcs.Serv("Workspace"):GetDescendants()) do
						if not b:IsDescendantOf(Character) and b:IsA("SpawnLocation") then
							spown = b
						end
					end
					if spown then
						RootV3.CFrame = CFrame.new(spown.Position.X,spown.Position.Y+(spown.Size.Y/2)+6,spown.Position.Z)
					else
						local base = Funcs.Serv("Workspace"):FindFirstChild("Base")
						if not base then
							base = Funcs.Serv("Workspace"):FindFirstChild("Baseplate")
						end
						if base then
							RootV3.CFrame = CFrame.new(math.clamp(RootV3.Position.X,(-base.Size.X/2)+5,(base.Size.X/2)-5),base.Position.Y+(base.Size.Y/2)+6,math.clamp(RootV3.Position.Z,(-base.Size.X/2)+5,(base.Size.X/2)-5))
						else
							RootV3.CFrame = CFrame.new(math.clamp(RootV3.Position.X,-100,100),30,math.clamp(RootV3.Position.Z,-100,100))
						end
					end
					flot.Position = RootV3.Position
					flot.Parent = RootV3
					spen.CFrame = RootV3.CFrame
					spen.Parent = RootV3
					Funcs.Serv("Debris"):AddItem(flot,1)
					Funcs.Serv("Debris"):AddItem(spen,1)
				end
			end
		end)]]

		Replicatorranwarn:Destroy()

		--[[ if Funcs.Serv("Players"):FindFirstChild(Player.Name) then
			if lplr.Name ~= Player.Name then
				Player.Parent = nil
			end
		end --]]
		--[[ Funcs.Serv("Players").PlayerAdded:Connect(function()
		game:GetService("RunService").RenderStepped:Wait()
			if Funcs.Serv("Players"):FindFirstChild(Player.Name) then
				if lplr.Name ~= Player.Name then
					Player.Parent = nil
				end
			end
		end) --]]

		PlayerGui = Player.PlayerGui
		Cam = Funcs.Serv("Workspace").CurrentCamera
		Backpack = Player.Backpack
		--[[ if lplr == Player then
			Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
		end --]]
		--[[ if lplr == Player then
			Funcs.Serv("RunService").Heartbeat:Connect(function()
			game:GetService("RunService").RenderStepped:Wait()
				Player.Character = Character
				Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
			end)
		end
		Character.PrimaryPart = Character.HumanoidRootPart
		Character.Parent = Funcs.Serv("Workspace") --]]
		Humanoid = Character.Humanoid
		RootPart = Character["HumanoidRootPart"]
		CRootPart = Character.HumanoidRootPart:Clone()
		VRootPart = Character.HumanoidRootPart:Clone()
		CameraRootPart = Character.HumanoidRootPart:Clone()
		Torso = Character["Torso"]
		Head = Character["Head"]
		RightArm = Character["Right Arm"]
		LeftArm = Character["Left Arm"]
		RightLeg = Character["Right Leg"]
		LeftLeg = Character["Left Leg"]
		RootJoint = RootPart["RootJoint"]
		Neck = Torso["Neck"]
		RightShoulder = Torso["Right Shoulder"]
		LeftShoulder = Torso["Left Shoulder"]
		RightHip = Torso["Right Hip"]
		LeftHip = Torso["Left Hip"]

		CRootPart.Parent = Character
		CRootPart.Name = "CHumanoidRootPart"
		CRootPart.Anchored = true
		VRootPart.Parent = Character
		VRootPart.Name = "VHumanoidRootPart"
		VRootPart.Anchored = true
		CameraRootPart.Parent = Character
		CameraRootPart.Name = "CameraHumanoidRootPart"
		CameraRootPart.Anchored = true
		CameraRootPart.CFrame = RootPart.CFrame
		CRootPart:ClearAllChildren()
		VRootPart:ClearAllChildren()
		CameraRootPart:ClearAllChildren()

		GroundMababjin = Instance.new("Part", Character)
		GroundMababjin.Anchored = true
		GroundMababjin.Transparency = 1

		OrbAccAthp = Instance.new("Attachment", RootPart)
		OrbAccAtho = Instance.new("Attachment", RootPart)
		MPASwordAthp1 = Instance.new("Attachment", CRootPart)
		MPASwordAtho1 = Instance.new("Attachment", CRootPart)
		MPASwordAthp2 = Instance.new("Attachment", CRootPart)
		MPASwordAtho2 = Instance.new("Attachment", CRootPart)
		MPASwordAthp3 = Instance.new("Attachment", CRootPart)
		MPASwordAtho3 = Instance.new("Attachment", CRootPart)
		MPASwordAthp4 = Instance.new("Attachment", CRootPart)
		MPASwordAtho4 = Instance.new("Attachment", CRootPart)

		if MPAAuraAcc then
			MPAAuraAccAthp = Instance.new("Attachment",GroundMababjin)
			MPAAuraAccAtho = Instance.new("Attachment",GroundMababjin)

			MPAAuraAccAthp.Name = "Attachment1"
			MPAAuraAccAtho.Name = "Attachment2"

			MPAAuraAccAthp.Position = Vector3.new(0, 0, 0)
			MPAAuraAccAtho.Rotation = Vector3.new(0, 0, 0)

			MPAAuraAcc:FindFirstChildOfClass("AlignPosition").Attachment1 = MPAAuraAccAthp
			MPAAuraAcc:FindFirstChildOfClass("AlignOrientation").Attachment1 = MPAAuraAccAtho
		end

		local TIME = 0

		local Sick = Instance.new("Sound",Head)
		Sick.Name = "qeriopkeriio**(8r7839rjxxjxeroji31op"
		Sick.SoundId = "rbxassetid://"..MusID.Value
		Sick.MaxDistance = SongMXDistance.Value
		Sick.Volume = SongVol.Value
		Sick.Looped = SongLooped.Value
		if Sick.IsPlaying == false then
			Sick:Play()
		end
		Sick.Parent = Torso

		-- local NORMALFACE = Head:FindFirstChildWhichIsA("Decal").Texture

		IT = Instance.new
		CF = CFrame.new
		VT = Vector3.new
		RAD = math.rad
		C3 = Color3.new
		UD2 = UDim2.new
		BRICKC = BrickColor.new
		ANGLES = CFrame.Angles
		EULER = CFrame.fromEulerAnglesXYZ
		COS = math.cos
		ACOS = math.acos
		SIN = math.sin
		ASIN = math.asin
		ABS = math.abs
		MATHR = math.random
		FLOOR = math.floor

		--//=================================		--|| 	         Bruh
		--=================================//
		local NoLeaving = Instance.new("ScreenGui")
		NoLeaving.Name = "NoLeaving"
		NoLeaving.DisplayOrder = 2147483647
		NoLeaving.ResetOnSpawn = false
		NoLeaving.IgnoreGuiInset = true
		local RejoinShit = Instance.new("TextLabel")
		RejoinShit.Name = "RejoinShit"
		RejoinShit.Size = UDim2.new(1, 0, 1, 0)
		RejoinShit.BackgroundColor3 = Color3.fromRGB(0, 0, 127)
		RejoinShit.FontSize = Enum.FontSize.Size14
		RejoinShit.TextSize = 14
		RejoinShit.TextColor3 = Color3.fromRGB(0, 255, 0)
		RejoinShit.Text = ([[
               
       
         
                           
  

  
                           
         
       
               
                                       
]])
		RejoinShit.TextWrap = true
		RejoinShit.Font = Enum.Font.SourceSans
		RejoinShit.TextWrapped = true
		RejoinShit.TextScaled = true
		RejoinShit.Parent = NoLeaving
		Funcs.Serv("ReplicatedFirst"):RemoveDefaultLoadingScreen()
		Funcs.Serv("TeleportService"):SetTeleportGui(NoLeaving)

		--//=================================		--|| 	      USEFUL VALUES
		--=================================//

		Animation_Speed = 3.0
		Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
		local Speed = 30
		local SIZE = 1
		local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
		local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
		local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
		local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
		local DAMAGEMULTIPLIER = 1
		local ANIM = "Idle"
		local ATTACK = false
		local FEATTACK = false
		local EQUIPPED = false
		local HOLD = false
		local COMBO = 1
		local Rooted = false
		local SINE = 0
		local sine = 0
		local vissine = 0
		local KEYHOLD = false
		local CHANGE = 2 / Animation_Speed
		local WALKINGANIM = false
		local VALUE1 = false
		local VALUE2 = false
		local ROBLOXIDLEANIMATION = IT("Animation")
		ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
		ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
		local Weapon = IT("Model")
		local Effects = IT("Folder")
		Effects.Name = "Effects"
		local UNANCHOR = true
		local TOBANISH = {}
		local TOBAN = {}
		local TOGUI = {}
		local TAIL = {}
		local VSONGS = {322621962,569026863,502771070,408862087,1471935327,236336857,2280063143,334259331,344685843,1479420512,297754476,591661590,1571736139,2988953773,130768805,2516100492,580535766,213546066,555947343,394236634,195822354,224584376,1576288222,199265353}
		local NK = {271068069,247967952,265024602,252591491,252591097,316039490,1222970152,1222970152}
		local Hue = 0
		local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
		local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
		local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
		local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))

		AntiBullet = true
		local PLAYANIMS = true
		local HITFLOOR, HITPOS = nil
		local WEAPONEQUIPPED = false
		local GUNEQUIPPED = false
		local CANNONEQUIPPED = false
		local INTRODONE = false
		local inf = 9e9
		local RUNNING = false

		local Player_Size = SIZE
		local Animation_Speed2 = 5
		local SCALE = 2

		local RunService = Funcs.Serv("RunService")
		local COLORSHIFT = C3(0,0,0)
		local MODE = 1

		local FONTS = {
			Enum.Font.Antique,
			Enum.Font.Arcade,
			Enum.Font.Arial,
			Enum.Font.ArialBold,
			Enum.Font.Bodoni,
			Enum.Font.Cartoon,
			Enum.Font.Code,
			Enum.Font.Fantasy,
			Enum.Font.Garamond,
			Enum.Font.Highway,
			Enum.Font.Legacy,
			Enum.Font.SciFi,
			Enum.Font.SourceSans,
			Enum.Font.SourceSansBold,
			Enum.Font.SourceSansItalic,
			Enum.Font.SourceSansLight,
			Enum.Font.SourceSansSemibold
		}

		local mtext1 = Instance.new("BillboardGui",Character)
		mtext1.AlwaysOnTop = true
		mtext1.Size = UDim2.new(7,35,3,15)
		mtext1.StudsOffset = Vector3.new(0,5,0)
		mtext1.MaxDistance = 10000
		mtext1.Adornee = Head
		mtext1.Name = "Name2"
		local mtext2 = Instance.new("TextLabel",mtext1)
		mtext2.BackgroundTransparency = 1
		mtext2.TextScaled = true
		mtext2.BorderSizePixel = 0
		mtext2.Text = "Normal"
		mtext2.Font = "Arcade"
		mtext2.TextSize = 35
		mtext2.TextStrokeTransparency = 1
		mtext2.Size = UDim2.new(1,0,0.5,0)
		mtext2.Parent = mtext1
		mtext2.TextColor3 = COLORSHIFT
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()
				mtext2.Font = FONTS[MATHR(1, #FONTS)]
				mtext2.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))
			end
		end))

		local MATERIALS = {
			Enum.Material.Brick,
			Enum.Material.Cobblestone,
			Enum.Material.Concrete,
			Enum.Material.CorrodedMetal,
			Enum.Material.DiamondPlate,
			Enum.Material.Fabric,
			Enum.Material.Foil,
			Enum.Material.ForceField,
			Enum.Material.Glass,
			Enum.Material.Granite,
			Enum.Material.Grass,
			Enum.Material.Ice,
			Enum.Material.Marble,
			Enum.Material.Metal,
			Enum.Material.Neon,
			Enum.Material.Pebble,
			Enum.Material.Plastic,
			Enum.Material.Sand,
			Enum.Material.Slate,
			Enum.Material.SmoothPlastic,
			Enum.Material.Wood,
			Enum.Material.WoodPlanks
		}

		local BruhChatLol
		coroutine.resume(coroutine.create(function()
			for i,v in pairs(lplr:FindFirstChildWhichIsA("PlayerGui"):WaitForChild("Chat"):GetDescendants()) do
				if v:IsA('TextLabel') then
					if v.Text == "Hyperskidded Echo (HSE) "..SCRIPTVERSION.." Loaded. USE Edit by SUPER_TIGERPRO/super_tiger123456" then
						BruhChatLol = v
						break
					end
				end
			end
		end))
		
		--pcall(function()

			do

				--//=================================				--|| 	      HEAD EFFECT
				--=================================//


				Head.Transparency = 1

				if Head:FindFirstChildOfClass("Decal") then
					Head:FindFirstChildOfClass("Decal"):Destroy()
				end
				script["DE#3989fd03ud"]["HeadParticle"]:Clone().Parent = Head

				--//=================================				--|| 	       R_ARM EFFECT
				--=================================//

				RightArm.Transparency = 0
				RightArm.Material = "ForceField"
				RightArm.Color = Color3.fromRGB(255, 255, 255)


				--//=================================				--|| 	       R_LEG EFFECT
				--=================================//

				RightLeg.Transparency = 0
				RightLeg.Material = "ForceField"
				RightLeg.Color = Color3.fromRGB(255, 255, 255)


				--//=================================				--|| SAZERENOS' ARTIFICIAL HEARTBEAT
				--=================================//


				gui555 = Instance.new("ScreenGui")
				gui555.Parent = PlayerGui
				exitbutton = Instance.new("TextButton",gui555)
				exitbutton.TextScaled = true
				exitbutton.Font = "Code"
				exitbutton.Name = randomstring()
				exitbutton.BorderSizePixel = 0
				exitbutton.BackgroundTransparency = .5
				exitbutton.TextStrokeTransparency = 0
				exitbutton.BackgroundColor3 = Color3.new(.5,.5,.5)
				exitbutton.Text = "Leave Game"
				exitbutton.Size = UDim2.new(.25,0,0,36)
				exitbutton.AnchorPoint = Vector2.new(.5,1)
				exitbutton.Position = UDim2.new(.5,0,0,0)
				exitbutton.MouseButton1Click:Connect(function()
				game:GetService("RunService").RenderStepped:Wait()
					Player:kick("You Left!")
				end)

				ArtificialHB = Instance.new("BindableEvent", script)
				ArtificialHB.Name = "ArtificialHB"

				script:WaitForChild("ArtificialHB")

				frame = Frame_Speed
				tf = 0
				allowframeloss = false
				tossremainder = false
				lastframe = tick()
				script.ArtificialHB:Fire()

				Funcs.Serv("RunService").Heartbeat:connect(function(s, p)
				game:GetService("RunService").RenderStepped:Wait()
					tf = tf + s
					if tf >= frame then
						if allowframeloss then
							script.ArtificialHB:Fire()
							lastframe = tick()
						else
							for i = 1, math.floor(tf / frame) do
								script.ArtificialHB:Fire()
							end
							lastframe = tick()
						end
						if tossremainder then
							tf = 0
						else
							tf = tf - frame * math.floor(tf / frame)
						end
					end
				end)

				--//=================================				--|| 	          WINGS
				--=================================//


				local LWing = Instance.new("Part")
				LWing.Parent = Character
				LWing.Size = Vector3.new(4, 1, 2)
				LWing.Color = COLORSHIFT
				LWing.Name = Player.Name.."'s Left Wing Of Madness"
				LWing.Anchored = false
				LWing.Locked = true
				local LWingMsh = Instance.new("SpecialMesh")
				LWingMsh.Parent = LWing
				LWingMsh.Offset = Vector3.new()
				LWingMsh.Scale = Vector3.new(0.0480000004, 0.0480000004, 0.0480000004)
				LWingMsh.MeshType = "FileMesh"
				LWingMsh.MeshId = "rbxassetid://1553468234"
				local RWing = Instance.new("Part")
				RWing.Parent = Character
				RWing.Size = Vector3.new(4, 1, 2)
				RWing.Color = COLORSHIFT
				RWing.Name = Player.Name.."'s Right Wing Of Madness"
				RWing.Anchored = false
				RWing.Locked = true
				local RWingMsh = Instance.new("SpecialMesh")
				RWingMsh.Parent = RWing
				RWingMsh.Offset = Vector3.new()
				RWingMsh.Scale = Vector3.new(0.0480000004, 0.0480000004, 0.0480000004)
				RWingMsh.MeshType = "FileMesh"
				RWingMsh.MeshId = "rbxassetid://1553468709"
				local LWingWld = Instance.new("Motor6D")
				LWingWld.Parent = LWing
				LWingWld.Part0 = Torso
				LWingWld.Part1 = LWing
				LWingWld.C0 = CFrame.new(-0.25, 0.5, 0.5)*CFrame.fromEulerAnglesXYZ(0, 1.57, 0)
				LWingWld.C1 = CFrame.new(1.1, 1, 0.95)
				local RWingWld = Instance.new("Motor6D")
				RWingWld.Parent = RWing
				RWingWld.Part0 = Torso
				RWingWld.Part1 = RWing
				RWingWld.C0 = CFrame.new(0.25, 0.5, 0.5)*CFrame.fromEulerAnglesXYZ(0, 1.57, 0)
				RWingWld.C1 = CFrame.new(1.1, 1, -0.95)


				--//=================================				--|| 	      SOME FUNCTIONS
				--=================================//

				local outer = IT("Part")
				outer.Locked = true
				outer.Transparency = 1
				outer.CanCollide = false
				outer.Shape = Enum.PartType.Cylinder
				outer.Size = VT(0.1, 1, 1)
				outer.Material = Enum.Material.Neon
				outer.Color = C3(255,255,255)
				outer.Parent = Character

				local outerm = IT("SpecialMesh")
				outerm.MeshType = Enum.MeshType.Cylinder
				outerm.Parent = outer

				local weld1 = Instance.new("Weld")
				weld1.Part0 = outer
				weld1.Part1 = Character["HumanoidRootPart"]
				weld1.Parent = outer
				weld1.C0 = CF(-2.95, 0, 0) * ANGLES(0, 0, 1.571)
				coroutine.wrap(function()
					--Funcs.Serv("Workspace").Baseplate:ClearAllChildren()
					while true do wait()
                    if not NOMORELAGPLSAAAA then
						if MODE == 1 then
							outer.Color = Color3.new(Sick.PlaybackLoudness/500,0,0)
						elseif MODE == 2 then
							outer.Color = Color3.new(Sick.PlaybackLoudness/500,0,0)
						elseif MODE == 3 then
							outer.Color = Color3.new(math.min(1,Sick.PlaybackLoudness/1000),math.min(1,Sick.PlaybackLoudness/1000),math.min(1,Sick.PlaybackLoudness/1000))
						elseif MODE == 4 then
							outer.Color = Color3.fromRGB(0, 0, 0)	
						elseif MODE == 5 then
							outer.Color = Color3.fromRGB(234, 97, 0)	
						elseif MODE == 6 then
							outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
						elseif MODE == 7 then
							outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
						elseif MODE == 8 then
							outer.Color = Color3.fromRGB(0,math.random(0,255),0)
						elseif MODE == 9 then
							outer.Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000)
						elseif MODE == 10 then
							outer.Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/400,0,0+170*Sick.PlaybackLoudness/400)					
						elseif MODE == 11 then
							outer.Color = Color3.fromRGB(100*Sick.PlaybackLoudness/500,0,0)
						elseif MODE == 12 then
							outer.Color = BrickColor.Random().Color
						elseif MODE == 13 then
							outer.Color = Color3.fromRGB(0, 0, 0)
						elseif MODE == 14 then
							outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
						elseif MODE == 15 then
							outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
						elseif MODE == 16 then
							outer.Color = Color3.new(1,0,0)					
						elseif MODE == 17 then
							outer.Color = C3(98/255 + Sick.PlaybackLoudness/1000, 37/255 + Sick.PlaybackLoudness/1000, 209/255 + Sick.PlaybackLoudness/1000)					
						elseif MODE == 18 then
							outer.Color = Color3.fromRGB(100*Sick.PlaybackLoudness/100)		
						elseif MODE == 19 then
							outer.Color = Color3.fromRGB(0,0,178*Sick.PlaybackLoudness/100)
						elseif MODE == 20 then
							outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
						end
                    else
                    if MODE == 1 then
							outer.Color = Color3.new(125/500,0,0)
						elseif MODE == 2 then
							outer.Color = Color3.new(125/500,0,0)
						elseif MODE == 3 then
							outer.Color = Color3.new(math.min(1,125/1000),math.min(1,125/1000),math.min(1,125/1000))
						elseif MODE == 4 then
							outer.Color = Color3.fromRGB(0, 0, 0)	
						elseif MODE == 5 then
							outer.Color = Color3.fromRGB(234, 97, 0)	
						elseif MODE == 6 then
							outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
						elseif MODE == 7 then
							outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
						elseif MODE == 8 then
							outer.Color = Color3.fromRGB(0,math.random(0,255),0)
						elseif MODE == 9 then
							outer.Color = Color3.fromRGB(0+170*125/1000,0,0+170*125/1000)
						elseif MODE == 10 then
							outer.Color = Color3.fromRGB(0+170*125/400,0,0+170*125/400)					
						elseif MODE == 11 then
							outer.Color = Color3.fromRGB(100*125/500,0,0)
						elseif MODE == 12 then
							outer.Color = BrickColor.Random().Color
						elseif MODE == 13 then
							outer.Color = Color3.fromRGB(0, 0, 0)
						elseif MODE == 14 then
							outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
						elseif MODE == 15 then
							outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
						elseif MODE == 16 then
							outer.Color = Color3.new(1,0,0)					
						elseif MODE == 17 then
							outer.Color = C3(98/255 + 125/1000, 37/255 + 125/1000, 209/255 + 125/1000)					
						elseif MODE == 18 then
							outer.Color = Color3.fromRGB(100*125/100)		
						elseif MODE == 19 then
							outer.Color = Color3.fromRGB(0,0,178*125/100)
						elseif MODE == 20 then
							outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
						end
                        end
					end
				end)()
				function Rejoin()
					--Funcs.Serv("TeleportService"):TeleportToPlaceInstance(game.PlaceId,game.JobId)
				end
				--[[ Funcs.Serv("GuiService").MenuOpened:Connect(function()
				game:GetService("RunService").RenderStepped:Wait()
					if lplr.Name ~= Player.Name then
						Rejoin()
					end
				end) --]]

				function TerrainColSwitch()
					TerrainCol = false
					Notify("[coroutine.close]: ","(TERRAIN) Color changes has been auto set to false to reduce lag.")
					if true then return end

					if TerrainCol == false then
						TerrainCol = true
						Notify("[Hyperskidded Echo]: ","(TERRAIN) Color changes has been set to true")
					else
						TerrainCol = false
						Notify("[Hyperskidded Echo]: ","(TERRAIN) Color changes has been set to false")
					end
				end

				function warnedpeople2(whom)
					if true then return end
					for i,v in pairs(Funcs.Serv("Players"):GetPlayers()) do
						coroutine.resume(coroutine.create(function()
							if v.PlayerGui:FindFirstChild("ARRIVAL")~= nil then
								v.PlayerGui:FindFirstChild("ARRIVAL"):destroy()
							end
							local droppingFrame = false
							local scrg = Instance.new("ScreenGui",v.PlayerGui)
							scrg.Name = "ARRIVAL"
							local mainFrame = Instance.new("Frame", scrg)
							mainFrame.Name = "MainFrame"
							mainFrame.BackgroundTransparency = 1
							mainFrame.BorderSizePixel = 0
							mainFrame.Size = UDim2.new(1, 0, -0.013, 100)
							mainFrame.Position = UDim2.new(0, 0, 0.365, 0)
							local TextFrame = Instance.new("TextLabel",mainFrame)
							TextFrame.Name = "TextFrame"
							TextFrame.Font = "Arcade"
							TextFrame.Text = ""
							TextFrame.TextScaled = true
							TextFrame.TextSize = 9
							TextFrame.TextStrokeTransparency = 1
							TextFrame.BackgroundTransparency = 1
							TextFrame.TextColor3 = Color3.new(1, 1, 1)
							TextFrame.TextStrokeColor3 = Color3.new(1, 1, 1)
							TextFrame.Size = UDim2.new(1, 0, 0, 92)
							TextFrame.Position = UDim2.new(0, 0, 0, 0)
							local fvalen = 0.55
							local fval = -0.49
							coroutine.resume(coroutine.create(function()
								while true do
									Swait()
									mainFrame.BackgroundColor3 = outer.Color
									mainFrame.BorderColor3 = outer.Color
									local randomfont = fonts[MATHR(1,#fonts)]
									TextFrame.Font = randomfont
									TextFrame.TextColor3 = outer.Color
									if(not droppingFrame)then
										mainFrame.Rotation = 0 - 2 * math.cos(SINE / 24)
									end
									TextFrame.TextStrokeTransparency = 0
								end
							end))
							for i = 1,string.len(whom),1 do
								TextFrame.Text = string.sub(whom,1,i)
								Swait()
							end
							wait(2)
							droppingFrame = true
							mainFrame.Rotation = 0
							local vinc2 = 1
							for i = 0, 99 do
								Swait()
								vinc2 = vinc2 + 0.25
								mainFrame.Position = mainFrame.Position + UDim2.new(0,0,0.0005*vinc2,0)
							end
							scrg:Destroy()
						end))
					end
				end
				function warnedpeople2pp(whom)
					if true then return end
					for i,v in pairs(Funcs.Serv("Players"):GetPlayers()) do
						coroutine.resume(coroutine.create(function()
							if v.PlayerGui:FindFirstChild("ARRIVAL")~= nil then
								v.PlayerGui:FindFirstChild("ARRIVAL"):destroy()
							end
							local droppingFrame = false
							local scrg = Instance.new("ScreenGui",v.PlayerGui)
							scrg.Name = "ARRIVAL"
							local mainFrame = Instance.new("Frame", scrg)
							mainFrame.Name = "MainFrame"
							mainFrame.BackgroundTransparency = 1
							mainFrame.BorderSizePixel = 0
							mainFrame.Size = UDim2.new(1, 0, -0.013, 100)
							mainFrame.Position = UDim2.new(0, 0, 0.365, 0)
							local TextFrame = Instance.new("TextLabel",mainFrame)
							TextFrame.Name = "TextFrame"
							TextFrame.Font = "Arcade"
							TextFrame.Text = ""
							TextFrame.TextScaled = true
							TextFrame.TextSize = 9
							TextFrame.TextStrokeTransparency = 1
							TextFrame.BackgroundTransparency = 1
							TextFrame.TextColor3 = Color3.new(1, 1, 1)
							TextFrame.TextStrokeColor3 = Color3.new(1, 1, 1)
							TextFrame.Size = UDim2.new(1, 0, 0, 92)
							TextFrame.Position = UDim2.new(0, 0, 0, 0)
							local fvalen = 0.55
							local fval = -0.49
							coroutine.resume(coroutine.create(function()
								while true do
									Swait()
									mainFrame.BackgroundColor3 = outer.Color
									mainFrame.BorderColor3 = outer.Color
									TextFrame.TextColor3 = outer.Color
									if(not droppingFrame)then
										mainFrame.Rotation = 0 - 2 * math.cos(SINE / 24)
									end
									TextFrame.TextStrokeTransparency = 0
								end
							end))
							for i = 1,string.len(whom),1 do
								TextFrame.Text = string.sub(whom,1,i)
								wait(0.05)
							end
							wait(2)
							droppingFrame = true
							mainFrame.Rotation = 0
							local vinc2 = 1
							for i = 0, 99 do
								Swait()
								vinc2 = vinc2 + 0.25
								mainFrame.Position = mainFrame.Position + UDim2.new(0,0,0.0005*vinc2,0)
							end
							scrg:Destroy()
						end))
					end
				end

				function spawnwave(POS)
					if true then return end
					local HITFLOOR,HITPOS = Raycast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, Character)
					local EMITPOS = HITPOS
					if HITFLOOR ~= nil then
						if HITFLOOR.Parent:FindFirstChildOfClass("Humanoid") then
							HITFLOOR,HITPOS = Raycast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, HITFLOOR.Parent)
							EMITPOS = HITPOS
						elseif HITFLOOR.Parent.Parent:FindFirstChildOfClass("Humanoid") then
							HITFLOOR,HITPOS = Raycast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, HITFLOOR.Parent.Parent)
							EMITPOS = HITPOS
						end
					end
					if HITFLOOR ~= nil then
						mdmg(EMITPOS,55)
						WACKYEFFECT({EffectType = "Sphere", Size = VT(55,100000,55), Size2 = VT(0,100000,0), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS) * ANGLES(RAD(MATHR(-15,15)), RAD(0), RAD(MATHR(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = outer.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 5})
						WACKYEFFECT({TIME = MATHR(0,44), EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(77 + 7 * COS(SINE/4),2 + 6 * COS(SINE/4),77 + 4 * COS(SINE/4)), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-22,22), RotationZ = 0, Material = "ForceField", Color = outer.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						for i = 1, 5 do
							local TOPOS = CF(EMITPOS)*ANGLES(RAD(MATHR(0,360)),RAD(MATHR(0,360)),RAD(MATHR(0,360)))*CF(0,0,12)
							WACKYEFFECT({TIME = MATHR(0,44), EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(77 + 7 * COS(SINE/4),2 + 6 * COS(SINE/4),77 + 4 * COS(SINE/4)), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS,TOPOS.p), MoveToPos = TOPOS.p, RotationX = 0, RotationY = MATHR(-22,22), RotationZ = 0, Material = "ForceField", Color = outer.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						end
					end
				end

				function Serv(Name)
					return game:GetService(Name)
				end
				DebrisFORSOMETHING = Funcs.Serv("Debris")
				local Services = {"RunService","GuiService","Stats","SoundService","LogService","ContentProvider","KeyframeSequenceProvider","Chat","MarketplaceService","Players","PointsService","AdService","NotificationService","ReplicatedFirst","HttpRbxApiService","TweenService","TextService","StarterPlayer","StarterPack","StarterGui","LocalizationService","PolicyService","TeleportService","JointsService","CollectionService","PhysicsService","BadgeService","Geometry","FriendService","InsertService","GamePassService","Debris","TimerService","CookiesService","UserInputService","KeyboardService","MouseService","VRService","ContextActionService","ScriptService","AssetService","TouchInputService","BrowserService","AnalyticsService","ScriptContext","Selection","HttpService","MeshContentProvider","Lighting","SolidModelContentProvider","GamepadService","ControllerService","RuntimeScriptService","HapticService","NetworkClient","ChangeHistoryService","Visit","GuidRegistryService","PermissionsService","Teams","ReplicatedStorage","TestService","SocialService","MemStorageService","GroupService","PathfindingService","VirtualUser"}
				function Notify(StarterText,Text)
					if not Player:FindFirstChildOfClass("PlayerGui") then
						return
					end
					coroutine.resume(coroutine.create(function()
						local NotifHolder = Instance.new("ScreenGui")
						NotifHolder.DisplayOrder = 2147483647
						NotifHolder.Name = "LMAO"
						NotifHolder.ResetOnSpawn = false
						NotifHolder.Archivable = false
						local NotifText = Instance.new("TextLabel")
						NotifText.BackgroundTransparency = 1
						NotifText.Name = "AAAAAAAAAAAAAAAAAAAAAAAAAA"
						NotifText.Position = UDim2.new(0,0,1,0)
						NotifText.Text = StarterText
						NotifText.Size = UDim2.new(1,0,.05,0)
						NotifText.Archivable = false
						NotifText.Font = Enum.Font.SourceSans
						NotifText.TextSize = 14
						NotifText.TextScaled = true
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								NotifText.TextColor3 = Character.Torso.Color
							end
						end))
						NotifText.TextStrokeTransparency = 0
						NotifText.TextXAlignment = Enum.TextXAlignment.Left
						NotifText.Parent = NotifHolder
						NotifHolder.Parent = Player:FindFirstChildOfClass("PlayerGui")
						NotifText:TweenPosition(UDim2.new(0,0,.95,0))
						local Timer = tick()
						repeat
							Serv("RunService").Heartbeat:Wait()
						until tick()-Timer >= 1
						Timer = tick()
						local LastLen = 0
						repeat
							Serv('RunService').Heartbeat:Wait()
							local Len = math.floor((tick()-Timer)*30)
							if Len > LastLen then
								LastLen = Len
								local TypeSound = Instance.new("Sound")
								TypeSound.Volume = 10
								TypeSound.SoundId = "rbxassetid://615716445"
								TypeSound.TimePosition = .07
								TypeSound.PlayOnRemove = true
								TypeSound.Playing = true
								TypeSound.Parent = Serv(Services[math.random(1,#Services)])
								TypeSound:Destroy()
								function Notify(StarterText,Text)
									if not Player:FindFirstChildOfClass("PlayerGui") then
										return
									end
									coroutine.resume(coroutine.create(function()
										local NotifHolder = Instance.new("ScreenGui")
										NotifHolder.DisplayOrder = 2147483647
										NotifHolder.Name = "LMAO"
										NotifHolder.ResetOnSpawn = false
										NotifHolder.Archivable = false
										local NotifText = Instance.new("TextLabel")
										NotifText.BackgroundTransparency = 1
										NotifText.Name = "AAAAAAAAAAAAAAAAAAAAAAAAAA"
										NotifText.Position = UDim2.new(0,0,1,0)
										NotifText.Text = StarterText
										NotifText.Size = UDim2.new(1,0,.05,0)
										NotifText.Archivable = false
										NotifText.Font = Enum.Font.SourceSans
										NotifText.TextSize = 14
										NotifText.TextScaled = true
										coroutine.resume(coroutine.create(function()
											while true do
												Swait()
												NotifText.TextColor3 = Character.Torso.Color
											end
										end))
										NotifText.TextStrokeTransparency = 0
										NotifText.TextXAlignment = Enum.TextXAlignment.Left
										NotifText.Parent = NotifHolder
										NotifHolder.Parent = Player:FindFirstChildOfClass("PlayerGui")
										NotifText:TweenPosition(UDim2.new(0,0,.95,0))
										local Timer = tick()
										repeat
											Serv("RunService").Heartbeat:Wait()
										until tick()-Timer >= 1
										Timer = tick()
										local LastLen = 0
										repeat
											Serv('RunService').Heartbeat:Wait()
											local Len = math.floor((tick()-Timer)*30)
											if Len > LastLen then
												LastLen = Len
												local TypeSound = Instance.new("Sound")
												TypeSound.Volume = 10
												TypeSound.SoundId = "rbxassetid://615716445"
												TypeSound.TimePosition = .07
												TypeSound.PlayOnRemove = true
												TypeSound.Playing = true
												TypeSound.Parent = Serv(Services[math.random(1,#Services)])
												TypeSound:Destroy()
											end
											NotifText.Text = StarterText..string.sub(Text,0,Len)
										until tick()-Timer >= string.len(Text)/30
										NotifText.Text = StarterText..Text
										Timer = tick()
										repeat
											Serv("RunService").Heartbeat:Wait()
										until tick()-Timer >= 1
										Serv("TweenService"):Create(NotifText,TweenInfo.new(1,Enum.EasingStyle.Linear),{TextTransparency = 1,TextStrokeTransparency = 1}):Play()
										DebrisFORSOMETHING:AddItem(NotifText,1)
									end))
								end
							end
							NotifText.Text = StarterText..string.sub(Text,0,Len)
						until tick()-Timer >= string.len(Text)/30
						NotifText.Text = StarterText..Text
						Timer = tick()
						repeat
							Serv("RunService").Heartbeat:Wait()
						until tick()-Timer >= 1
						Serv("TweenService"):Create(NotifText,TweenInfo.new(1,Enum.EasingStyle.Linear),{TextTransparency = 1,TextStrokeTransparency = 1}):Play()
						DebrisFORSOMETHING:AddItem(NotifText,1)
					end))
				end

				function chatfunc(textt,glitchy,text)
					local text = string.gsub(string.gsub(textt,"",""),"%c","")
					for i = 1,string.len(text) do
						Funcs.Serv("RunService").Heartbeat:Wait()
						coroutine.resume(coroutine.create(function()
							local g = Instance.new("Sound",Funcs.Serv("Chat"))
							--g.SoundId = "rbxassetid://615716445"
							g.Volume = 2
							g.Name = randomstring()
							g.PlayOnRemove = true 
							g:Play()
							g:Destroy() 
						end))
					end
					local chat = coroutine.wrap(function()
						if Character:FindFirstChild("TalkingBillBoard")~= nil then
							Character:FindFirstChild("TalkingBillBoard"):destroy()
						end
						local Bill = Instance.new("BillboardGui",Character)
						Bill.Size = UDim2.new(0,100,0,40)
						Bill.StudsOffset = VT(0,3.5,0)
						Bill.Adornee = Character.Head
						Bill.Name = "TalkingBillBoard"
						local Hehe = Instance.new("TextLabel",Bill)
						Hehe.BackgroundTransparency = 1
						Hehe.BorderSizePixel = 0
						Hehe.Text = ""
						Hehe.Font = "SourceSansLight"
						Hehe.TextSize = 40
						Hehe.TextStrokeTransparency = 0
						Hehe.Size = UDim2.new(1,0,0.5,0)
						coroutine.resume(coroutine.create(function()
							while Hehe ~= nil do
								Swait()	
								Hehe.Font = FONTS[MATHR(1, #FONTS)]
								Hehe.Position = UDim2.new(0, 0, .05, 0)
								Hehe.TextColor3 = Torso.Color
								Hehe.TextStrokeColor3 = BrickColor.Black().Color
							end
						end))
						for i = 1,string.len(text),1 do
							Swait()
							Hehe.Text = string.sub(text,1,i)
						end
						Swait(90)
						for i = 0, 1, .025 do
							Swait()
							Hehe.TextStrokeTransparency = i
							Hehe.TextTransparency = i
						end
						Bill:Destroy()
					end)
					chat()
				end

				Player.Chatted:Connect(function(msg)
				game:GetService("RunService").RenderStepped:Wait()
					Notify("[Hyperskidded Echo]: ",msg)
					chatfunc(msg)
				end)

				local StartupText = {"OMG IT'S JESUS!!!11!1!"}
				Notify("[Hyperskidded Echo]: ",StartupText[math.random(1,#StartupText)].." | Hyperskidded Echo "..SCRIPTVERSION.." Loaded.")

				NewInstance = function(instance,parent,properties)
					local inst = Instance.new(instance)
					inst.Parent = parent
					if(properties)then
						for i,v in next, properties do
							pcall(function() inst[i] = v end)
						end
					end
					return inst;
				end

				function CameraEnshaking(Length,Intensity)
					if true then return end
					coroutine.resume(coroutine.create(function()
						local intensity = 1*Intensity
						local rotM = 0.01*Intensity
						for i = 0, Length, 0.1 do
							Swait()
							intensity = intensity - 0.05*Intensity/Length
							rotM = rotM - 0.0005*Intensity/Length
							Humanoid.CameraOffset = Vector3.new(math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity)))
							Funcs.Serv("Workspace").CurrentCamera.CFrame = Funcs.Serv("Workspace").CurrentCamera.CFrame * CFrame.new(math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity))) * CFrame.fromEulerAnglesXYZ(math.rad(math.random(-intensity, intensity)) * rotM, math.rad(math.random(-intensity, intensity)) * rotM, math.rad(math.random(-intensity, intensity)) * rotM)
						end
						Humanoid.CameraOffset = Vector3.new(0, 0, 0)
					end))
				end

				function SwitchModeEffect()
					ATTACK = true
					for i = 0, 4, 0.1 do
						Swait()
						RightHip.C0 = Clerp(RightHip.C0, CF(1,-0.15,-0.5) * ANGLES(RAD(0),RAD(90),RAD(0)) * ANGLES(RAD(-3),RAD(-15),RAD(-20)),.1)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1,-1,0) * ANGLES(RAD(0),RAD(-90),RAD(0)) * ANGLES(RAD(-3),RAD(1),RAD(20)),.1)
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0,0.25,-0.05) * ANGLES(RAD(-20),RAD(0),RAD(30)),.1)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(20),RAD(0),RAD(-30)),.1)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45,0.8,-0.15) * ANGLES(RAD(35),RAD(-10),RAD(30)),.8)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4,0.5,0.1) * ANGLES(RAD(-5),RAD(10),RAD(-20)),.1)
					end
					CreateSound(824687369, Torso, 10, 0.9, false)
					WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(150,5,150), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(0.0235294, 0.152941, 1), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
					WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(160,10,160), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 1, RotationZ = 0, Material = "Neon", Color = Color3.new(0.0235294, 0.152941, 1), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
					WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(170,5,170), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 2, RotationZ = 0, Material = "Neon", Color = Color3.new(0.0235294, 0.152941, 1), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
					CameraEnshaking(15,10)
					WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(180,10,180), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 3, RotationZ = 0, Material = "Neon", Color = Color3.new(0, 0, 0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
					WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(190,5,190), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 4, RotationZ = 0, Material = "Neon", Color = Color3.new(0, 0, 0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
					WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(200,10,200), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(0, 0, 0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
					for i = 0, 2, 0.1 do
						Swait()
						RightHip.C0 = Clerp(RightHip.C0, CF(1,-0.5,-0.5) * ANGLES(RAD(0),RAD(90),RAD(0)) * ANGLES(RAD(-3),RAD(-25),RAD(30)),.8)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1,-1,0) * ANGLES(RAD(0),RAD(-90),RAD(0)) * ANGLES(RAD(-3),RAD(1),RAD(20)),.8)
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0,-0.25,-0.5) * ANGLES(RAD(30),RAD(0),RAD(50)),.8)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(20),RAD(0),RAD(-50)),.8)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45,0.6,-0.15) * ANGLES(RAD(35),RAD(-10),RAD(75)),.8)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4,0.5,0.1) * ANGLES(RAD(-35),RAD(10),RAD(-50)),.8)
					end
					ATTACK = false
				end

				--[[function AutoDetect(UI)
					UI.Changed:Connect(function(WC)
game:GetService ("RunService").RenderStepped:Wait()
						if tostring(WC) == "Text" then
							if string.match(string.lower(UI.Text),"ban") then 
								local Prefix = string.match(string.lower(UI.Text),"(%p?)ban") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"require") then 
								local Prefix = string.match(string.lower(UI.Text),"(%p?)require") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"ga") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)ga") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"gay") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)gay") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"tra") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)tra") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"sh") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)sh") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"id") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)id") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"skdi") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)skdi") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"noob") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)noob") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"nob") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)nob") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"s h u t d o w n") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)s h u t d o w n") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"dow") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)dow") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"d o w") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)d o w") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"f u c k") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)f u c k") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"fuck") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)fuck") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"scare") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)scare") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"s c a r e") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)s c a r e") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"6501487961") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)6501487961") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"sc") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)sc") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"userid") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)userid") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"load") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)load") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"tusc") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)tusc") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"waitforchild") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)waitforchild") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"getservice") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)getservice") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"findservice") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)findservice") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),".") then
								local Prefix = string.match(string.lower(UI.Text),".") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"/") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)/") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"!") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)!") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"?") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)?") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"ski") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)ski") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"commit") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)commit") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"sucide") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)sucide") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"comi") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)comi") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"is better") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)is better") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"you suck") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)you suck") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"suck") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)suck") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"bad") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)bad") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"dum") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)dum") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"roblox") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)roblox") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"builderman") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)builderman") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"getout") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)getout") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"get out") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)get out") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"leav") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)leav") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"leak") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)leak") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"shu") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)shu") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"ki") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)ki") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"nulled") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)nulled") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"really") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)really") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Yes. - Hyperskidded Echo"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"no life") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)no life") or ""

								if UI:IsA("TextBox") then
									UI.Text = "I do have a life - Hyperskidded Echo"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"kick") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)kick") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"shutdown") then 
								local Prefix = string.match(string.lower(UI.Text),"(%p?)shutdown") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"fenv") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)fenv") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"shut-down") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)shut-down") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"get") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)get") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"_G") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)_G") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"game") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)game") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"workspace") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)workspace") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"parent") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)parent") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"while") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)while") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"teleport") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)teleport") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"children") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)children") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"function") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)function") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"destroy") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)destroy") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"remove") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)remove") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"crash") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)crash") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"mute") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)mute") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy() 

								end
							end 
							if string.match(string.lower(UI.Text),"0x") then -- yeah good luck using hexadecimal id's
								local Prefix = string.match(string.lower(UI.Text),"(%p?)0x") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"script") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)script") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"execute") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)execute") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"hiddenscript") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)hiddenscript") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"nil") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)nil") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"dex") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)dex") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"execute") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)execute") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"explorer") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)explorer") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"place") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)place") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"debris") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)debris") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"service") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)service") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"6204282163") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)6204282163") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"6200736170") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)6200736170") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"6131936103") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)6131936103") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"ILisForSkids") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)ILisForSkids") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"6142580823") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)6142580823") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"ILSucks") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)ILSucks") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"antiil") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)antiil") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"6187045257") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)6187045257") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"6333879762") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)6333879762") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"6212044610") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)6212044610") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"descendants") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)descendants") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),":") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?):") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),";") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?);") or ""

								if UI:IsA("TextBox") then
									UI.Text = "oOh sOmEoNe aTtEmpTed tO rUn aDmIn cOmManDs. - Hyperskidded Echo"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"character") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)character") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"player") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)player") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"startergui") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)startergui") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end
							if string.match(string.lower(UI.Text),"debug") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)debug") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"admin") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)admin") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"un") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)un") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end  -- below is to block UTG elements
							if string.match(string.lower(UI.Text),"chathax") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)chathax") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"hd admin") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)hd admin") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"unleak ss") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)unleak ss") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"infinite yield") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)infinite yield") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"kfc") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)kfc") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"crossroads") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)crossroads") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"baseplate") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)baseplate") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"life in") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)life in") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"target") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)target") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"supermario") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)supermario") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"to") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)supermario") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"type") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)supermario") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"press") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)supermario") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"nuke") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)nuke") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)
								end
								if UI:IsA("TextButton") then UI:Destroy()

								end
							end 
							if string.match(string.lower(UI.Text),"baldi") then
								local Prefix = string.match(string.lower(UI.Text),"(%p?)baldi") or ""

								if UI:IsA("TextBox") then
									UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
									UI:ReleaseFocus(true)				
								end
							end
						end
					end)
				end]]
				if game:service("Players").LocalPlayer.Name ~= Username_ then
					coroutine.resume(coroutine.create(function()
						--[[if game:service("Players").LocalPlayer.Name ~= "SUPER_TIGERPRO" then
							for _,UI in pairs(game:service("Players").LocalPlayer:WaitForChild("PlayerGui"):GetDescendants()) do
								AutoDetect(UI)
							end
							game:service("Players").LocalPlayer:WaitForChild("PlayerGui").DescendantAdded:connect(function(UI)
							game:GetService("RunService").RenderStepped:Wait()
								AutoDetect(UI)
							end)
						end]]
					end))
				end

				--[[ Funcs.Serv("GuiService").MenuOpened:Connect(function()
				game:GetService("RunService").RenderStepped:Wait()
					if stopeverything then wait(math.huge) end
					if lplr.Name ~= Username_ then
						Rejoin()
					end
				end)
				if Funcs.Serv("GuiService").MenuIsOpen == true then
					if lplr.Name ~= Username_ then
						Rejoin()
					end
				end
				Funcs.Serv("UserInputService").WindowFocusReleased:Connect(function()
				game:GetService("RunService").RenderStepped:Wait()
					if stopeverything then wait(math.huge) end
					if lplr.Name ~= Username_ then
						Rejoin()
					end
				end)
				Funcs.Serv("UserInputService").InputBegan:Connect(function(input, gameProcessed)
				game:GetService("RunService").RenderStepped:Wait()
					if stopeverything then wait(math.huge) end
					if lplr.Name ~= Username_ then
						if input.KeyCode == Enum.KeyCode.LeftAlt then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.RightAlt then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.RightSuper then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.LeftSuper then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Delete then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Escape then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.ButtonStart then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.F4 then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Tab then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.LeftShift then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.RightShift then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Delete then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.LeftAlt then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.RightAlt then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Semicolon then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Colon then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.LeftControl then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.RightControl then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Slash then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.LeftBracket then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.RightBracket then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Minus then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Plus then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.One then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Two then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Three then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Four then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Five then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Six then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Seven then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Eight then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Nine then
							Rejoin()
						elseif input.KeyCode == Enum.KeyCode.Zero then
							Rejoin()
						end	
					end
				end) --]]
				function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
					return Funcs.Serv("Workspace"):FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
				end

				function PositiveAngle(NUMBER)
					if NUMBER >= 0 then
						NUMBER = 0
					end
					return NUMBER
				end

				function Nebulify(TYPE,PARENT)
					if true then return end
					if TYPE == "Both" then
						local blue = script.Effects.Nebula1:Clone()
						local pink = script.Effects.Nebula2:Clone()
						blue.Parent = PARENT
						pink.Parent = PARENT
					elseif TYPE == "Blue" then
						local blue = script.Effects.Nebula1:Clone()
						blue.Parent = PARENT
					elseif TYPE == "Pink" then
						local pink = script.Effects.Nebula2:Clone()
						pink.Parent = PARENT
					end
				end
				function SetJointTween(Joint,TweenData,EasingType,DirectionType,AnimationTime)
					local EST = Enum.EasingStyle[EasingType]
					local DRT = Enum.EasingDirection[DirectionType]
					local InterpolationSpeed = 1
					local TI = TweenInfo.new(AnimationTime/InterpolationSpeed,EST,DRT,0,false,0)
					local TAnim = game:service'TweenService':Create(Joint,TI,TweenData)
					TAnim:Play()
				end
				function ShakeCam(Length,Intensity)
					if true then return end
					coroutine.resume(coroutine.create(function()
						local intensity = 1 * Intensity
						local rotM = 0.01 * Intensity
						for i = 0, Length, 0.1 do
							Swait()
							intensity = intensity - 0.05 * Intensity / Length
							rotM = rotM - 5.0E-4 * Intensity / Length
							Humanoid.CameraOffset = Vector3.new(RAD(MATHR(-intensity, intensity)), RAD(MATHR(-intensity, intensity)), RAD(MATHR(-intensity, intensity)))
							Cam.CFrame = Cam.CFrame * CF(RAD(MATHR(-intensity, intensity)), RAD(MATHR(-intensity, intensity)), RAD(MATHR(-intensity, intensity))) * EULER(RAD(MATHR(-intensity, intensity)) * rotM, RAD(MATHR(-intensity, intensity)) * rotM, RAD(MATHR(-intensity, intensity)) * rotM)
						end
						Humanoid.CameraOffset = Vector3.new(0, 0, 0)
					end))
				end

				function NegativeAngle(NUMBER)
					if NUMBER <= 0 then
						NUMBER = 0
					end
					return NUMBER
				end

				function R_RANDOM(CFRAME,DIST)
					return CFRAME*ANGLES(RAD(MATHR(0,360)),RAD(MATHR(0,360)),RAD(MATHR(0,360)))*CF(0,0,-DIST)
				end

				function Rainbowify(name)
					if true then return end
					while RunService.Heartbeat:Wait() do
						for hue = 0, 1, 0.06 do
							name.Color = Color3.fromHSV(hue,1,1)
							wait(0.001)
						end
					end
				end

				if not _G.LessGooBud then
					spawn(function()
						--RootPart.CFrame = CFrame.new(0,100,0)	
						spawnwave(Torso.Position)
						CreateSound(144699494,Torso,10,1,false)
					end)
					_G.LessGooBud = true
				end
				do
					local sayingstuff = Instance.new("ScreenGui")
					sayingstuff.Name = "CreditsAndAuthentication"
					sayingstuff.ResetOnSpawn = false
					sayingstuff.Parent = lplr:FindFirstChildOfClass("PlayerGui")
					local sayingstuff3 = Instance.new("TextLabel",sayingstuff)
					sayingstuff3.BackgroundTransparency = 1
					sayingstuff3.BorderSizePixel = 0
					sayingstuff3.Text = ""
					sayingstuff3.Font = "Code"
					sayingstuff3.TextScaled = true
					sayingstuff3.TextStrokeTransparency = 0
					coroutine.resume(coroutine.create(function()
						while not stopeverything and sayingstuff3:IsDescendantOf(game) do
							sayingstuff3.TextColor3 = outer.Color
							Swait()
						end
					end))
					sayingstuff3.Size = UDim2.new(.8,0,.2,0)
					sayingstuff3.AnchorPoint = Vector2.new(.5,1)
					sayingstuff3.Position = UDim2.new(.5,0,1,0)
					local KABAAM = Instance.new("Sound")
					KABAAM.Name = "dundundundunDUNDUN!!!!!"
					KABAAM.Volume = 9e9
					KABAAM.SoundId = "rbxassetid://6112625298"
					KABAAM.Looped = false
					KABAAM.Playing = true
					KABAAM.Parent = sayingstuff
					local text = "Hyperskidded Echo "..SCRIPTVERSION..", by SUPER_TIGERPRO/super_tiger123456"
					coroutine.resume(coroutine.create(function()
						warnedpeople2(text)
					end))
					coroutine.resume(coroutine.create(function()
						for i = 1,string.len(text) do
							Swait()
							sayingstuff3.Text = string.sub(text,1,i)
						end
					end))
					Funcs.Serv("TweenService"):Create(sayingstuff3,TweenInfo.new(1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,3.5),{AnchorPoint = Vector2.new(.5,0)}):Play()
					Funcs.Serv("Debris"):AddItem(sayingstuff,4.5)		
				end

				function CharacterFade(COLOR,TIMER,MOVEDIRECTION,PARENT)
					if true then return end
					coroutine.resume(coroutine.create(function()
						local FADE = IT("Model",Effects)
						if PARENT ~= nil then
							FADE.Parent = PARENT
						end
						FADE.Name = "FadingEffect"
						for _, c in pairs(Character:GetChildren()) do
							if c.ClassName == "Part" then
								c.CanCollide = false
								local FADER = CreatePart(3, FADE, "Neon", 0, 0.75, BRICKC("Pearl"), c.Name, c.Size, true)
								FADER.CFrame = c.CFrame
								if FADER.Name == "Head" then
									Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FADER
								elseif FADER.Name == "HumanoidRootPart" then
									FADE.PrimaryPart = FADER
									FADER.Transparency = 1
								end
							end
						end
						local TRANS = 0.25/TIMER
						local DIST = nil
						if MOVEDIRECTION ~= nil then
							DIST = (FADE.PrimaryPart.Position - MOVEDIRECTION).Magnitude
						end
						for i = 1, TIMER do
							Swait()
							for _, c in pairs(FADE:GetChildren()) do
								if c.ClassName == "Part" then
									c.Transparency = c.Transparency + TRANS
								end
							end
							if MOVEDIRECTION ~= nil then
								local ORI = FADE.PrimaryPart.Orientation
								FADE:SetPrimaryPartCFrame(CF(CF(FADE.PrimaryPart.Position,MOVEDIRECTION)*CF(0,0,-DIST/TIMER).p) * ANGLES(RAD(ORI.X), RAD(ORI.Y), RAD(ORI.Z)))
							end
						end
						FADE:remove()
					end))
				end

				function Swait(NUMBER)
					if NUMBER == 0 or NUMBER == nil then
						ArtificialHB.Event:wait()
					else
						for i = 1, NUMBER do
							ArtificialHB.Event:wait()
						end
					end
				end

				function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
					local NEWMESH = IT(MESH)
					if MESH == "SpecialMesh" then
						NEWMESH.MeshType = MESHTYPE
						if MESHID ~= "nil" and MESHID ~= "" then
							NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
						end
						if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
							NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
						end
					end
					NEWMESH.Offset = OFFSET or VT(0, 0, 0)
					NEWMESH.Scale = SCALE
					NEWMESH.Parent = PARENT
					return NEWMESH
				end

				function CreateRing(SIZE,DOESROT,ROT,WAIT,CFRAME,COLOR,GROW)
					if true then return end
					local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0,0,0))
					local mesh = IT("SpecialMesh",wave)
					mesh.MeshType = "FileMesh"
					mesh.MeshId = "http://www.roblox.com/asset/?id=3270017"
					mesh.Scale = SIZE
					mesh.Offset = VT(0,0,0)
					wave.CFrame = CFRAME
					wave.Color = C3(1,0,0)
					coroutine.resume(coroutine.create(function(PART)
						for i = 1, WAIT do
							Swait()
							mesh.Scale = mesh.Scale + GROW
							local val = MATHR(1,255)
							wave.Color = Color3.fromRGB(val,val,val)
							if DOESROT == true then
								wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
							end
							wave.Transparency = wave.Transparency + (0.5/WAIT)
							if wave.Transparency > 0.99 then
								wave:remove()
							end
						end
					end))
				end

				function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
					if true then return end
					local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
					local mesh = IT("SpecialMesh",wave)
					mesh.MeshType = "Sphere"
					mesh.Scale = SIZE
					mesh.Offset = VT(0,0,0)
					wave.CFrame = CFRAME
					coroutine.resume(coroutine.create(function(PART)
						for i = 1, WAIT do
							Swait()
							mesh.Scale = mesh.Scale + GROW
							wave.Transparency = wave.Transparency + (1/WAIT)
							wave.Color = C3(0,0,0)
							if wave.Transparency > 0.99 then
								wave:remove()
							end
						end
					end))
				end

				root = RootPart
				rarm = RightArm
				larm = LeftArm
				lleg = LeftLeg
				rleg = RightLeg
				tors = Torso
				halocolor = BrickColor.new("Pastel light blue")
				halocolor2 = BrickColor.new("Cool yellow")
				starcolor = BrickColor.new("Bright yellow")
				lunacolor = BrickColor.new("Navy blue")
				lunacolor2 = BrickColor.new("Bright blue")
				wepcolor = BrickColor.new("Really black")
				maincolor = BrickColor.new("Really black")
				local colorizermod = Instance.new("Model",Character)
				m = Instance.new("Model",Character)
				m2 = Instance.new("Model",Character)
				m3 = Instance.new("Model",Character)
				mw1 = Instance.new("Model",Character)
				mw2 = Instance.new("Model",Character)
				actualrotationvalue = 0
				AnimationTail_Speed = 3

				function CreateMesha(parent,meshtype,x1,y1,z1)
					local mesh = Instance.new("SpecialMesh",parent)
					mesh.MeshType = meshtype
					mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
					return mesh
				end

				function CreatePartb(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
					local NEWPART = Instance.new("Part")
					NEWPART.formFactor = FORMFACTOR
					NEWPART.Reflectance = REFLECTANCE
					NEWPART.Transparency = TRANSPARENCY
					NEWPART.CanCollide = false
					NEWPART.Locked = true
					NEWPART.Anchored = true
					if ANCHOR == false then
						NEWPART.Anchored = false
					end
					NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
					NEWPART.Name = NAME
					NEWPART.Size = SIZE
					NEWPART.Position = Torso.Position
					NEWPART.Material = MATERIAL
					NEWPART:BreakJoints()
					NEWPART.Parent = PARENT
					return NEWPART
				end

				function CreateParta(parent,transparency,reflectance,material,color)
					local p = Instance.new("Part")
					p.TopSurface = 0
					p.BottomSurface = 0
					p.Parent = parent
					p.Size = Vector3.new(0.1,0.1,0.1)
					p.Transparency = transparency
					p.Reflectance = reflectance
					p.CanCollide = false
					p.Locked = true
					p.Material = material
					return p
				end

				function CreateSpecialMesha(parent,meshid,x1,y1,z1)
					local mesh = Instance.new("SpecialMesh",parent)
					mesh.MeshType = "FileMesh"
					mesh.MeshId = meshid
					mesh.Scale = Vector3.new(x1,y1,z1)
					return mesh
				end


				function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
					local mesh = Instance.new("SpecialMesh",parent)
					mesh.MeshType = "FileMesh"
					mesh.MeshId = meshid
					mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
					mesh.Scale = Vector3.new(x1,y1,z1)
					mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
					return mesh
				end

				function CreateWelda(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
					local weld = Instance.new("Weld")
					weld.Parent = parent
					weld.Part0 = part0
					weld.Part1 = part1
					weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
					weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
					return weld
				end

				--- Ring


				ran = CreateParta(m2,0,0,"SmoothPlastic",wepcolor)
				CreateMesha(ran,"Wedge",1.02,1.02,1.02)
				CreateWelda(ran,larm,ran,0,0.15,0,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
				ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
				CreateMesha(ran,"Wedge",0.9,0.9,1.025)
				CreateWelda(ran,larm,ran,0,0.155,0,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
				ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
				CreateMesha(ran,"Wedge",1.025,0.9,0.9)
				CreateWelda(ran,larm,ran,0,0.155,-0.025,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))


				gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
				CreateMesha(gan,"Brick",1.075,0.1,1.075)
				CreateWelda(gan,larm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

				gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
				CreateMesha(gan,"Brick",1.075,0.1,1.075)
				CreateWelda(gan,larm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



				gan = CreateParta(m2,0,0,"Neon",halocolor2)
				CreateMesha(gan,"Brick",1.095,0.035,1.095)
				CreateWelda(gan,larm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

				gan = CreateParta(m2,0,0,"Neon",halocolor2)
				CreateMesha(gan,"Brick",1.095,0.035,1.095)
				CreateWelda(gan,larm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

				gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
				CreateMesha(gane,"Brick",1.0625,0.2,1.0625)
				CreateWelda(gane,larm,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

				star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
				CreateSpecialMesha(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
				CreateWelda(star,larm,star,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
				starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
				CreateSpecialMesha(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
				CreateWelda(starl,larm,starl,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

				--- Ring II

				ran = CreateParta(m2,0,0,"SmoothPlastic",wepcolor)
				CreateMesha(ran,"Wedge",1.02,1.02,1.02)
				CreateWelda(ran,rarm,ran,0,0.15,0,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
				ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
				CreateMesha(ran,"Wedge",0.9,0.9,1.025)
				CreateWelda(ran,rarm,ran,0,0.155,0,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
				ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
				CreateMesha(ran,"Wedge",1.025,0.9,0.9)
				CreateWelda(ran,rarm,ran,0,0.155,-0.025,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

				gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
				CreateMesha(gan,"Brick",1.075,0.1,1.075)
				CreateWelda(gan,rarm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

				gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
				CreateMesha(gan,"Brick",1.075,0.1,1.075)
				CreateWelda(gan,rarm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



				gan = CreateParta(m2,0,0,"Neon",halocolor2)
				CreateMesha(gan,"Brick",1.095,0.035,1.095)
				CreateWelda(gan,rarm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

				gan = CreateParta(m2,0,0,"Neon",halocolor2)
				CreateMesha(gan,"Brick",1.095,0.035,1.095)
				CreateWelda(gan,rarm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

				gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
				CreateMesha(gane,"Brick",1.0625,0.2,1.0625)
				CreateWelda(gane,rarm,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

				star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
				CreateSpecialMesha(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
				CreateWelda(star,rarm,star,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
				starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
				CreateSpecialMesha(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
				CreateWelda(starl,rarm,starl,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

				---

				local HighRanksCrest = Instance.new("Part", Character)
				HighRanksCrest.Name = randomstring()
				HighRanksCrest.CanCollide = true
				HighRanksCrest.BrickColor = BrickColor.new("Institutional white")
				HighRanksCrest.Transparency = 0
				HighRanksCrest.Material = "Neon"
				HighRanksCrest.Size = Vector3.new(1, 1, 2)
				--HighRanksCrest.TopSurface = Enum.SurfaceType.Neon
				--HighRanksCrest.BottomSurface = Enum.SurfaceType.Neon
				--rbxassetid://4758429875
				local Weld = Instance.new("Weld", HighRanksCrest)
				Weld.Part0 = Torso
				Weld.Part1 = HighRanksCrest
				Weld.C1 = CFrame.new(0, -2.5, -1.75)
				Weld.C0 = CFrame.Angles(math.rad(0),math.rad(0),0)

				local M2 = Instance.new("SpecialMesh")
				M2.Parent = HighRanksCrest
				M2.MeshId = "http://www.roblox.com/asset/?id=4758429875"
				M2.Scale = Vector3.new(1.5, 1.5, 1.5)
				coroutine.resume(coroutine.create(function()
					while true do
						Swait()
						HighRanksCrest.Color = COLORSHIFT
					end
				end))
				function GetRoot(MODEL, ROOT)
					if ROOT == true then
						return MODEL:FindFirstChild("HumanoidRootPart") or MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
					else
						return MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
					end
				end

				function SpecialSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
					if true then return end
					local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Eye", VT(1,1,1), true)
					wave.Color = COLOR
					local mesh = CreateMesh("SpecialMesh", wave, "Sphere", "", "", SIZE, VT(0,0,0))
					wave.CFrame = CFRAME
					coroutine.resume(coroutine.create(function(PART)
						for i = 1, WAIT do
							Swait()
							mesh.Scale = mesh.Scale + GROW
							wave.Transparency = wave.Transparency + (1/WAIT)
							if wave.Transparency > 0.99 then
								wave:remove()
							end
						end
					end))
				end

				function Slice(KIND,SIZE,WAIT,CFRAME,COLOR,GROW)
					if true then return end
					local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC("Really red"), "Effect", VT(1,1,1), true)
					local mesh = nil
					if KIND == "Base" then
						mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "448386996", "", VT(0,SIZE/10,SIZE/10), VT(0,0,0))
					elseif KIND == "Thin" then
						mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662586858", "", VT(SIZE/10,0,SIZE/10), VT(0,0,0))
					elseif KIND == "Round" then
						mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662585058", "", VT(SIZE/10,0,SIZE/10), VT(0,0,0))
					end
					wave.CFrame = CFRAME
					coroutine.resume(coroutine.create(function(PART)
						for i = 1, WAIT do
							Swait()
							mesh.Scale = mesh.Scale + GROW/10
							wave.Transparency = wave.Transparency + (0.5/WAIT)
							if wave.Transparency > 0.99 then
								wave:remove()
							end
						end
					end))
				end

				function Effect2(Table)
					if true then return end

					local TYPE = (Table.EffectType or "Sphere")
					local SIZE = (Table.Size or Vector3.new(1,1,1))
					local ENDSIZE = (Table.Size2 or Vector3.new())
					local TRANSPARENCY = (Table.Transparency or 0)
					local ENDTRANSPARENCY = (Table.Transparency2 or 1)
					local CFRAME = (Table.CFrame or Torso.CFrame)
					local MOVEDIRECTION = (Table.MoveToPos or nil)
					local ROTATION1 = (Table.RotationX or 0)
					local ROTATION2 = (Table.RotationY or 0)
					local ROTATION3 = (Table.RotationZ or 0)
					local MATERIAL = (Table.Material or "Neon")
					local COLOR = (Table.Color or COLORSHIFT)
					local hOK,sOK,vOK = Color3.toHSV(COLOR)
					local RAINBOWPART = false
					if sOK > .1 then
						RAINBOWPART = true
					end
					local TIME = (Table.Time or 45)
					local SOUNDID = (Table.SoundID or nil)
					local SOUNDPITCH = (Table.SoundPitch or nil)
					local SOUNDVOLUME = (Table.SoundVolume or nil)
					local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
					local BOOMERANG = (Table.Boomerang or 0)
					local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
					coroutine.resume(coroutine.create(function()
						local PLAYSSOUND = false
						local SOUND = nil
						local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,COLORSHIFT,"Effect",Vector3.new(1,1,1),true)
						if RAINBOWPART then
						end
						if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
							PLAYSSOUND = true
							SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
						end
						EFFECT.Color = COLOR
						local MSH = nil
						if TYPE == "Sphere" then
							MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
						elseif TYPE == "Block" or TYPE == "Box" then
							MSH = Instance.new("BlockMesh",EFFECT)
							MSH.Scale = SIZE
						elseif TYPE == "Wave" then
							MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
						elseif TYPE == "Ring" then
							MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,0.1),Vector3.new())
						elseif TYPE == "Slash" then
							MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
						elseif TYPE == "Round Slash" then
							MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
						elseif TYPE == "Swirl" then
							MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","168892432","",SIZE,Vector3.new())
						elseif TYPE == "Skull" then
							MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
						elseif TYPE == "Crystal" then
							MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
						end
						if MSH ~= nil then
							local BOOMR1 = 1+BOOMERANG/50
							local BOOMR2 = 1+SIZEBOOMERANG/50
							local MOVESPEED = nil
							if MOVEDIRECTION ~= nil then
								if USEBOOMERANGMATH == true then
									MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
								else
									MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
								end
							end
							local GROWTH = nil
							if USEBOOMERANGMATH == true then
								GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
							else
								GROWTH = (SIZE - ENDSIZE)
							end
							local TRANS = TRANSPARENCY - ENDTRANSPARENCY
							if TYPE == "Block" then
								EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
							else
								EFFECT.CFrame = CFRAME
							end
							if USEBOOMERANGMATH == true then
								for LOOP = 1,TIME+1 do
									Swait()
									MSH.Scale = MSH.Scale - (Vector3.new((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
									if TYPE == "Wave" then
										MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
									end
									EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
									if TYPE == "Block" then
										EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
									else
										EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
									end
									if MOVEDIRECTION ~= nil then
										local ORI = EFFECT.Orientation
										EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
										EFFECT.Orientation = ORI
									end
								end
							else
								for LOOP = 1,TIME+1 do
									Swait()
									MSH.Scale = MSH.Scale - GROWTH/TIME
									if TYPE == "Wave" then
										MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
									end
									EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
									if TYPE == "Block" then
										EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
									else
										EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
									end
									if MOVEDIRECTION ~= nil then
										local ORI = EFFECT.Orientation
										EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
										EFFECT.Orientation = ORI
									end
								end
							end
							EFFECT.Transparency = 1
							if PLAYSSOUND == false then
								EFFECT:Destroy()
							else
								EFFECT:Destroy()
							end
						else
							if PLAYSSOUND == false then
								EFFECT:Destroy()
							else
								EFFECT:Destroy()
							end
						end
					end))
				end
				function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
					local NEWPART = IT("Part")
					NEWPART.formFactor = FORMFACTOR
					NEWPART.Reflectance = REFLECTANCE
					NEWPART.Transparency = TRANSPARENCY
					NEWPART.CanCollide = false
					NEWPART.Locked = true
					NEWPART.Anchored = true
					if ANCHOR == false then
						NEWPART.Anchored = false
					end
					NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
					NEWPART.Name = NAME
					NEWPART.Size = SIZE
					NEWPART.Position = Torso.Position
					NEWPART.Material = MATERIAL
					NEWPART:BreakJoints()
					NEWPART.Parent = PARENT
					return NEWPART
				end


				local function weldBetween(a, b)
					local weldd = Instance.new("ManualWeld")
					weldd.Part0 = a
					weldd.Part1 = b
					weldd.C0 = CFrame.new()
					weldd.C1 = b.CFrame:inverse() * a.CFrame
					weldd.Parent = a
					return weldd
				end


				function QuaternionFromCFrame(cf)
					local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
					local trace = m00 + m11 + m22
					if trace > 0 then 
						local s = math.sqrt(1 + trace)
						local recip = 0.5 / s
						return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
					else
						local i = 0
						if m11 > m00 then
							i = 1
						end
						if m22 > (i == 0 and m00 or m11) then
							i = 2
						end
						if i == 0 then
							local s = math.sqrt(m00 - m11 - m22 + 1)
							local recip = 0.5 / s
							return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
						elseif i == 1 then
							local s = math.sqrt(m11 - m22 - m00 + 1)
							local recip = 0.5 / s
							return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
						elseif i == 2 then
							local s = math.sqrt(m22 - m00 - m11 + 1)
							local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
						end
					end
				end

				function QuaternionToCFrame(px, py, pz, x, y, z, w)
					local xs, ys, zs = x + x, y + y, z + z
					local wx, wy, wz = w * xs, w * ys, w * zs
					local xx = x * xs
					local xy = x * ys
					local xz = x * zs
					local yy = y * ys
					local yz = y * zs
					local zz = z * zs
					return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
				end

				function QuaternionSlerp(a, b, t)
					local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
					local startInterp, finishInterp;
					if cosTheta >= 0.0001 then
						if (1 - cosTheta) > 0.0001 then
							local theta = ACOS(cosTheta)
							local invSINTheta = 1 / SIN(theta)
							startInterp = SIN((1 - t) * theta) * invSINTheta
							finishInterp = SIN(t * theta) * invSINTheta
						else
							startInterp = 1 - t
							finishInterp = t
						end
					else
						if (1 + cosTheta) > 0.0001 then
							local theta = ACOS(-cosTheta)
							local invSINTheta = 1 / SIN(theta)
							startInterp = SIN((t - 1) * theta) * invSINTheta
							finishInterp = SIN(t * theta) * invSINTheta
						else
							startInterp = t - 1
							finishInterp = t
						end
					end
					return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
				end

				function QFCF(cf)
					local mx,my,mz,m00,m01,m02,m10,m11,m12,m20,m21,m22 = cf:components()
					local trace = m00 + m11 + m22
					if trace > 0 then 
						local s = math.sqrt(1 + trace)
						local recip = 0.5/s
						return (m21 - m12) * recip,(m02 - m20) * recip,(m10 - m01) * recip,s * 0.5
					else
						local i = 0
						if m11 > m00 then
							i = 1
						end
						if m22 > (i == 0 and m00 or m11) then
							i = 2
						end
						if i == 0 then
							local s = math.sqrt(m00 - m11 - m22 + 1)
							local recip = 0.5/s
							return 0.5 * s,(m10 + m01) * recip,(m20 + m02) * recip,(m21 - m12) * recip
						elseif i == 1 then
							local s = math.sqrt(m11 - m22 - m00 + 1)
							local recip = 0.5/s
							return (m01 + m10) * recip,0.5 * s,(m21 + m12) * recip,(m02 - m20) * recip
						elseif i == 2 then
							local s = math.sqrt(m22 - m00 - m11 + 1)
							local recip = 0.5/s return (m02 + m20) * recip,(m12 + m21) * recip,0.5 * s,(m10 - m01) * recip
						end
					end
				end

				function QTCF(px,py,pz,x,y,z,w)
					local xs,ys,zs = x + x,y + y,z + z
					local wx,wy,wz = w * xs,w * ys,w * zs
					local xx = x * xs
					local xy = x * ys
					local xz = x * zs
					local yy = y * ys
					local yz = y * zs
					local zz = z * zs
					return CFrame.new(px,py,pz,1 - (yy + zz),xy - wz,xz + wy,xy + wz,1 - (xx + zz),yz - wx,xz - wy,yz + wx,1 - (xx + yy))
				end

				function QS(a,b,t)
					local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
					local startInterp,finishInterp;
					if cosTheta >= 0.0001 then
						if (1 - cosTheta) > 0.0001 then
							local theta = math.acos(cosTheta)
							local invSinTheta = 1/math.sin(theta)
							startInterp = math.sin((1 - t) * theta) * invSinTheta
							finishInterp = math.sin(t * theta) * invSinTheta
						else
							startInterp = 1 - t
							finishInterp = t
						end
					else
						if (1 + cosTheta) > 0.0001 then
							local theta = math.acos(-cosTheta)
							local invSinTheta = 1/math.sin(theta)
							startInterp = math.sin((t - 1) * theta) * invSinTheta
							finishInterp = math.sin(t * theta) * invSinTheta
						else
							startInterp = t - 1
							finishInterp = t
						end
					end
					return a[1] * startInterp + b[1] * finishInterp,a[2] * startInterp + b[2] * finishInterp,a[3] * startInterp + b[3] * finishInterp,a[4] * startInterp + b[4] * finishInterp
				end

				function Clerp(a, b, t)
					local qa = {QFCF(a)}
					local qb = {QFCF(b)}
					local ax,ay,az = a.x,a.y,a.z
					local bx,by,bz = b.x,b.y,b.z
					local _t = 1 - t
					return QTCF(_t * ax + t * bx,_t * ay + t * by,_t * az + t * bz,QS(qa,qb,t))
				end

				function mdmg(centerofeffect,range)
					--[[pcall(function()
						for i,v in pairs(Funcs.Serv("Workspace"):GetDescendants()) do
							if not v:IsDescendantOf(Character) and v:IsA("Humanoid") and v.RootPart and (v.RootPart.Position - centerofeffect).Magnitude <= range + v.RootPart.Size.Magnitude then
								local deathp = Instance.new("Part")
								deathp.Anchored = true 
								deathp.Transparency = 1
								deathp.CanCollide = false
								deathp.CFrame = v.RootPart.CFrame
								local bruh = CreateSound(206082273,deathp,5,.75)
								bruh.PlayOnRemove = true
								for i = 1,10 do
									local a = Instance.new("Part")
									a.Name = randomstring()
									a.Anchored = true
									a.Position = deathp.Position
									a.Shape = "Ball"
									a.Color = COLORSHIFT
									a.Material = "Neon"
									a.CastShadow = false
									a.Size = Vector3.new(i*2.5,i*2.5,i*2.5)
									a.CanCollide = false
									a.Transparency = .75
									a.Parent = Funcs.Serv("Workspace")
									Funcs.Serv("Debris"):AddItem(a,1.5-i/10)
									for o = 1,3 do
										local hitm = script.SomeEffectIDK:Clone()
										hitm.Color = COLORSHIFT
										hitm.Trail.Color = ColorSequence.new(COLORSHIFT,Color3.new(1,1,1))
										hitm.attachment.ParticleEmitter.Color = ColorSequence.new(COLORSHIFT,Color3.new(1,1,1))
										hitm.CFrame = a.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))*CFrame.new(0,1,0)
										hitm.Parent = Effects
										hitm.Velocity = CFrame.new(hitm.Position,a.Position).LookVector*250
										Funcs.Serv("Debris"):AddItem(hitm,1.33)						
									end
								end
								deathp.Parent = Funcs.Serv("Workspace")
								pcall(function()
									deathp:Destroy()
								end)
								if v:IsDescendantOf(game) and v.Parent ~= Funcs.Serv("Workspace") and v.Parent ~= Funcs.Serv("Workspace").Terrain then
									v.RootPart:Destroy()
									local maxparent = v
									coroutine.resume(coroutine.create(function()
										local waitthing = 0
										waitthing = waitthing + Funcs.Serv("RunService").Heartbeat:Wait()
									end))
									maxparent:Destroy()
								elseif v:IsDescendantOf(game) then
									v.RootPart:Destroy()
									v:Destroy()
								end
							end
						end
					end)]]
				end

				function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
					local frame = IT("Frame")
					frame.BackgroundTransparency = TRANSPARENCY
					frame.BorderSizePixel = BORDERSIZEPIXEL
					frame.Position = POSITION
					frame.Size = SIZE
					frame.BackgroundColor3 = COLOR
					frame.BorderColor3 = BORDERCOLOR
					frame.Name = NAME
					frame.Parent = PARENT
					return frame
				end

				function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
					local label = IT("TextLabel")
					label.BackgroundTransparency = 1
					label.Size = UD2(1, 0, 1, 0)
					label.Position = UD2(0, 0, 0, 0)
					label.TextColor3 = TEXTCOLOR
					label.TextStrokeTransparency = STROKETRANSPARENCY
					label.TextTransparency = TRANSPARENCY
					label.FontSize = TEXTFONTSIZE
					label.Font = TEXTFONT
					label.BorderSizePixel = BORDERSIZEPIXEL
					label.TextScaled = false
					label.Text = TEXT
					label.Name = NAME
					label.Parent = PARENT
					return label
				end

				function NoOutlines(PART)
					PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
				end

				function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
					local NEWWELD = IT(TYPE)
					NEWWELD.Part0 = PART0
					NEWWELD.Part1 = PART1
					NEWWELD.C0 = C0
					NEWWELD.C1 = C1
					NEWWELD.Parent = PARENT
					return NEWWELD
				end

				local S = IT("Sound")
				function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
					local NEWSOUND = nil
					coroutine.resume(coroutine.create(function()
						NEWSOUND = S:Clone()
						NEWSOUND.Parent = PARENT
						NEWSOUND.Volume = 9e9
						NEWSOUND.Pitch = PITCH
						NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
						NEWSOUND:play()
						if DOESLOOP == true then
							NEWSOUND.Looped = true
						else
							repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
							NEWSOUND:remove()
						end
					end))
					return NEWSOUND
				end

				function CFrameFromTopBack(at, top, back)
					local right = top:Cross(back)
					return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
				end

				function nooutline(part)
					part.TopSurface,part.BottomSurface,part.LeftSurface,part.RightSurface,part.FrontSurface,part.BackSurface = 10,10,10,10,10,10
				end

				function part(formfactor,parent,material,reflectance,transparency,brickcolor,name,size)
					local fp=it("Part")
					fp.formFactor=formfactor
					fp.Parent=parent
					fp.Reflectance=reflectance
					fp.Transparency=transparency
					fp.CanCollide=false
					fp.Locked=true
					fp.BrickColor=BrickColor.new(tostring(brickcolor))
					fp.Name=name
					fp.Size=size
					fp.Position=Character.Torso.Position
					nooutline(fp)
					fp.Material=material
					fp:BreakJoints()
					return fp
				end

				function mesh(Mesh,part,meshtype,meshid,offset,scale)
					local mesh=it(Mesh)
					mesh.Parent=part
					if Mesh=="SpecialMesh" then
						mesh.MeshType=meshtype
						mesh.MeshId=meshid
					end
					mesh.Offset=offset
					mesh.Scale=scale
					return mesh
				end

				function weld(parent,part0,part1,c0,c1)
					local weld=it("Weld")
					weld.Parent=parent
					weld.Part0=part0
					weld.Part1=part1
					weld.C0=c0
					weld.C1=c1
					return weld
				end

				--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				function WACKYEFFECT(Table)
					if true then return end

					local TYPE = (Table.EffectType or "Sphere")
					local SIZE = (Table.Size or VT(1,1,1))
					local ENDSIZE = (Table.Size2 or VT(0,0,0))
					local TRANSPARENCY = (Table.Transparency or 0)
					local ENDTRANSPARENCY = (Table.Transparency2 or 1)
					local CFRAME = (Table.CFrame or Torso.CFrame)
					local MOVEDIRECTION = (Table.MoveToPos or nil)
					local ROTATION1 = (Table.RotationX or 0)
					local ROTATION2 = (Table.RotationY or 0)
					local ROTATION3 = (Table.RotationZ or 0)
					local MATERIAL = (Table.Material or "Neon")
					local COLOR = (Table.Color or C3(1,1,1))
					local TIME = (Table.Time or 45)
					local SOUNDID = (Table.SoundID or nil)
					local SOUNDPITCH = (Table.SoundPitch or nil)
					local SOUNDVOLUME = (Table.SoundVolume or nil)
					coroutine.resume(coroutine.create(function()
						local PLAYSSOUND = false
						local SOUND = nil
						local EFFECT = CreatePart(3, workspace, "Neon", 0, 0, C3(0,0,0), "Effect", VT(1,1,1), true)
						EFFECT.Color = COLORSHIFT
						if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
							PLAYSSOUND = true
							SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
						end
						local MSH = nil
						if TYPE == "Sphere" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
						elseif TYPE == "Block" then
							MSH = IT("BlockMesh",EFFECT)
							MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
						elseif TYPE == "Wave" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
						elseif TYPE == "Ring" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
						elseif TYPE == "Slash" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
						elseif TYPE == "Round Slash" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
						elseif TYPE == "Swirl" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
						elseif TYPE == "Skull" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
						elseif TYPE == "Crystal" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
						end
						if MSH ~= nil then
							local MOVESPEED = nil
							if MOVEDIRECTION ~= nil then
								MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
							end
							local GROWTH = SIZE - ENDSIZE
							local TRANS = TRANSPARENCY - ENDTRANSPARENCY
							if TYPE == "Block" then
								EFFECT.CFrame = CFRAME*ANGLES(RAD(MATHR(0,360)),RAD(MATHR(0,360)),RAD(MATHR(0,360)))
							else
								EFFECT.CFrame = CFRAME
							end
							for LOOP = 1, TIME+1 do
								Swait()
								MSH.Scale = MSH.Scale - GROWTH/TIME
								if TYPE == "Wave" then
									MSH.Offset = VT(0,0,-MSH.Scale.X/8)
								end
								EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
								if TYPE == "Block" then
									EFFECT.CFrame = CFRAME*ANGLES(RAD(MATHR(0,360)),RAD(MATHR(0,360)),RAD(MATHR(0,360)))
								else
									EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
								end
								if MOVEDIRECTION ~= nil then
									local ORI = EFFECT.Orientation
									EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
									EFFECT.Orientation = ORI
								end
							end
							if PLAYSSOUND == false then
								EFFECT:remove()
							else
								SOUND.Stopped:Connect(function()
								game:GetService("RunService").RenderStepped:Wait()
									EFFECT:remove()
								end)
							end
						else
							if PLAYSSOUND == false then
								EFFECT:remove()
							else
								repeat Swait() until SOUND.Playing == false
								EFFECT:remove()
							end
						end
					end))
				end

				function WACKYEFFECT2(Table)
					if true then return end
					local TYPE = Table.EffectType or "Sphere"
					local SIZE = Table.Size or VT(1, 1, 1)
					local ENDSIZE = Table.Size2 or VT(0, 0, 0)
					local TRANSPARENCY = Table.Transparency or 0
					local ENDTRANSPARENCY = Table.Transparency2 or 1
					local CFRAME = Table.CFrame or Torso.CFrame
					local MOVEDIRECTION = Table.MoveToPos or nil
					local ROTATION1 = Table.RotationX or 0
					local ROTATION2 = Table.RotationY or 0
					local ROTATION3 = Table.RotationZ or 0
					local MATERIAL = Table.Material --or "Neon"
					local COLOR = Table.Color or C3(1, 1, 1)
					local TIME = Table.Time or 45
					local SOUNDID = Table.SoundID or nil
					local SOUNDPITCH = Table.SoundPitch or nil
					local SOUNDVOLUME = Table.SoundVolume or nil
					local USEBOOMERANGMATH = Table.UseBoomerangMath or false
					local BOOMERANG = Table.Boomerang or 0
					local SIZEBOOMERANG = Table.SizeBoomerang or 0
					coroutine.resume(coroutine.create(function()
						local PLAYSSOUND = false
						local SOUND = nil
						local EFFECT = CreatePart(3, Effects, "Neon", 0, 0, C3(0,0,0), "Effect", VT(1,1,1), true)
						EFFECT.Color = COLORSHIFT
						if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
							PLAYSSOUND = true
							SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
						end
						local MSH
						if TYPE == "Sphere" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0, 0, 0))
						elseif TYPE == "Block" or TYPE == "Box" then
							MSH = IT("BlockMesh", EFFECT)
							MSH.Scale = SIZE
						elseif TYPE == "Wave" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0, 0, -SIZE.X / 8))
						elseif TYPE == "Ring" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X, SIZE.X, 0.1), VT(0, 0, 0))
						elseif TYPE == "Slash" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
						elseif TYPE == "Round Slash" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
						elseif TYPE == "Swirl" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0, 0, 0))
						elseif TYPE == "Skull" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0, 0, 0))
						elseif TYPE == "Star" then 
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "2760116123", "", SIZE, VT(0,0,0))   	
						elseif TYPE == "Crystal" then
							MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "450656451", "", SIZE, VT(0, 0, 0))
						end
						coroutine.resume(coroutine.create(function()
							if MSH ~= nil then
								local BOOMR1 = 1 + BOOMERANG / 50
								local BOOMR2 = 1 + SIZEBOOMERANG / 50
								local MOVESPEED = nil
								if MOVEDIRECTION ~= nil then
									MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
								end
								local GROWTH
								if USEBOOMERANGMATH == true then
									GROWTH = (SIZE - ENDSIZE) * (BOOMR2 + 1)
								else
									GROWTH = SIZE - ENDSIZE
								end
								local TRANS = TRANSPARENCY - ENDTRANSPARENCY
								if TYPE == "Block" then
									EFFECT.CFrame = CFRAME * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360)))
								else
									EFFECT.CFrame = CFRAME
								end
								if USEBOOMERANGMATH == true then
									for LOOP = 1, TIME + 1 do
										Swait()
										MSH.Scale = MSH.Scale - VT(GROWTH.X * (1 - LOOP / TIME * BOOMR2), GROWTH.Y * (1 - LOOP / TIME * BOOMR2), GROWTH.Z * (1 - LOOP / TIME * BOOMR2)) * BOOMR2 / TIME
										if TYPE == "Wave" then
											MSH.Offset = VT(0, 0, -MSH.Scale.Z / 8)
										end
										EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
										if TYPE == "Block" then
											EFFECT.CFrame = CFRAME * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360)))
										else
											EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
										end
										if MOVEDIRECTION ~= nil then
											local ORI = EFFECT.Orientation
											EFFECT.CFrame = CF(EFFECT.Position, MOVEDIRECTION) * CF(0, 0, -MOVESPEED * (1 - LOOP / TIME * BOOMR1))
											EFFECT.Orientation = ORI
										end
									end
								else
									for LOOP = 1, TIME + 1 do
										Swait()
										MSH.Scale = MSH.Scale - GROWTH / TIME
										if TYPE == "Wave" then
											MSH.Offset = VT(0, 0, -MSH.Scale.Z / 8)
										end
										EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
										if TYPE == "Block" then
											EFFECT.CFrame = CFRAME * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360)))
										else
											EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
										end
										if MOVEDIRECTION ~= nil then
											local ORI = EFFECT.Orientation
											EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
											EFFECT.Orientation = ORI
										end
									end
								end
								EFFECT.Transparency = 1
								if PLAYSSOUND == false then
									EFFECT:remove()
								else
									repeat
										Swait()
									until EFFECT:FindFirstChildOfClass("Sound") == nil
									EFFECT:remove()
								end
							elseif PLAYSSOUND == false then
								EFFECT:remove()
							else
								repeat
									Swait()
								until EFFECT:FindFirstChildOfClass("Sound") == nil
								EFFECT:remove()
							end
						end))
						return EFFECT
					end))
				end   

				function MakeForm(PART,TYPE)
					if true then return end
					if TYPE == "Cyl" then
						local MSH = IT("CylinderMesh",PART)
					elseif TYPE == "Ball" then
						local MSH = IT("SpecialMesh",PART)
						MSH.MeshType = "Sphere"
					elseif TYPE == "Wedge" then
						local MSH = IT("SpecialMesh",PART)
						MSH.MeshType = "Wedge"
					end
				end

				function SpawnTrail(FROM,TO,BIG)
					if true then return end
					local TRAIL = CreatePart(3, Funcs.Serv("Workspace"), "Neon", 0, 0.5, "Really red", "Trail", VT(0,0,0))
					MakeForm(TRAIL,"Cyl")
					local DIST = (FROM - TO).Magnitude
					if BIG == true then
						TRAIL.Size = VT(0.5,DIST,0.5)
					else
						TRAIL.Size = VT(0.25,DIST,0.25)
					end
					TRAIL.Name = "Effect"
					TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
					coroutine.resume(coroutine.create(function()
						while true do
							Swait()
							TRAIL.Color = COLORSHIFT
						end
					end))
					coroutine.resume(coroutine.create(function()
						for i = 1, 5 do
							Swait()
							TRAIL.Transparency = TRAIL.Transparency + 0.01
						end
						wait(4.2)
						TRAIL:remove()
					end))
				end
				Debris = Funcs.Serv("Debris")

				function CastProperRay(StartPos, EndPos, Distance, Ignore)
					local DIRECTION = CF(StartPos,EndPos).lookVector
					return Raycast(StartPos, DIRECTION, Distance, Ignore)
				end

				function turnto(position)
					RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
				end

				CameraRootPart.CFrame = RootPart.CFrame
				CameraRootPart.Anchored = false
				CreateWeldOrSnapOrMotor("Weld", CameraRootPart, CameraRootPart, RootPart, CFrame.new(0, -1.5, 0), CFrame.new(0, 0, 0))

				local asd = Instance.new("ParticleEmitter")
				asd.Color = ColorSequence.new(Color3.new(0.5, 0, 0), Color3.new(.1, 0, 0))
				asd.LightEmission = .1
				asd.Size = NumberSequence.new(0.2)
				asd.Texture = "http://www.roblox.com/asset/?ID=291880914"
				aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.2),NumberSequenceKeypoint.new(1, 5)})
				bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
				asd.Transparency = bbb
				asd.Size = aaa
				asd.ZOffset = .9
				asd.Acceleration = Vector3.new(0, -5, 0)
				asd.LockedToPart = false
				asd.EmissionDirection = "Back"
				asd.Lifetime = NumberRange.new(1, 2)
				asd.Rotation = NumberRange.new(-100, 100)
				asd.RotSpeed = NumberRange.new(-100, 100)
				asd.Speed = NumberRange.new(2)
				asd.Enabled = false
				asd.VelocitySpread = 10000

				function getbloody(victim,amount)
					if true then return end
					local prtcl = asd:Clone()
					prtcl.Parent = victim
					prtcl:Emit(amount)
				end

				local TORSOVELOCITY = 0

				function Ragdoll(Character2,CharTorso)
					if true then return end
					local svch = Character2
					local hum = Character2:findFirstChild("Humanoid")
					local q = Character2:GetChildren()
					local CLONE = IT("Model",Effects)
					local DummyHead = nil
					for i = 1,#q do
						if q[i].ClassName ~= "Humanoid" and q[i].ClassName ~= "LocalScript" and q[i].ClassName ~= "Script" and q[i].ClassName ~= "Accessory" and q[i].ClassName ~= "Hat" and q[i].ClassName ~= "Gear" then
							q[i].Parent = CLONE
							if q[i].Name == "Head" then
								DummyHead = CLONE.Head:Clone()
								q[i]:ClearAllChildren()
								q[i].Transparency = 1
							end
						else
							if q[i].ClassName ~= "Humanoid" then
								q[i]:remove()
							end
						end
					end
					local chrclone = CLONE

					for _, c in pairs(Character2:GetChildren()) do
						if c.ClassName == "Accessory" then
							c:remove()
						end
					end

					local ch = chrclone:GetChildren()
					local i
					for i = 1,#ch do
						if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" or ch[i].ClassName == "Script" then
							ch[i]:remove()
						end
					end
					local function Scan(ch)
						local e
						for e = 1,#ch do
							Scan(ch[e]:GetChildren())
							if ch[e].ClassName == "Weld" or ch[e].ClassName == "Motor6D" then
								ch[e]:remove()
							end
						end
					end
					Scan(chrclone:GetChildren())

					local ch = Character2:GetChildren()
					local i
					for i = 1,#ch do
						if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
							ch[i]:remove()
						end
					end

					local ch = Character2:GetChildren()
					local i
					for i = 1,#ch do
						if ch[i].ClassName == "Part" or ch[i].ClassName == "Hat" or ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
							ch[i]:remove()
						end
					end
					Character2 = chrclone
					local Torso2 = Character2.Torso
					local movevector = Vector3.new()

					if Torso2 then
						movevector = CFrame.new(CharTorso.Position,Torso2.Position).lookVector
						local Head = Character2:FindFirstChild("Head")
						if Head then
							local Neck = Instance.new("Weld")
							Neck.Name = "Neck"
							Neck.Part0 = Torso2
							Neck.Part1 = Head
							Neck.C0 = CFrame.new(0, 1.5, 0)
							Neck.C1 = CFrame.new()
							Neck.Parent = Torso2
							Head:ClearAllChildren()
							Head.Transparency = 1

						end
						local Limb = Character2:FindFirstChild("Right Arm")
						if Limb then

							Limb.CFrame = Torso2.CFrame * CFrame.new(1.5, 0, 0)
							local Joint = Instance.new("Glue")
							Joint.Name = "RightShoulder"
							Joint.Part0 = Torso2
							Joint.Part1 = Limb
							Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
							Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
							Joint.Parent = Torso2

							local B = Instance.new("Part")
							B.TopSurface = 0
							B.BottomSurface = 0
							B.formFactor = "Symmetric"
							B.Size = Vector3.new(1, 1, 1)
							B.Transparency = 1
							B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
							B.Parent = Character2
							local W = Instance.new("Weld")
							W.Part0 = Limb
							W.Part1 = B
							W.C0 = CFrame.new(0, -0.5, 0)
							W.Parent = Limb

						end
						local Limb = Character2:FindFirstChild("Left Arm")
						if Limb then

							Limb.CFrame = Torso2.CFrame * CFrame.new(-1.5, 0, 0)
							local Joint = Instance.new("Glue")
							Joint.Name = "LeftShoulder"
							Joint.Part0 = Torso2
							Joint.Part1 = Limb
							Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
							Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
							Joint.Parent = Torso2

							local B = Instance.new("Part")
							B.TopSurface = 0
							B.BottomSurface = 0
							B.formFactor = "Symmetric"
							B.Size = Vector3.new(1, 1, 1)
							B.Transparency = 1
							B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
							B.Parent = Character2
							local W = Instance.new("Weld")
							W.Part0 = Limb
							W.Part1 = B
							W.C0 = CFrame.new(0, -0.5, 0)
							W.Parent = Limb

						end
						local Limb = Character2:FindFirstChild("Right Leg")
						if Limb then

							Limb.CFrame = Torso2.CFrame * CFrame.new(0.5, -2, 0)
							local Joint = Instance.new("Glue")
							Joint.Name = "RightHip"
							Joint.Part0 = Torso2
							Joint.Part1 = Limb
							Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
							Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
							Joint.Parent = Torso2

							local B = Instance.new("Part")
							B.TopSurface = 0
							B.BottomSurface = 0
							B.formFactor = "Symmetric"
							B.Size = Vector3.new(1, 1, 1)
							B.Transparency = 1
							B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
							B.Parent = Character2
							local W = Instance.new("Weld")
							W.Part0 = Limb
							W.Part1 = B
							W.C0 = CFrame.new(0, -0.5, 0)
							W.Parent = Limb

						end
						local Limb = Character2:FindFirstChild("Left Leg")
						if Limb then

							Limb.CFrame = Torso2.CFrame * CFrame.new(-0.5, -2, 0)
							local Joint = Instance.new("Glue")
							Joint.Name = "LeftHip"
							Joint.Part0 = Torso2
							Joint.Part1 = Limb
							Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
							Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
							Joint.Parent = Torso2

							local B = Instance.new("Part")
							B.TopSurface = 0
							B.BottomSurface = 0
							B.formFactor = "Symmetric"
							B.Size = Vector3.new(1, 1, 1)
							B.Transparency = 1
							B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
							B.Parent = Character2
							local W = Instance.new("Weld")
							W.Part0 = Limb
							W.Part1 = B
							W.C0 = CFrame.new(0, -0.5, 0)
							W.Parent = Limb

						end
						--[
						local Bar = Instance.new("Part")
						Bar.TopSurface = 0
						Bar.BottomSurface = 0
						Bar.formFactor = "Symmetric"
						Bar.Size = Vector3.new(1, 1, 1)
						Bar.Transparency = 1
						Bar.CFrame = Torso2.CFrame * CFrame.new(0, 0.5, 0)
						Bar.Parent = Character2
						local Weld = Instance.new("Weld")
						Weld.Part0 = Torso2
						Weld.Part1 = Bar
						Weld.C0 = CFrame.new(0, 0.5, 0)
						Weld.Parent = Torso2
						--]]
					end
					Character2.Parent = Weapon
					if movevector ~= Vector3.new() then
						for i = 1,10 do
							Torso2.Velocity = movevector * 30
						end
					end
					DummyHead.Name = "FakeHead"
					DummyHead.Parent = CLONE
					local BLOOD = CreatePart(3, DummyHead, "Glass", 0, 0, "Maroon", "Blood", VT(0.65,0.25,0.65),false)
					BLOOD.CFrame = DummyHead.CFrame*CF(0,-DummyHead.Size.Y/2,0)
					MakeForm(BLOOD,"Cyl")
					weldBetween(DummyHead,BLOOD)
					local BLOOD = CreatePart(3, Torso2, "Glass", 0, 0, "Maroon", "Blood", VT(0.65,0.2,0.65),false)
					BLOOD.CFrame = Torso2.CFrame*CF(0,Torso2.Size.Y/2,0)
					MakeForm(BLOOD,"Cyl")
					weldBetween(Torso2,BLOOD)
					Character2.Name = "Corpse"
					local hum2 = svch:findFirstChild("Humanoid")

					return Character2,Torso2,DummyHead
				end

				function PuddleOfBlood(Position,MaxDrop,Model,MaxSize)
					if true then return end

					local HITFLOOR, HITPOS = Raycast(Position, (CF(Position, Position + VT(0, -1, 0))).lookVector, MaxDrop, Model)
					if HITFLOOR ~= nil then
						if HITFLOOR.Parent ~= Weapon and HITFLOOR.Parent ~= Character then
							if HITFLOOR.Name == "BloodPuddle" then
								local DIST = (Position - HITFLOOR.Position).Magnitude
								if (HITFLOOR.Size.Z <= 5 and HITFLOOR.Size.Z < MaxSize) or (HITFLOOR.Size.Z > 5 and HITFLOOR.Size.Z < MaxSize and DIST < HITFLOOR.Size.Z/3) then
									HITFLOOR.Size = HITFLOOR.Size + VT(0.1,0,0.1)
								end
							else
								if HITFLOOR.Anchored == true then
									local BLOOD = CreatePart(3, Effects, "Glass", 0, 0, "Maroon", "BloodPuddle", VT(1,0,1))
									BLOOD.CFrame = CF(HITPOS)
									MakeForm(BLOOD,"Cyl")
									coroutine.resume(coroutine.create(function()
										Swait(75)
										while true do
											Swait()
											BLOOD.Size = BLOOD.Size - VT(0.02,0,0.02)
											if BLOOD.Size.Z < 0.051 then
												BLOOD:remove()
												break
											end
										end
									end))
								end
							end
						end
					end
				end

				function SprayBlood(POSITION,DIRECTION,BloodSize)
					if true then return end

					local BLOOD = CreatePart(3, Effects, "Glass", 0, 0, "Maroon", "BloodPuddle", VT(0.5,0.5,0.5),false)
					BLOOD.CFrame = CF(POSITION)
					MakeForm(BLOOD,"Ball")
					local bv = Instance.new("BodyVelocity",BLOOD) 
					bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
					bv.velocity = CF(POSITION,DIRECTION+VT(MATHR(-3,3)/30,MATHR(-3,3)/30,MATHR(-3,3)/30)).lookVector*15
					bv.Name = "MOVE"
					Debris:AddItem(bv,0.05)
					coroutine.resume(coroutine.create(function()
						local HASTOUCHEDGROUND = false
						local HIT = BLOOD.Touched:Connect(function(hit)
						game:GetService("RunService").RenderStepped:Wait()
							if hit.Anchored == true then
								HASTOUCHEDGROUND = true
								PuddleOfBlood(BLOOD.Position+VT(0,1,0),2,BLOOD,BloodSize)
							end
						end)
						for i = 1, 50 do
							Swait()
							if HASTOUCHEDGROUND == true then
								break
							end
							BLOOD.Size = BLOOD.Size * 0.9
						end
						BLOOD:remove()
					end))
				end

				function DESTROYAHAHAHAHAH(Target)
					if Target.Parent ~= Weapon and Target:FindFirstChildOfClass("Humanoid") then
						Target:BreakJoints()
						local CFRAME = Target:FindFirstChild("Torso").CFrame or Target:FindFirstChild("UpperTorso")
						local CLONE,TORS2,DummyHead = Ragdoll(Target,Torso)
						getbloody(DummyHead,45)
						if TORS2 ~= nil then
							CreateSound("185688060", TORS2, 10, (math.random(8,12)/10))
							CreateSound("337800380", DummyHead, 5, (math.random(8,18)/10))
							local HUM = IT("Humanoid")
							HUM.MaxHealth = 0
							HUM.Health = 0
							HUM.Name = "CorpseHumanoid"
							HUM.PlatformStand = true
							HUM.Parent = CLONE
							TORS2.CFrame = CFRAME
							coroutine.resume(coroutine.create(function()
								for i = 1, 450 do
									wait()
									SprayBlood(DummyHead.CFrame*CF(0,-0.25,0).p,DummyHead.CFrame*CF(0,-0.7,0).p,5)
									SprayBlood(TORS2.CFrame*CF(0,TORS2.Size.Y/2,0).p,TORS2.CFrame*CF(0,TORS2.Size.Y,0).p,10)
									PuddleOfBlood(DummyHead.CFrame*CF(0,-0.25,0).p,4,CLONE,3)
									PuddleOfBlood(TORS2.CFrame*CF(0,TORS2.Size.Y/2,0).p,8,CLONE,6)
								end
								CLONE:Remove()
							end))
						end
					end
				end

				local SayText = Instance.new("ScreenGui")
				SayText.Name = "CreditsAndAuthentication"
				SayText.ResetOnSpawn = false
				SayText.Parent = lplr:FindFirstChildOfClass("PlayerGui")
				local SayText2 = Instance.new("TextLabel",SayText)
				SayText2.BackgroundTransparency = 1
				SayText2.BorderSizePixel = 0
				SayText2.Text = "  ?   !"
				SayText2.Font = "Code"
				SayText2.TextScaled = true
				SayText2.TextStrokeTransparency = 0
				coroutine.resume(coroutine.create(function()

				end))

				--//=================================				--||	     WEAPON CREATION
				--=================================//

				local YCSI = script["DE#3989fd03ud"]["YCSI"]

				local GUN = script["DE#3989fd03ud"]["Model"]

				local cannon = script["DE#3989fd03ud"]["Cannon"]

				local Blade = YCSI:Clone()
				local Gunclone = GUN:Clone()
				local cannon = cannon:Clone()

				Blade.Parent = Character
				Gunclone.Parent = Character
				local BladeGrip = CreateWeldOrSnapOrMotor("Weld", Blade.Handle, RightArm, Blade.Handle, CF(0, -1, 0)*ANGLES(RAD(90),RAD(0),RAD(0)), CF(0, 0, 0))
				local gunGrip = CreateWeldOrSnapOrMotor("Weld", Gunclone.Handle, RightArm, Gunclone.Handle, CF(0,-1, 0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0.21, 0))
				local CannonGrip = CreateWeldOrSnapOrMotor("Weld", cannon, RightArm, cannon, CF(.05,-1,-.15) * ANGLES(RAD(-90),RAD(0),RAD(0)),CF(0.05, -1, 2.2))
				--cannon.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1
				local BackBlade = YCSI:Clone()
				Blade.Parent = Character
				CreateWeldOrSnapOrMotor("Weld", BackBlade.REDB, Torso, BackBlade.REDB, CF(1, -0.5, 0.5)*ANGLES(RAD(0),RAD(0),RAD(-45)), CF(0, 0, 0))

				local WEAPONGUI = IT("ScreenGui")


				local SKILLTEXTCOLOR = Color3.fromRGB(100,0,0)
				local SKILLFONT = Enum.Font.Antique
				local SKILLTEXTSIZE = 7.5

				local ATTACKS = {""..SCRIPTVERSION.."","Q","E","T","J","K","L","Z","X","C","V","B"}
				local ATTACKSFRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill Frame")
				local TEXT = CreateLabel(ATTACKSFRAME, "[BANISH]", SKILLTEXTCOLOR, SKILLTEXTSIZE+1, SKILLFONT, 0, 2, 0.5, "Skill text")

				for i = 1, #ATTACKS do
					local SKILLFRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.90-(0.04*i), 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill Frame")
					local SKILLTEXT = CreateLabel(SKILLFRAME, "["..ATTACKS[i].."]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Skill text")
				end

				coroutine.wrap(function()
					while wait() do
						mtext2.TextColor3 = COLORSHIFT
						WEAPONGUI.Parent = PlayerGui
						cannon.Color = COLORSHIFT
						LWing.Color = COLORSHIFT
						RWing.Color = COLORSHIFT
						Funcs.Serv("Lighting").ClockTime = 0
						for i,v in pairs(Gunclone:GetChildren()) do
							v.Color = COLORSHIFT
						end
						if MODE == 1 then
							TEXT.Text = "[Normal]"
							mtext2.Text = "Hyperskidded Echo"
							MusID.Value = "1296056458"
						elseif MODE == 2 then
							TEXT.Text = "[BloodWater]"
							mtext2.Text = "HSE - B l o o d W a t e r"
							MusID.Value = "4835535512"
						elseif MODE == 3 then
							TEXT.Text = "[Bad Apple]"
							mtext2.Text = "HSE - B a d  A p p l e"
							MusID.Value = "932923622"
						elseif MODE == 4 then -- a dance of fire and ice
							TEXT.Text = "[Ultraskidded Echo]"
							mtext2.Text = "HSE - U l t r a s k i d d e d  E c h o"
							MusID.Value = "6144914219"
						elseif MODE == 5 then
							TEXT.Text = "[Error (USE)]"
							mtext2.Text = "HSE - E r r o r (USE)"
							MusID.Value = "2349318464"
						elseif MODE == 6 then
							TEXT.Text = "[Hyperskidded Cannon]"
							mtext2.Text = "HSE - H y p e r s k i d d e d  C a n n o n"
							MusID.Value = "5495430725"
						elseif MODE == 7 then
							TEXT.Text = "[SOLID LC]"
							mtext2.Text = "HSE - S O L I D  L C"
							MusID.Value = "348832364"
						elseif MODE == 8 then
							TEXT.Text = "[Err0r]"
							mtext2.Text = "HSE - E r r 0 r"
							MusID.Value = "859912308"
						elseif MODE == 9 then
							TEXT.Text = "[Purple guy]"
							mtext2.Text = "HSE - P u r p l e  g u y"
							MusID.Value = "5177243035"
						elseif MODE == 10 then
							TEXT.Text = "[Chilled]"
							mtext2.Text = "HSE - C h i l l e d"
							MusID.Value = "679355361"
						elseif MODE == 11 then
							TEXT.Text = "[Echo]"
							mtext2.Text = "HSE - E c h o"
							MusID.Value = "573736432"
						elseif MODE == 12 then
							TEXT.Text = "[SuperUBlockAlt]"
							mtext2.Text = "HSE - S u p e r U B l o c k A l t"
							MusID.Value = "2242814132"
						elseif MODE == 13 then
							TEXT.Text = "[Immortality Lord]"
							mtext2.Text = "HSE - I m m o r t a l i t y  L o r d"
							MusID.Value = "6049110238"
						elseif MODE == 14 then
							TEXT.Text = "[Lightning Cannon]"
							mtext2.Text = "HSE - L i g h t n i n g  C a n n o n"
							MusID.Value = "3247404955"
						elseif MODE == 15 then
							TEXT.Text = "[Kickisher Rewrite v4]"
							mtext2.Text = "HSE - K R e w r i t e V 4"
							MusID.Value = "143884682"
						elseif MODE == 16 then
							TEXT.Text = "[MAYHEM]"
							mtext2.Text = "HSE - M A Y H E M"
							MusID.Value = "614032233"
						elseif MODE == 17 then
							TEXT.Text = "[Death]"
							mtext2.Text = "HSE - D e a t h"
							MusID.Value = "1426355953"
						elseif MODE == 18 then
							TEXT.Text = "[Redemption]"
							mtext2.Text = "HSE - R e d e m p t i o n"
							MusID.Value = "1632083717"
						elseif MODE == 19 then
							TEXT.Text = "[SBV4 SCR]"
							mtext2.Text = "HSE - S B V 4  S C R"
							MusID.Value = "199531143"
						elseif MODE == 20 then
							TEXT.Text = "[Corrupt]"
							mtext2.Text = "HSE - C o r r u p t"
							MusID.Value = "151915559"
						elseif MODE == 21 then
							TEXT.Text = "[]"
							mtext2.Text = "HSE - "
							MusID.Value = ""
						elseif MODE == 22 then
							TEXT.Text = "[]"
							mtext2.Text = "HSE - "
							MusID.Value = ""
						elseif MODE == 23 then
							TEXT.Text = "[]"
							mtext2.Text = "HSE - "
							MusID.Value = ""
						elseif MODE == 24 then
							TEXT.Text = "[]"
							mtext2.Text = "HSE - "
							MusID.Value = ""
						elseif MODE == 25 then
							TEXT.Text = "[]"
							mtext2.Text = "HSE - "
							MusID.Value = ""
						elseif MODE == 26 then
							TEXT.Text = "[]"
							mtext2.Text = "HSE - "
							MusID.Value = ""
						elseif MODE == 27 then
							TEXT.Text = "[]"
							mtext2.Text = "HSE - "
							MusID.Value = ""
						elseif MODE == 28 then
							TEXT.Text = "[]"
							mtext2.Text = "HSE - "
							MusID.Value = ""
						elseif MODE == 29 then
							TEXT.Text = "[]"
							mtext2.Text = "HSE - "
							MusID.Value = ""
						elseif MODE == 30 then
							TEXT.Text = "[]"
							mtext2.Text = "HSE - "
							MusID.Value = ""
						end
						Sick.SoundId = "rbxassetid://"..MusID.Value
						Sick.Volume = SongVol.Value
					end
				end)()


				local CreationFolder = IT("Folder",Character)
				CreationFolder.Name = "CreationFolder"

				local LASTPART2 = Head--Extra Horns 1
				for i = 1, 36 do
					local MATH = (1-(i/25))
					if LASTPART2 == Head then
						local Horn2 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn2", VT(0.25*MATH,0.25,0.25*MATH),false)
						CreateWeldOrSnapOrMotor("Weld", LASTPART2, LASTPART2, Horn2, CF(0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(15), RAD(-15)), CF(0, 0, 0))
						LASTPART2 = Horn2
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								Horn2.Color = COLORSHIFT
							end
						end))
					else
						local Horn2 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn2", VT(0.25*MATH,0.25,0.25*MATH),false)
						CreateWeldOrSnapOrMotor("Weld", LASTPART2, LASTPART2, Horn2, CF(0, Horn2.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(-0.3), RAD(0)), CF(0, 0, 0))
						LASTPART2 = Horn2
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								Horn2.Color = COLORSHIFT
							end
						end))
					end
				end--
				local LASTPART2 = Head--Extra Horns 2
				for i = 1, 36 do
					local MATH = (1-(i/25))
					if LASTPART2 == Head then
						local Horn2 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn2", VT(0.25*MATH,0.25,0.25*MATH),false)
						CreateWeldOrSnapOrMotor("Weld", LASTPART2, LASTPART2, Horn2, CF(-0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(-15), RAD(15)), CF(0, 0, 0))
						LASTPART2 = Horn2
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								Horn2.Color = COLORSHIFT
							end
						end))
					else
						local Horn2 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn2", VT(0.25*MATH,0.25,0.25*MATH),false)
						CreateWeldOrSnapOrMotor("Weld", LASTPART2, LASTPART2, Horn2, CF(0, Horn2.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(0.3), RAD(0)), CF(0, 0, 0))
						LASTPART2 = Horn2
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								Horn2.Color = COLORSHIFT
							end
						end))
					end
				end

				local LASTPART = Head
				for i = 1, 62 do
					local MATH = (1-(i/25))
					if LASTPART == Head then
						local Horn = CreatePart(3, Character, "Neon", 0, 0, "Dirt brown", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
						CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(15), RAD(-15)), CF(0, 0, 0))
						LASTPART = Horn
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								Horn.Color = COLORSHIFT
							end
						end))
					else
						local Horn = CreatePart(3, Character, "Neon", 0, 0, "Dirt brown", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
						CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(-2.5), RAD(0)), CF(0, 0, 0))
						LASTPART = Horn
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								Horn.Color = COLORSHIFT
							end
						end))
					end
				end
				local LASTPART = Head
				for i = 1, 62 do
					local MATH = (1-(i/25))
					if LASTPART == Head then
						local Horn = CreatePart(3, Character, "Neon", 0, 0, "Dirt brown", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
						CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(-0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(-15), RAD(15)), CF(0, 0, 0))
						LASTPART = Horn
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								Horn.Color = COLORSHIFT
							end
						end))
					else
						local Horn = CreatePart(3, Character, Enum.Material.Neon, 0, 0, "Dirt brown", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
						CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(2.5), RAD(0)), CF(0, 0, 0))
						LASTPART = Horn
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								Horn.Color = COLORSHIFT
							end
						end))
					end
				end
				local LASTPART = Torso
				for i = 1, 75 do
					local MATH = 1 - i / 70
					if LASTPART == Torso then
						local Tail = CreatePart(3, Character, Enum.Material.Neon, 0, 0, "New Yeller", "Tail", VT(0.25 * MATH, 0.25, 0.25 * MATH), false)
						local WLD = CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Tail, CF(0, -0.75, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
						LASTPART = Tail
						Tail.Color = C3((i*3-3)/.5,0,.5)
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								Tail.Color = COLORSHIFT
							end
						end))
						table.insert(TAIL, WLD)
					else
						local Tail = CreatePart(3, Character, Enum.Material.Neon, 0, 0, "New Yeller", "Tail", VT(0.25 * MATH, 0.25, 0.25 * MATH), false)
						local WLD = CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Tail, CF(0, Tail.Size.Y / 2, 0) * ANGLES(RAD(-1.2), RAD(0), RAD(0)), CF(0, 0, 0))
						LASTPART = Tail
						Tail.Color = C3((i*3-3)/.5,0,.5)
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								Tail.Color = COLORSHIFT
							end
						end))
						table.insert(TAIL, WLD)
					end
				end


				Humanoid:SetStateEnabled("Dead",false)
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead,false)

				Humanoid:SetStateEnabled("GettingUp",true)
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp,true)
				Humanoid:SetStateEnabled("Ragdoll",false)
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)

				local PlayerSize = 1
				local FT,FRA,FLA,FRL,FLL = Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh")
				FT.MeshId,FT.Scale = "rbxasset://fonts/torso.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
				FRA.MeshId,FRA.Scale = "rbxasset://fonts/rightarm.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
				FLA.MeshId,FLA.Scale = "rbxasset://fonts/leftarm.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
				FRL.MeshId,FRL.Scale = "rbxasset://fonts/rightleg.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
				FLL.MeshId,FLL.Scale = "rbxasset://fonts/leftleg.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)

				Funcs.Serv("Workspace").ChildAdded:connect(function(instance)
				game:GetService("RunService").RenderStepped:Wait()
					for BANISH = 1, #TOBANISH do
						if TOBANISH[BANISH] ~= nil then
							if instance.Name == TOBANISH[BANISH] then
								coroutine.resume(coroutine.create(function()
									instance:ClearAllChildren()
									Debris:AddItem(instance,0.0005)
								end))
							end
						end
					end
				end)

				--//=================================				--||			DAMAGING
				--=================================//

				function Kill(MODEL)
					if MODEL == nil then return end
					MODELOLD = MODEL
					MODELARCHIVABLE = MODEL.Archivable
					MODELOLD.Archivable = true

					MODEL = MODELOLD:Clone()
					MODEL.Parent = workspace
					MODELOLD.Archivable = MODELARCHIVABLE
					MODEL:BreakJoints()
					local HUM = MODEL:FindFirstChildOfClass("Humanoid")
					if MODE == 1 then
						coroutine.resume(coroutine.create(function()
							table.insert(TOBANISH,MODEL.Name)	
						end))		
					end
					if HUM then
						for index, CHILD in pairs(MODEL:GetChildren()) do
							if CHILD:IsA("BasePart") then
								if CHILD.Name == "Head" then
									WACKYEFFECT2({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Granite", Color = C3(.75,0,0), SoundID = nil, SoundPitch = .8, SoundVolume = 4, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
									WACKYEFFECT2({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Granite", Color = C3(.5,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
									WACKYEFFECT2({Time = MATHR(10,30)*12, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MATHR(-360,360)/1.5,MATHR(-360,360)/1.5,0), MATHR(-360,360)/35, RotationX = MATHR(-360,360)/35, RotationY = MATHR(-360,360)/35, RotationZ = MATHR(-360,360)/35, Material = "Granite", Color = C3(.35,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, SizeBoomerang = 0, Boomerang = 50})
								elseif CHILD.Name ~= "HumanoidRootPart" then
									WACKYEFFECT2({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Granite", Color = C3(.75,0,0), SoundID = nil, SoundPitch = .8, SoundVolume = 4, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
									WACKYEFFECT2({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Granite", Color = C3(.5,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
									WACKYEFFECT2({Time = MATHR(10,30)*6, EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MATHR(-50,100)/1.5,MATHR(-50,100)/35,MATHR(-50,100)/35), MATHR(-50,100)/35, RotationX = MATHR(-50,100)/35, RotationY = MATHR(-50,100)/35, RotationZ = MATHR(-50,100)/35, Material = "Granite", Color = C3(.35,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 35})
								end
								if CHILD.Name == "Torso" or CHILD.Name == "UpperTorso" then
									WACKYEFFECT2({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Granite", Color = C3(.75,0,0), SoundID = 130113415, SoundPitch = MATHR(0.9,1.1), SoundVolume = 10, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
									WACKYEFFECT2({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Granite", Color = C3(.5,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
									WACKYEFFECT2({Time = 50, EffectType = "Box", Size = VT(0.2,0.2,0.2)*CHILD.Size.Magnitude * 3, Size2 = VT(5,5,5)*CHILD.Size.Magnitude, Transparency = 0.8, Transparency2 = 1, CFrame = CF(CHILD.Position), MoveToPos = CHILD.Position+VT(MATHR(-50,100)/35,MATHR(-50,100)/35,MATHR(-50,100)/35), MATHR(-50,100)/35, RotationX = MATHR(-50,100)/35, RotationY = MATHR(-50,100)/35, RotationZ = MATHR(-50,100)/35, Material = "Granite", Color = C3(.35,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 35})
								end
								CHILD:Destroy()
								CHILD:Destroy()
								CHILD:Destroy()
							end
						end
						HUM.Health = 0
					end
					MODEL:remove()
					MODEL:remove()
					MODEL:remove()
					MODEL:remove()
					MODEL:remove()
					MODEL:Destroy()
					MODEL:Destroy()
					MODEL:Destroy()
					MODEL:Destroy()
					MODEL:Destroy()
				end
				function MeshPartKill(MESHPART)
					--[[WACKYEFFECT({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(MESHPART.Size.Z,MESHPART.Size.Y,MESHPART.Size.Z)/3, Size2 = (VT(MESHPART.Size.Z,MESHPART.Size.Y,MESHPART.Size.Z)/3)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = MESHPART.CFrame, MoveToPos = MESHPART.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = .8, SoundVolume = 4, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(MESHPART.Size.Z,MESHPART.Size.Y,MESHPART.Size.Z)/2, Size2 = (VT(MESHPART.Size.Z,MESHPART.Size.Y,MESHPART.Size.Z)/2)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = MESHPART.CFrame, MoveToPos = MESHPART.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT({Time = MATHR(10,30)*6, EffectType = "Box", Size = MESHPART.Size, Size2 = MESHPART.Size, Transparency = MESHPART.Transparency, Transparency2 = 1, CFrame = MESHPART.CFrame, MoveToPos = MESHPART.Position+VT(MATHR(-50,100)/1.5,MATHR(-50,100)/35,MATHR(-50,100)/35), MATHR(-50,100)/35, RotationX = MATHR(-50,100)/35, RotationY = MATHR(-50,100)/35, RotationZ = MATHR(-50,100)/35, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 35})
					MESHPART:remove()
					MESHPART:remove()
					MESHPART:remove()
					MESHPART:remove()
					MESHPART:remove()
					MESHPART:Destroy()
					MESHPART:Destroy()
					MESHPART:Destroy()
					MESHPART:Destroy()
					MESHPART:Destroy()]]
				end
				function ApplyAoE(POSITION,RANGE)
					for index, CHILD in pairs(Funcs.Serv("Players"):GetChildren()) do
						CHILD = CHILD.Character
						if CHILD ~= nil and CHILD.ClassName == "Model" and CHILD ~= Character and CHILD ~= MainCharacter and CHILD ~= ReanimCharacter then
							local HUM = CHILD:FindFirstChildOfClass("Humanoid")
							if HUM then
								local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
								if TORSO then
									if (TORSO.Position - POSITION).Magnitude <= RANGE then
										Kill(CHILD)
									end
								end
							end
						end
					end
				end
				function ApplyAoEW(POSITION,RANGE)
					for index, CHILD in pairs(Funcs.Serv("Workspace"):GetDescendants()) do
						if CHILD.ClassName == "Model" and CHILD ~= Character then
							local HUM = CHILD:FindFirstChildOfClass("Humanoid")
							if HUM then
								local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
								if TORSO then
									if (TORSO.Position - POSITION).Magnitude <= RANGE then
										Kill(CHILD)
									end
								end
							end
						end
					end
				end

				--//=================================				--||      ANTI-DEATH CREATION
				--=================================//

				function antideath()
				game:GetService("RunService").RenderStepped:Wait()
					Head.Parent = Character
					Torso.Parent = Character
					RightArm.Parent = Character
					LeftArm.Parent = Character
					LeftLeg.Parent = Character
					RightLeg.Parent = Character
					Head.Transparency = 0
					Torso.Transparency = 0
					RightArm.Transparency = 0
					LeftArm.Transparency = 0
					LeftLeg.Transparency = 0
					RightLeg.Transparency = 0
					RootPart.Transparency = 1
					Head.Locked = true
					Torso.Locked = true
					RightArm.Locked = true
					LeftArm.Locked = true
					LeftLeg.Locked = true
					RightLeg.Locked = true
					Shield.Locked = true
					Humanoid.Parent = Character
				end

				local Regen = {}
				delay(1,function()
					local Descendants = Character:GetDescendants()
					for i = 1,#Descendants do
						local E = Descendants[i]
						if E:IsA("BasePart") and not E:IsDescendantOf(Effects) then
							E.CustomPhysicalProperties = PhysicalProperties.new(Enum.Material.Wood)
							table.insert(Regen,{E,E.Parent,E.Color,E.Size,E.Material})
						end
						if E:IsA("JointInstance") then
							table.insert(Regen,{E,E.Parent,nil,nil,nil})
						end
					end
				end)

				local BODY = {}

				for e = 1, #BODY do
					if BODY[e] ~= nil then
						local STUFF = BODY[e]
						local PART = STUFF[1]
						local PARENT = STUFF[2]
						local MATERIAL = STUFF[3]
						local COLOR = STUFF[4]
						local TRANSPARENCY = STUFF[5]
						if PART.ClassName == "Part" and PART ~= RootPart then
							PART.Material = MATERIAL
							PART.Color = COLOR
							PART.Transparency = TRANSPARENCY
						end
						PART.AncestryChanged:Connect(function()
game:GetService("RunService").RenderStepped:Wait()
							PART.Parent = PARENT
						end)
					end
				end


				function Refit2()
				game:GetService("RunService").RenderStepped:Wait()
					Character.Parent = Funcs.Serv("Workspace")
					CreationFolder.Parent = Character
					for e = 1, #BODY do
						if BODY[e] ~= nil then
							local STUFF = BODY[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							--local SIZE = STUFF[6]
							local NAME = STUFF[7]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Transparency = TRANSPARENCY
								PART.Name = NAME
							end
							if PART.Parent ~= PARENT then
								if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
									Humanoid:remove()
								end
								PART.Parent = PARENT
								if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
									Humanoid = IT("Humanoid",Character)
								end
							end
						end
					end
				end

				local BODY2 = {}
				for e = 1, #BODY2 do
					if BODY2[e] ~= nil then
						do
							local STUFF = BODY2[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Color = COLOR
								PART.Transparency = TRANSPARENCY
							end
							PART.AncestryChanged:Connect(function()
							game:GetService("RunService").RenderStepped:Wait()
								PART.Parent = PARENT
							end)
						end
					end
				end
				function Refit3()
				game:GetService("RunService").RenderStepped:Wait()
					Character.Parent = Funcs.Serv("Workspace")
					for e = 1, #BODY2 do
						if BODY2[e] ~= nil then
							local STUFF = BODY2[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART:IsA("BasePart") and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Color = COLOR
								PART.Transparency = TRANSPARENCY
							end
							if PART.Parent ~= PARENT then
								Humanoid:remove()
								PART.Parent = PARENT
							end
						end
					end
				end

				local BODY3 = {}
				for e = 1, #BODY3 do
					if BODY3[e] ~= nil then
						local STUFF = BODY3[e]
						local PART = STUFF[1]
						local PARENT = STUFF[2]
						local MATERIAL = STUFF[3]
						local COLOR = STUFF[4]
						local TRANSPARENCY = STUFF[5]
						if PART.ClassName == "Part" and PART ~= RootPart then
							PART.Material = MATERIAL
							PART.Color = COLOR
							PART.Transparency = TRANSPARENCY
						end
						PART.AncestryChanged:Connect(function()
						game:GetService("RunService").RenderStepped:Wait()
							PART.Parent = PARENT
						end)
					end
				end
				function Refit4()
				game:GetService("RunService").RenderStepped:Wait()
					if Character.Parent ~= Funcs.Serv("Workspace") then
						Character.Parent = Funcs.Serv("Workspace")
					end
					for e = 1, #BODY3 do
						if BODY3[e] ~= nil then
							local STUFF = BODY3[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART:IsA("BasePart") and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Color = COLOR
								PART.Transparency = TRANSPARENCY
							end
							if PART.Parent ~= PARENT then
								Humanoid:remove()
								Humanoid = IT("Humanoid",Character)
							end
						end
					end
				end

				local BODY4 = {}
				for e = 1, #BODY4 do
					if BODY4[e] ~= nil then
						local STUFF = BODY4[e]
						local PART = STUFF[1]
						local PARENT = STUFF[2]
						local MATERIAL = STUFF[3]
						local COLOR = STUFF[4]
						local TRANSPARENCY = STUFF[5]
						if PART.ClassName == "Part" and PART ~= RootPart then
							PART.Transparency = TRANSPARENCY
						end
						PART.AncestryChanged:Connect(function()
						game:GetService("RunService").RenderStepped:Wait()
							PART.Parent = PARENT
						end)
					end
				end
				function Refit5()
				game:GetService("RunService").RenderStepped:Wait()
					Character.Parent = Funcs.Serv("Workspace")
					for e = 1, #BODY4 do
						if BODY4[e] ~= nil then
							local STUFF = BODY4[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART:IsA("BasePart") and PART ~= RootPart then
								PART.Transparency = TRANSPARENCY
							end
							if PART.Parent ~= PARENT then
								Humanoid:remove()
								PART.Parent = PARENT
								Humanoid = IT("Humanoid",Character)

							end
						end
					end
				end

				local BODY5 = {}
				local EXTRATRANS = 0

				function Refit6()
				game:GetService("RunService").RenderStepped:Wait()
					Character.Parent = Funcs.Serv("Workspace")
					for e = 1, #BODY5 do
						if BODY5[e] ~= nil then
							local STUFF = BODY5[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART:IsA("BasePart") and PART ~= RootPart then
								PART.Transparency = TRANSPARENCY+EXTRATRANS
							end
							if PART.Parent ~= PARENT then
								Humanoid:remove()
								PART.Parent = PARENT
								Humanoid = IT("Humanoid",Character)
							end
						end
					end
				end

				local BODY6 = {}

				function Refit7()
				game:GetService("RunService").RenderStepped:Wait()
					Character.Parent = Funcs.Serv("Workspace")
					for e = 1, #BODY6 do
						if BODY6[e] ~= nil then
							local STUFF = BODY6[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							local NAME = STUFF[7]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Transparency = TRANSPARENCY
								PART.Name = NAME
							end
							if PART.Parent ~= PARENT then
								if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
									Humanoid:remove()
								end
								PART.Parent = PARENT
								if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
									Humanoid = IT("Humanoid", Character)
								end
							end
						end
					end
				end
				local BODY7 = {}

				for e = 1, #BODY7 do
					if BODY7[e] ~= nil then
						local STUFF = BODY7[e]
						local PART = STUFF[1]
						local PARENT = STUFF[2]
						local MATERIAL = STUFF[3]
						local COLOR = STUFF[4]
						local TRANSPARENCY = STUFF[5]
						--local SIZE = STUFF[6]
						local NAME = STUFF[7]
						if PART.ClassName == "Part" and PART ~= RootPart then
							PART.Material = MATERIAL
							PART.Color = COLOR
							PART.Transparency = TRANSPARENCY
						end
						PART.AncestryChanged:Connect(function()
						game:GetService("RunService").RenderStepped:Wait()
							PART.Parent = PARENT
						end)
					end
				end

				function Refit8()
				game:GetService("RunService").RenderStepped:Wait()
					Character.Parent = Funcs.Serv("Workspace")
					for e = 1, #BODY7 do
						if BODY7[e] ~= nil then
							local STUFF = BODY7[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							--local SIZE = STUFF[6]
							local NAME = STUFF[7]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Transparency = TRANSPARENCY
								PART.Name = NAME
							end
							if PART.Parent ~= PARENT then
								Humanoid:remove()
								PART.Parent = PARENT
								Humanoid = IT("Humanoid",Character)
							end
						end
					end
				end
				local BODY8 = {}

				for e = 1, #BODY8 do
					if BODY8[e] ~= nil then
						local STUFF = BODY8[e]
						local PART = STUFF[1]
						local PARENT = STUFF[2]
						local MATERIAL = STUFF[3]
						local COLOR = STUFF[4]
						local TRANSPARENCY = STUFF[5]
						if PART.ClassName == "Part" and PART ~= RootPart then
							PART.Material = MATERIAL
							PART.Color = COLOR
							PART.Transparency = TRANSPARENCY
						end
						PART.AncestryChanged:Connect(function()
						game:GetService("RunService").RenderStepped:Wait()
							PART.Parent = PARENT
						end)
					end
				end

				function Refit9()
				game:GetService("RunService").RenderStepped:Wait()
					Character.Parent = Funcs.Serv("Workspace")
					for e = 1, #BODY8 do
						if BODY8[e] ~= nil then
							local STUFF = BODY8[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Color = COLOR
								PART.Transparency = TRANSPARENCY
							end
							if PART.Parent ~= PARENT then
								Humanoid:remove()
								PART.Parent = PARENT
								Humanoid = IT("Humanoid",Character)
							end
						end
					end
				end
				local EXTRATRANS = 0
				local BODY9 = {}
				for e = 1, #BODY9 do
					if BODY9[e] ~= nil then
						local STUFF = BODY9[e]
						local PART = STUFF[1]
						local PARENT = STUFF[2]
						local MATERIAL = STUFF[3]
						local COLOR = STUFF[4]
						local TRANSPARENCY = STUFF[5]
						if PART.ClassName == "Part" and PART ~= RootPart then
							PART.Material = MATERIAL
							PART.Color = COLOR
							PART.Transparency = TRANSPARENCY
						end
						PART.AncestryChanged:Connect(function()
						game:GetService("RunService").RenderStepped:Wait()
							PART.Parent = PARENT
						end)
					end
				end

				function Refit10()
				game:GetService("RunService").RenderStepped:Wait()
					Character.Parent = Funcs.Serv("Workspace")
					for e = 1, #BODY9 do
						if BODY9[e] ~= nil then
							local STUFF = BODY9[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART:IsA("BasePart") and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Color = COLOR
								PART.Transparency = TRANSPARENCY+EXTRATRANS
							end
							if PART.Parent ~= PARENT then
								Humanoid:remove()
								PART.Parent = PARENT
								Humanoid = IT("Humanoid",Character)
							end
						end
					end
				end

				local BODY10 = {}
				function Refit11()
				game:GetService("RunService").RenderStepped:Wait()
					Character.Parent = Funcs.Serv("Workspace")
					for e = 1, #BODY10 do	
						if BODY10[e] ~= nil then
							local STUFF = BODY10[e]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local TRANSPARENCY = STUFF[5]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Color = COLOR
								PART.Transparency = TRANSPARENCY
							end
							if PART.Parent ~= PARENT then
								Humanoid:remove()
								PART.Parent = PARENT
								Humanoid = IT("Humanoid",Character)
							end
						end
					end
				end

				local BODY11 = {}

				function Refit12()
				game:GetService("RunService").RenderStepped:Wait()
					Character.Parent = Funcs.Serv("Workspace")
					for e = 1, #BODY11 do
						if BODY11[e] ~= nil then
							local STUFF = BODY11[e]
							local PART = STUFF[1]
							local PARENT = Character:FindFirstChild("Safety") or STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							local NAME = STUFF[7]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Transparency = TRANSPARENCY
								PART.Name = NAME
							end
							if PART.Parent ~= PARENT then
								if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
									Humanoid:remove()
								end
								PART.Parent = PARENT
								if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
								end
							end
						end
					end
				end

				local BODY12 = {}
				function Refit13()
				game:GetService("RunService").RenderStepped:Wait()
					Character.Parent = Funcs.Serv("Workspace")
					for e = 1, #BODY12 do
						if BODY12[e] ~= nil then
							local STUFF = BODY12[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							local SIZE = STUFF[6]
							local NAME = STUFF[7]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Transparency = TRANSPARENCY
								PART.Name = NAME
							end
							if PART.Parent ~= PARENT then
								Humanoid:remove()
								PART.Parent = PARENT
								Humanoid = IT("Humanoid",Character)
							end
							Humanoid.MaxHealth = "inf"
							Humanoid.Health = "Inf"
						end
					end
				end

--[[
				Humanoid.Died:Connect(Refit)
				Humanoid.Died:connect(Refit2)
				Humanoid.Died:connect(Refit3)
				Humanoid.Died:connect(Refit4)
				Humanoid.Died:connect(Refit5)
				Humanoid.Died:connect(Refit6)
				Humanoid.Died:connect(Refit7)
				Humanoid.Died:connect(Refit8)
				Humanoid.Died:connect(Refit9)
				Humanoid.Died:connect(Refit10)
				Humanoid.Died:connect(Refit11)
				Humanoid.Died:connect(Refit12)
				Humanoid.Died:connect(Refit13)]]
				Humanoid.HealthChanged:Connect(function()
				game:GetService("RunService").RenderStepped:Wait()
					if Humanoid.Health <= 1 then
						Humanoid.Health = math.huge
						--[[Refit()
						Refit2()
						Refit3()
						Refit4()
						Refit5()
						Refit6()
						Refit7()
						Refit8()
						Refit9()
						Refit10()
						Refit11()
						Refit12()
						Refit13()]]
					end
				end)

				for _, c in pairs(Character:GetChildren()) do
					if c and c.Parent then
						if c.ClassName == "Accessory" then
							local ACCESSORY = c
							local HANDLE = c.Handle
							HANDLE.Parent = Character
							if c then
								if HANDLE:FindFirstChild("HatAttachment") or HANDLE:FindFirstChild("FaceFrontAttachment") or HANDLE:FindFirstChild("HairAttachment") then
									local WLD = weldBetween(Head,HANDLE)
								else
									local WLD = weldBetween(Torso,HANDLE)
								end
							end
							HANDLE.Name = ACCESSORY.Name
							ACCESSORY:remove()
						end
					end
				end
				local BODY = {}
				for _, c in pairs(Character:GetDescendants()) do
					if c:IsA("BasePart") and c.Name ~= "Handle" and not c:IsDescendantOf(Effects) then
						if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
							c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
						end
						table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency,c.Size,c.Name})
					elseif c:IsA("JointInstance") then
						table.insert(BODY,{c,c.Parent,nil,nil,nil,nil,nil})
					end
				end
				for e = 1, #BODY do
					if BODY[e] ~= nil then
						do
							local STUFF = BODY[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Transparency = TRANSPARENCY
							end
							PART.AncestryChanged:Connect(function()
							game:GetService("RunService").RenderStepped:Wait()
								PART.Parent = PARENT
							end)
						end
					end
				end
				function refit()
					coroutine.resume(coroutine.create(function()
						wait()
						Humanoid.Died:connect(refit)
					end))
					Character.Parent = Funcs.Serv("Workspace")
					for e = 1, #BODY do
						if BODY[e] ~= nil then
							local STUFF = BODY[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							local SIZE = STUFF[6]
							local NAME = STUFF[7]
							if PART.ClassName == "Part" and PART:IsA("BasePart") and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Transparency = TRANSPARENCY
								PART.Name = NAME
							end
							if PART.Parent ~= PARENT then
								if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
									Humanoid:remove()
								end
								PART.Parent = PARENT
								if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
									Humanoid = Instance.new("Humanoid",Character)
								end
							end
						end
					end
				end
				local Regen = {}
				for e = 1, #Regen do
					if Regen[e] ~= nil then
						local STUFF = Regen[e]
						local PART = STUFF[1]
						local PARENT = STUFF[2]
						local MATERIAL = STUFF[3]
						local COLOR = STUFF[4]
						local TRANSPARENCY = STUFF[5]
						if PART.ClassName == "Part" and PART ~= BODY.RootPart then
							PART.Material = MATERIAL
							PART.Color = COLOR
							PART.Transparency = TRANSPARENCY
						end
						PART.AncestryChanged:Connect(function()
						game:GetService("RunService").RenderStepped:Wait()
							PART.Parent = PARENT
						end)
					end
				end
				function Refit()
				game:GetService("RunService").RenderStepped:Wait()
					coroutine.resume(coroutine.create(function()
						wait()
						Humanoid.Died:connect(Refit)	
					end))
					for i = 1,#Regen do
						local E = Regen[i]
						local PART = E[1]
						local PARENT = E[2]
						local COLOR = E[3]
						local SIZE = E[4]
						local MATERIAL = E[5]
						if PART:IsA("BasePart") and PART.Parent ~= PARENT then
							PART.Color = COLOR
							PART.Size = SIZE
							PART.Material = MATERIAL
						end
						if PART.Parent ~= PARENT then
							Humanoid.Parent = nil
							PART.Parent = PARENT
							Humanoid.Parent = Character
						end
					end
					Humanoid.Parent = Character
				end
				function Parents()
					RootJoint.Parent = RootPart
					Neck.Parent = Torso
					RightShoulder.Parent = Torso
					LeftShoulder.Parent = Torso
					RightHip.Parent = Torso
					LeftHip.Parent = Torso
					RootPart.Parent = Character
					LeftArm.Parent = Character
					RightArm.Parent = Character
					RightLeg.Parent = Character
					LeftLeg.Parent = Character
					Torso.Parent = Character
					Head.Parent = Character
				end
				local States = {
					"FallingDown";
					"PlatformStanding";
					"Physics";
					"Swimming";
					"Dead";
					"Ragdoll";
					"Seated";
				}
				for i,v in pairs(States) do
					Humanoid:SetStateEnabled(v,false)
				end

				--//=================================				--||	ATTACK FUNCTIONS AND STUFF
				--=================================//

				function BladeCombo()
					ATTACK = true
					Rooted = false
					local savespeed = Speed
					Speed = 5
					EQUIPPED = true
					local HIT2 = function()
						local HITS2 = {}
						local TOUCH2 = LeftArm.Touched:Connect(function(hit)
						game:GetService("RunService").RenderStepped:Wait()
							if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent ~= Character then
								local HUM = hit.Parent:FindFirstChildOfClass("Humanoid")
								local TORSO = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
								if TORSO and HUM.Health > 0 then
									local PASS = true
									for i = 1, #HITS2 do
										if HITS2[i] == hit.Parent then
											PASS = false
										end
									end
									table.insert(HITS2,hit.Parent)
									if PASS == true then
										Kill(HUM.Parent)
									end
								end
							end
						end)
						return TOUCH2
					end
					local HIT = function()
						local HITS = {}
						local TOUCH = Blade.REDB.Touched:Connect(function(hit)
						game:GetService("RunService").RenderStepped:Wait()
							if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent ~= Character then
								local HUM = hit.Parent:FindFirstChildOfClass("Humanoid")
								local TORSO = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
								if TORSO and HUM.Health > 0 then
									local PASS = true
									for i = 1, #HITS do
										if HITS[i] == hit.Parent then
											PASS = false
										end
									end
									table.insert(HITS,hit.Parent)
									if PASS == true then
										Kill(HUM.Parent)
									end
								end
							end
						end)
						return TOUCH
					end
					if COMBO == 1 then
						Blade.REDB.Trail.Enabled = true
						for i=0, 0.35, 0.1 / 3 do
							Swait()
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(5)), 3 / 3)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)), 1 / 3)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 1 / 3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / 3)  
							if ANIM=="Walk" then
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / 3)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / 3)
							else
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
							end
						end
						CreateSound(1489705211,RightArm,MATHR(7,8),MATHR(8,13)/12,false)
						local TOUCHED = HIT()
						for i=0, 0.5, 0.1 / 3 do
							Swait()
							WACKYEFFECT({EffectType = "Box", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-35)), 3 / 3)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / 3)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.8, 0.5, -0.7) * ANGLES(RAD(0), RAD(0), RAD(-90)) * ANGLES(RAD(15), RAD(180), RAD(0)) * RIGHTSHOULDERC0, 0.6 / 3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / 3)
							if ANIM=="Walk" then
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / 3)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / 3)
							else
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
							end
						end
						TOUCHED:Disconnect()
						COMBO = 2
						Blade.REDB.Trail.Enabled = false
					elseif COMBO == 2 then
						for i=0, 0.35, 0.1 / 3 do
							Swait()
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(5)), 3 / 3)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(15)), 1 / 3)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 1 / 3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / 3)
							if ANIM=="Walk" then
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / 3)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / 3)
							else
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
							end
						end
						CreateSound(1489705211,LeftArm,MATHR(7,8),MATHR(8,13)/12,false)
						local TOUCHED = HIT2()
						for i=0, 0.5, 0.1 / 3 do
							Swait()
							WACKYEFFECT({EffectType = "Box", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(45)), 3 / 3)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-55)), 1 / 3)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.6 / 3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-105)) * ANGLES(RAD(90), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / 3)
							if ANIM=="Walk" then
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / 3)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / 3)
							else
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
							end
						end
						TOUCHED:Disconnect()
						COMBO = 1
					end
					coroutine.resume(coroutine.create(function()
						for i = 1, 50 do
							Swait()
							if ATTACK == true then
								break
							end
						end
						if ATTACK == false then
							COMBO = 1
						end
					end))
					Speed = savespeed
					ATTACK = false
					Rooted = false
					EQUIPPED = false
				end
				function Lightning(Part0,Part1,Timess,Offset,Color,Timer,sSize,eSize,Trans,Boomer,sBoomer,Trans2)
					if true then return end
					local magz = (Part0 - Part1).Magnitude
					local Times = math.floor(math.clamp(magz/10,1,20))
					local curpos = Part0
					local trz = {
						-Offset,
						Offset
					}
					for i = 1,Times do
						local li = Instance.new("Part",Effects)
						li.Name = randomstring()
						li.TopSurface = 0
						li.Material = "Neon"
						li.BottomSurface = 0
						li.Anchored = true
						li.Locked = true
						li.Transparency = 0
						li.Color = Color
						li.formFactor = "Custom"
						li.CanCollide = false
						li.Size = Vector3.new(0.1,0.1,magz/Times)
						local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
						local trolpos = CFrame.new(curpos,Part1) * CFrame.new(0,0,magz/Times).p + Offzet
						if Times == i then
							local magz2 = (curpos - Part1).Magnitude
							li.Size = Vector3.new(0.1,0.1,magz2)
							li.CFrame = CFrame.new(curpos,Part1) * CFrame.new(0,0,-magz2/2)
						else
							li.CFrame = CFrame.new(curpos,trolpos) * CFrame.new(0,0,magz/Times/2)
						end
						curpos = li.CFrame * CFrame.new(0,0,magz/Times/2).p
						li:Destroy()
						Effect2({Time = Timer,EffectType = "Box",Size = Vector3.new(sSize,sSize,li.Size.Z),Size2 = Vector3.new(eSize,eSize,li.Size.Z),Transparency = Trans,Transparency2 = Trans2 or 1,CFrame = li.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = li.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = Boomer,Boomerang = 0,SizeBoomerang = sBoomer})
					end
				end
				--local stopeverything = true

				function AttackGyro()
					local GYRO = Instance.new("BodyGyro",RootPart)
					GYRO.D = 25
					GYRO.P = 20000
					GYRO.MaxTorque = Vector3.new(0,4000000,0)
					GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
					coroutine.resume(coroutine.create(function()
						repeat if stopeverything then wait(math.huge) end
							Swait()
							GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
						until ATTACK == false
						GYRO:Destroy()
					end))
				end
				function SingularityBeam()
					ATTACK = true
					Speed = 0
					AttackGyro()
					for i = 0,0.5,0.05 do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),0.7/3)
						Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1/3)
						RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,0.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1/3)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.25,0.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1/3)
						RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
						LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
					end
					local HoleDist = (cannon.Part.Position - cannon.Part.Position).Magnitude
					local chargebeam = CreatePart(3,Effects,"Neon",0,0,COLORSHIFT,"Charge Beam",Vector3.new(.25,HoleDist,.25),false)
					MakeForm(chargebeam,"Cyl")
					chargebeam.CFrame = CFrame.new(cannon.Part.Position,cannon.Part.Position) * CFrame.new(0,0,-HoleDist/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
					local chargeweld = weldBetween(cannon.Part,chargebeam)
					local chargeball = CreatePart(3,Effects,"Neon",0,0,COLORSHIFT,"Charge Ball",Vector3.new(.5,.5,.5),false)
					chargeball.Shape = "Ball"
					chargeball.CFrame = cannon.Part.CFrame
					weldBetween(cannon.Part,chargeball)
					CreateSound(342793847,cannon.Part,10,1,false)
					local bigball = Funcs.Serv("TweenService"):Create(chargeball,TweenInfo.new(3.86,Enum.EasingStyle.Linear),{Size = Vector3.new(2.5,2.5,2.5)})
					bigball:Play()
					bigball.Completed:Wait()
					chargebeam:Destroy()
					local KillDist = (cannon.Part.Position - Mouse.Hit.p).Magnitude
					coroutine.resume(coroutine.create(function()
						repeat if stopeverything then wait(math.huge) end KillDist = (cannon.Part.Position - Mouse.Hit.p).Magnitude Swait() until ATTACK == false
					end))
					Funcs.Serv("Lighting").ExposureCompensation = 100
					for _, v in pairs(Funcs.Serv("Workspace"):GetDescendants()) do
						if v:IsA("Model") and v:FindFirstChildOfClass("Humanoid") and v ~= Character then
							Kill(v)
						elseif v:IsA("MeshPart") or v:IsA("UnionOperation") and v ~= cannon then
							if v ~= cannon then
								v.Locked = false
								MeshPartKill(v)
							end
						end
					end
					CreateSound(138677306,cannon.Part,10,1,false)
					CreateSound(415700134,cannon.Part,10,1,false)
					Swait(150)
					CreateSound(3264923,cannon.Part,10,1,false)
					Swait(30)
					chargeball:Destroy()
					Speed = 30
					ATTACK = false
					Funcs.Serv("Lighting").ExposureCompensation = 0
				end
				function Ka_Boom()
					ATTACK = true
					Speed = 0
					local die = CreateSound(1566051529,RootPart,3,1)
					die.EmitterSize = 100
					Swait(5)
					for i = 1,3 do
						for i = 0,1.5,0.1 do
							Swait()
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),0.7/3)
							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
						end
						Effect2({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = cannon.Part.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 642890855,SoundPitch = 0.45,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						Effect2({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = cannon.Part.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						local skypos = cannon.Part.CFrame * CFrame.new(-400,0,0)
						local DISTANCE = (cannon.Part.Position - skypos.p).Magnitude
						local killbeam = CreatePart(3,Effects,"Neon",0,0,COLORSHIFT,"Kill Beam",Vector3.new(1,DISTANCE,1))
						killbeam.CFrame = CFrame.new(cannon.Part.Position,skypos.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
						MakeForm(killbeam,"Cyl")
						coroutine.resume(coroutine.create(function()
							for i = 1,25 do
								Swait()
								killbeam.Transparency = i/25
							end
							killbeam:Destroy()
						end))
						Lightning(cannon.Part.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
						Lightning(cannon.Part.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
						Lightning(cannon.Part.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
						Lightning(cannon.Part.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
						Lightning(cannon.Part.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
						for i = 0,2 do
							Effect2({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = cannon.Part.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
							Effect2({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = cannon.Part.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
						end
						Effect2({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 192410089,SoundPitch = .55,SoundVolume = 8,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						Effect2({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						for i = 0,2 do
							Effect2({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
							Effect2({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
						end
						for i = 1,42 do
							Swait()
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)

							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
						end
					end
					for i = 1,15 do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)

						RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
						RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
						LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
					end
					local BEAM = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
					local BEAM2 = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
					MakeForm(BEAM,"Ball")
					MakeForm(BEAM2,"Ball")
					BEAM.CFrame = CFrame.new(RootPart.Position)
					BEAM2.CFrame = CFrame.new(RootPart.Position)
					local boooom = CreateSound(415700134,RootPart,10,1,false)
					boooom.EmitterSize = 100
					for i=1,140 do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)

						RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
						RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
						LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
						BEAM.Size = BEAM.Size + Vector3.new(0.7,8,0.7)
						BEAM2.Size = BEAM2.Size + Vector3.new(2,2,2)
						BEAM.Color = COLORSHIFT
						BEAM2.Color = COLORSHIFT
						BEAM.CFrame = CFrame.new(RootPart.Position)
						BEAM2.CFrame = CFrame.new(RootPart.Position)
						WACKYEFFECT({TIME = 5+i,EffectType = "Swirl",Size = BEAM2.Size*1.15,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = 0.8,Transparency2 = 1,CFrame = BEAM.CFrame * CFrame.Angles(math.rad(0),math.rad(i*5),math.rad(0)),MoveToPos = nil,RotationX = 0,RotationY = i/8,RotationZ = 0,Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
					end
					mdmg(RootPart.Position,BEAM2.Size.Y/2)
					Effect2({TIME = 75,EffectType = "Sphere",Size = BEAM.Size,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = 0,Transparency2 = 0,CFrame = BEAM.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
					Effect2({TIME = 75,EffectType = "Sphere",Size = BEAM2.Size,Size2 = Vector3.new(0,0,0),Transparency = 0,Transparency2 = 0.6,CFrame = BEAM2.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
					for i,v in pairs(Effects:GetChildren()) do
						v.Color = COLORSHIFT
						v:GetPropertyChangedSignal("Color"):Connect(function()
						game:GetService("RunService").RenderStepped:Wait()
							v.Color = COLORSHIFT
						end)
					end
					BEAM2:Destroy()
					BEAM:Destroy()
					ATTACK = false
					Speed = 30
				end
				function Shot1()
					local Hole = Gunclone:FindFirstChild("Hole")
					ATTACK = true
					Rooted = false
					for i=0, 0.01, 0.1 / Animation_Speed do
						Swait()
						turnto(Mouse.Hit.p)
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					end
					repeat
						for i=0, 0.01, 0.1 / Animation_Speed do
							Swait()
							turnto(Mouse.Hit.p)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						end
						local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
						SpawnTrail(Hole.Position,POS)
						CreateSound(904440937, Character, 10, 1, false)
						if HIT ~= nil then
							if HIT.Parent:FindFirstChildOfClass("Humanoid") then
								Kill(HIT.Parent)
							end
						end
						for i=0, 0.01, 0.1 / Animation_Speed do
							Swait()
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						end
					until KEYHOLD == false
					ATTACK = false
					Rooted = false
				end
				function Shot2()
					local Hole = Gunclone:FindFirstChild("Hole")
					ATTACK = true
					Rooted = false
					for i=0, 0.01, 0.1 / Animation_Speed do
						Swait()
						turnto(Mouse.Hit.p)
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					end
					repeat
						for i=0, 0.01, 0.1 / Animation_Speed do
							Swait()
							turnto(Mouse.Hit.p)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						end
						local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
						SpawnTrail(Hole.Position,POS)
						CreateSound(904440937, Character, 10, 1, false)
						if HIT ~= nil then
							if HIT.Parent.ClassName == "Model" then
								Kill(HIT.Parent)
							end
						end
						for i=0, 0.01, 0.1 / Animation_Speed do
							Swait()
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						end
					until KEYHOLD == false
					ATTACK = false
					Rooted = false
				end
				function Warp()
					local POS = Mouse.Hit.p+VT(0,4,0)
					local ORI = RootPart.Orientation
					RootPart.CFrame = CF(POS)
					RootPart.Orientation = ORI
					RootJoint.Parent = RootPart    
					CreateSound("424195979",RootPart,7,2,false)
					ShakeCam(1,25)
					for i = 1,4.5,.15 do 
						SpecialSphere(VT(2,10,2)/6,35,CF(POS,RootPart.Position)*ANGLES(RAD(MATHR(-360,360)),RAD(MATHR(-360,360)),RAD(MATHR(-360,360)))*CF(0,MATHR(4,8),0),Color3.new(0,0,0),VT(0,0,0))	
						SpecialSphere(VT(2,10,2)/6,35,CF(POS,RootPart.Position)*ANGLES(RAD(MATHR(-360,360)),RAD(MATHR(-360,360)),RAD(MATHR(-360,360)))*CF(0,MATHR(4,8),0),Color3.new(0,0,0),VT(0,0,0))	
						WACKYEFFECT({Time=20,EffectType = "Sphere", Size = VT(4*i,65*(1-i/4.5),4*i)*SCALE, Size2 = VT(5*i,0,5*i)*SCALE, Transparency = 0, Transparency2 = 1, CFrame = CF(POS)*ANGLES(0,360*math.rad(i),0), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time=20,EffectType = "Sphere", Size = VT(4*i,65*(1-i/4.5),4*i)*SCALE, Size2 = VT(5*i,0,5*i)*SCALE, Transparency = 0, Transparency2 = 1, CFrame = CF(POS)*ANGLES(0,360*math.rad(i),0), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						ApplyAoE(POS,20)
					end
				end

				function Stomp()
					ATTACK = true
					Rooted = false
					PLAYANIMS = false
					Speed = 5
					for i=0, 1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 2 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.4*SIZE, -0.6*SIZE) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE /12), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
					end
					CreateSound(3923230963,Torso,10,1,false)
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(50,10,50)*MATHR(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MATHR(1,1.1), SoundVolume = 10})
					WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(50,50,50)*MATHR(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MATHR(1,1.1), SoundVolume = 10})
					WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0.01,1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MATHR(1,1.1), SoundVolume = 10})
					WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0.01,1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MATHR(1,1.1), SoundVolume = 10})
					WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0.01,1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MATHR(1,1.1), SoundVolume = 10})
					ApplyAoE(RootPart.Position,25)
					ShakeCam(3,25)
					for i=0, 1, 0.1 / Animation_Speed do
						Swait()
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 3 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-180), RAD(-5)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE /12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE /12), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE /12), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
					end
					Speed = 15
					PLAYANIMS = true
					ATTACK = false
					Rooted = false
					Humanoid.CameraOffset = VT(0,0,0)
				end

				function Slash()
					ATTACK = true
					Rooted = true
					PLAYANIMS = false
					local STOPPP = false
					MagicSphere(VT(0,0,0),15,RootPart.CFrame,"Really black",VT(2,2,2))
					coroutine.wrap(function()
						while wait() do
							WACKYEFFECT({Time = 15, EffectType = "Crystal", Size = VT(1,5,1), Size2 = VT(1,25,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,0,0)*ANGLES(RAD(MATHR(0,360)),RAD(MATHR(0,360)),RAD(MATHR(0,360))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Glass", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							if STOPPP == true then
								break
							end
						end
					end)()
					for i=0, 1, 0.1 / Animation_Speed do
						Swait()
						CreateRing(VT(0,0,0),false,0,5,CF(RootPart.Position-VT(0,3,0))*ANGLES(RAD(90),RAD(0),RAD(0)),"Really black",VT(1,1,0))
						turnto(Mouse.Hit.p)
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, -0.5*SIZE) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(90), RAD(-45), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.2*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.5*SIZE, -0.5*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(-45), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					end
					for i=0,0.1, 0.1 / Animation_Speed do
						Swait()
						turnto(Mouse.Hit.p)
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(90), RAD(-45), RAD(0)) * RIGHTSHOULDERC0, 0.5)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(90), RAD(0), RAD(75)) * LEFTSHOULDERC0, 0.5)
						RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
					end
					local SOUND = CreateSound("rbxasset://sounds/swordlunge.wav", Torso, 5, 0.6)
					SOUND.SoundId = "rbxasset://sounds/swordlunge.wav"
					CreateSound(62339698, Torso, 10, 0.4)
					ApplyAoE(RootPart.Position,55)
					ShakeCam(3,25)
					WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(5,5,5), Size2 = VT(100,100,100)*MATHR(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MATHR(1,1.1), SoundVolume = 10})
					WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MATHR(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MATHR(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MATHR(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					STOPPP = true
					for i=0, 1, 0.1 / Animation_Speed do
						Swait()
						turnto(Mouse.Hit.p)
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(90), RAD(0), RAD(-75)) * RIGHTSHOULDERC0, 0.5)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(90), RAD(0), RAD(75)) * LEFTSHOULDERC0, 0.5)
						RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
					end
					PLAYANIMS = true
					ATTACK = false
					Rooted = false
				end



				function Grab()
					local TARGET = Mouse.Target
					if TARGET ~= nil and TARGET.Parent:FindFirstChildOfClass("Humanoid") then
						do
							local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
							local ROOT = GetRoot(HUM.Parent, true)
							local FOE = ROOT.Parent
							local HED = FOE:FindFirstChild("Head")
							local TORS = FOE:FindFirstChild("Torso") or FOE:FindFirstChild("UpperTorso")
							Rooted = true
							turnto(TORS.Position)
							if ROOT and HUM.Health > 0 then   
								ATTACK = true	
								coroutine.resume(coroutine.create(function()
									repeat
										Swait()
										WACKYEFFECT2({
											Time = 12,
											EffectType = "Sphere",
											Size = VT(5, 5, 5)/10,
											Size2 = VT(0, 0, 250)/10,
											Transparency = 0,
											Transparency2 = 1,
											CFrame = CF(ROOT.Position) * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360))),
											MoveToPos = nil,
											RotationX = 0,
											RotationY = 0,
											RotationZ = 0,
											Material = "Neon",
											Color = C3(1,0,0),
											SoundID = 220834019,
											SoundPitch = 2,
											SoundVolume = .5,
											UseBoomerangMath = true,
											Boomerang = 50,
											SizeBoomerang = 100
										})
										WACKYEFFECT2({Time = 25, EffectType = "Box", Size = VT(2,0,2)/3, Size2 = VT(6,7.5,6)/3, Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame * ANGLES(RAD(MATHR(-360,360)), RAD(MATHR(-360,360)), RAD(MATHR(-360,360))), MoveToPos = RightArm.CFrame*CF(0,-1,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
										WACKYEFFECT2({
											Time = 15,
											EffectType = "Box",
											Size = TORS.Size * 1.2,
											Size2 = TORS.Size * 1.2,
											Transparency = 0.4,
											Transparency2 = 1,
											CFrame = TORS.CFrame,
											MoveToPos = nil,
											RotationX = 0,
											RotationY = 0,
											RotationZ = 0,
											Material = "Neon",
											Color = C3(1, 0, 0),
											SoundID = nil,
											SoundPitch = nil,
											SoundVolume = nil,
											UseBoomerangMath = false,
											Boomerang = 0,
											SizeBoomerang = 0
										})
										RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
										Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-2), RAD(-5), RAD(-85)) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(SINE / 13))), 1 / Animation_Speed)
										RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.65, 1, 0) * ANGLES(RAD(120), RAD(0), RAD(90))* RIGHTSHOULDERC0, 0.15 / 3)
										LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.85, .5, 0) * ANGLES(RAD(0),RAD(0),RAD(-50)) * ANGLES(RAD(0),RAD(0),RAD(MATHR(-10,40))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
										RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
										LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
									until ATTACK == false
								end))
								HUM.Health = .11111
								HUM:SetStateEnabled("Dead",true)
								local POS = ROOT.Position + VT(0, 15 * ROOT.Size.Z, 0)
								local grav = Instance.new("BodyPosition", ROOT)
								grav.D = 850
								grav.P = 4000
								grav.maxForce = VT(inf,inf,inf)
								grav.Position = POS
								wait(2)
								Kill(TARGET.Parent)
								ShakeCam(1,25)
								ATTACK = false
								Rooted = false
								Humanoid.CameraOffset = VT(0,0,0)
							end
						end	
					end
				end

				function Nightmare_Is_Coming()
					--ATTACK = true
                    --[[
					CreateSound("459523898",RootPart,10,1,false)
					CreateSound("459523898",RootPart,10,1,false)
					CreateSound("223103466",RootPart,3,.8,false)
					CreateSound("3651185476",RootPart,10,1,false)
					CreateSound("3651185476",RootPart,10,1,false)
					CreateSound("3651185476",RootPart,10,1,false)
					CreateSound("3651185476",RootPart,10,1,false)
					local SCOLOR = Instance.new("ColorCorrectionEffect")
					SCOLOR.Brightness = 0
					SCOLOR.Contrast = 0
					SCOLOR.Saturation = 0
					SCOLOR.Name = "SpookyColor"
					SCOLOR.Parent = game:GetService('Lighting')
					for i=0, 11.5, 0.1 / Animation_Speed2 do
						Swait()
						Humanoid.CameraOffset = VT(MATHR(-500,500)/2.5,MATHR(-50,50)/2.5,MATHR(-500,500)/2.5)/30
						ApplyAoE(RootPart.Position,1e9)
						WACKYEFFECT2({
							Time = 12,
							EffectType = "Sphere",
							Size = VT(5, 5, 5)/10 * 25,
							Size2 = VT(0, 0, 250)/10 * 25,
							Transparency = 0,
							Transparency2 = 1,
							CFrame = CF(RootPart.Position) * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360))),
							MoveToPos = nil,
							RotationX = 0,
							RotationY = 0,
							RotationZ = 0,
							Material = "Neon",
							Color = C3(0,0,0),
							SoundID = nil,
							SoundPitch = 1,
							SoundVolume = 6,
							UseBoomerangMath = true,
							Boomerang = 0,
							SizeBoomerang = 0
						})
						WACKYEFFECT2({
							Time = 75 - i * 4,
							EffectType = "Box",
							Size = VT(0, 0, 0),
							Size2 = VT(5, 5, 5) + VT(i, i, i) * 55,
							Transparency = 0,
							Transparency2 = 1,
							CFrame = CF(RootPart.Position) * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360))),
							MoveToPos = nil,
							RotationX = 360,
							RotationY = 360,
							RotationZ = 360,
							Material = "Neon",
							Color = C3(0,0,0),
							SoundID = nil,
							SoundPitch = MATHR(8, 20) / 10,
							SoundVolume = 2,
							UseBoomerangMath = true,
							Boomerang = 25,
							SizeBoomerang = 100
						})
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-7), RAD(-10), RAD(27 - 2.5 * SIN(SINE / 13))) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(SINE / 13))), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, .5, 0) * ANGLES(RAD(0), RAD(0), RAD(15))* RIGHTSHOULDERC0, 0.15 / 3)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.65, .5, 0) *ANGLES(RAD(0),RAD(0 + .5 * COS(SINE / 12)),RAD(MATHR(-40,10))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					end
					CreateSound("168513088",RootPart,10,1,false)
					CreateSound("168513088",RootPart,10,1,false)
					CreateSound("168513088",RootPart,10,1,false)
					CreateSound("168513088",RootPart,10,1,false)
					--
					CreateSound("231917744",RootPart,10,1,false)
					CreateSound("231917744",RootPart,10,1,false)
					CreateSound("231917744",RootPart,10,1,false)
					CreateSound("231917744",RootPart,10,1,false)
					Funcs.Serv("Lighting").Brightness = 0
					Funcs.Serv("Lighting").OutdoorAmbient = Color3.new(0,0,0)
					Funcs.Serv("Lighting").ClockTime = 0
					Humanoid.HipHeight = 10
					local BLUR = Instance.new("BlurEffect")
					BLUR.Size = 0
					BLUR.Name = "Wasted"
					BLUR.Parent = game:GetService('Lighting')
					for i = 1,350 do
						Swait()
						SCOLOR.Brightness = 5-((i/10)*5)
						SCOLOR.Contrast = 4-((i/10)*4)
						SCOLOR.Saturation = 3-((i/10)*3)
						BLUR.Size = (i/30)*10
						ApplyAoE(RootPart.Position,1e9999)
						WACKYEFFECT2({
							Time = 75 - i * 4,
							EffectType = "Box",
							Size = VT(0, 0, 0),
							Size2 = VT(5, 5, 5) + VT(i, i, i) * 100,
							Transparency = 0,
							Transparency2 = 1,
							CFrame = CF(RootPart.Position) * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360))),
							MoveToPos = nil,
							RotationX = 360,
							RotationY = 360,
							RotationZ = 360,
							Material = "Neon",
							Color = C3(0,0,0),
							SoundID = 231917744,
							SoundPitch = MATHR(8, 20) / 10,
							SoundVolume = 3,
							UseBoomerangMath = true,
							Boomerang = 25,
							SizeBoomerang = 100
						})
						WACKYEFFECT2({EffectType = "Wave", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MATHR(0,360)), RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Slate", Color = C3(0,0,0), SoundID = 528589382, SoundPitch = MATHR(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
						WACKYEFFECT2({EffectType = "Sphere", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MATHR(0,360)), RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = C3(1,0,0), SoundID = 528589382, SoundPitch = MATHR(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
						WACKYEFFECT2({EffectType = "Slash", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MATHR(0,360)), RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = C3(1,0,0), SoundID = 528589382, SoundPitch = MATHR(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-7), RAD(-10), RAD(27 - 2.5 * SIN(SINE / 13))) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(SINE / 13))), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, .5, 0) * ANGLES(RAD(0), RAD(0), RAD(15))* RIGHTSHOULDERC0, 0.15 / 3)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.65, .5, 0) *ANGLES(RAD(0),RAD(0 + .5 * COS(SINE / 12)),RAD(MATHR(-40,10))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					end
					local SCOLORE = game:GetService('Lighting'):FindFirstChild("SpookyColor")
					if SCOLORE then
						spawn(function()
							for i = 1,20 do
								SCOLORE.Brightness = 0
								SCOLORE.Contrast = 0
								SCOLORE.Saturation = 0
							end
							SCOLORE:Destroy()
							SCOLOR:Destroy()  
						end)
					end	
					local BLURA = game:GetService('Lighting'):FindFirstChild("Wasted")
					if BLURA then
						spawn(function()
							for i = 1, 20 do
								BLURA.Size = 5-((i/30)*5)
								Swait()
							end
							BLUR:Destroy()
							BLURA:Destroy() 
						end)
					end
					Humanoid.HipHeight = 0
					Funcs.Serv("Lighting").ClockTime = 14
					Funcs.Serv("Lighting").Brightness = 2
					ATTACK = false
					Humanoid.CameraOffset = VT(0,0,0)]]
				end

				function ToggleBlade()
					WACKYEFFECT({Time = 25,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(25,25,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = 260435136, SoundPitch = 0.9, SoundVolume = 10})
					WACKYEFFECT({Time = 12.5,EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(0.25,0,0.25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					WACKYEFFECT({Time = 12.5,EffectType = "Ring", Size = VT(0,0,0), Size2 = VT(1.25,2.5,2.5), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					WACKYEFFECT({Time = 12.5,EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(25,0,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					if WEAPONEQUIPPED == false and GUNEQUIPPED == false and CANNONEQUIPPED == false then
						WEAPONEQUIPPED = true
					else
						WEAPONEQUIPPED = false
					end
				end

				function ToggleGun()
					WACKYEFFECT({Time = 25,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(25,25,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = 260435136, SoundPitch = 0.9, SoundVolume = 10})
					WACKYEFFECT({Time = 12.5,EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(0.25,0,0.25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					WACKYEFFECT({Time = 12.5,EffectType = "Ring", Size = VT(0,0,0), Size2 = VT(1.25,2.5,2.5), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					WACKYEFFECT({Time = 12.5,EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(25,0,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					if GUNEQUIPPED == false and WEAPONEQUIPPED == false and CANNONEQUIPPED == false then
						GUNEQUIPPED = true
					else
						GUNEQUIPPED = false
					end
				end

				function ToggleCannon()
					WACKYEFFECT({Time = 25,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(25,25,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = 260435136, SoundPitch = 0.9, SoundVolume = 10})
					WACKYEFFECT({Time = 12.5,EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(0.25,0,0.25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					WACKYEFFECT({Time = 12.5,EffectType = "Ring", Size = VT(0,0,0), Size2 = VT(1.25,2.5,2.5), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					WACKYEFFECT({Time = 12.5,EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(25,0,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					if CANNONEQUIPPED == false and WEAPONEQUIPPED == false and GUNEQUIPPED == false then
						CANNONEQUIPPED = true
					else
						CANNONEQUIPPED = false
					end
				end
				function draw()
					repeat Swait()
						local a = Instance.new("Part",Effects)
						local mesh22 = Instance.new("SpecialMesh", a)
						mesh22.MeshId = Enum.MeshType.Sphere
						a.Name = "d r a w"
						a.Size = Vector3.new(2.5,0.01,2.5)
						a.CFrame = CFrame.new(Mouse.Hit.Position)
						a.Locked = true
						a.Anchored = true
						a.CanCollide = false
						a.Material = "Neon"
					until KEYHOLD == false
				end

				function Sprint()
					Speed = 70
					Animation_Speed = 5.0
					RUNNING = true
					Mouse.KeyUp:Connect(function(Key)
					game:GetService("RunService").RenderStepped:Wait()
						if Key == "0" then
							Animation_Speed = 3.0
							Speed = 30
							RUNNING = false
						end
					end)
				end

				function TP()
					for _, v in pairs(Funcs.Serv("Workspace"):GetChildren()) do
						if v:IsA("Model") and v:FindFirstChildOfClass("Humanoid") and v ~= Character then
							v:FindFirstChild("HumanoidRootPart").CFrame = Character:FindFirstChild("HumanoidRootPart").CFrame + Vector3.new(0,5,0)
							v:FindFirstChild("HumanoidRootPart").Anchored = true
						end
					end
					Slash()
				end
                coroutine.resume(coroutine.create(function()
                        local text = "Preparing functions..."
						warnedpeople2pp(text)
					end))
				function Combo()
					ATTACK = true
					Rooted = false
					local savespeed = Speed
					Speed = 12
					EQUIPPED = true
					local HIT2 = function()
						local HITS2 = {}
						local TOUCH2 = LeftArm.Touched:Connect(function(hit)
						game:GetService("RunService").RenderStepped:Wait()
							if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent ~= Character then
								local HUM = hit.Parent:FindFirstChildOfClass("Humanoid")
								local TORSO = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
								if TORSO and HUM.Health > 0 then
									local PASS = true
									for i = 1, #HITS2 do
										if HITS2[i] == hit.Parent then
											PASS = false
										end
									end
									table.insert(HITS2,hit.Parent)
									if PASS == true then
										Kill(HUM.Parent)
									end
								end
							end
						end)
						return TOUCH2
					end
					local HIT = function()
						local HITS = {}
						local TOUCH = RightArm.Touched:Connect(function(hit)
						game:GetService("RunService").RenderStepped:Wait()
							if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent ~= Character then
								local HUM = hit.Parent:FindFirstChildOfClass("Humanoid")
								local TORSO = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
								if TORSO and HUM.Health > 0 then
									local PASS = true
									for i = 1, #HITS do
										if HITS[i] == hit.Parent then
											PASS = false
										end
									end
									table.insert(HITS,hit.Parent)
									if PASS == true then
										Kill(HUM.Parent)
									end
								end
							end
						end)
						return TOUCH
					end
					if COMBO == 1 then
						for i=0, 0.35, 0.1 / Animation_Speed do
							Swait()
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(5)), 3 / 3)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)  
							if ANIM=="Walk" then
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
							else
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							end
						end
						CreateSound(1489705211,RightArm,MATHR(7,8),MATHR(8,13)/12,false)
						local TOUCHED = HIT()
						for i=0, 0.5, 0.1 / Animation_Speed do
							Swait()
							WACKYEFFECT2({EffectType = "Block", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-35)), 3 / 3)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.8, 0.5, -0.7) * ANGLES(RAD(0), RAD(0), RAD(-90)) * ANGLES(RAD(15), RAD(180), RAD(0)) * RIGHTSHOULDERC0, 0.6 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							if ANIM=="Walk" then
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
							else
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							end
						end
						TOUCHED:Disconnect()
						COMBO = 2
					elseif COMBO == 2 then
						for i=0, 0.35, 0.1 / Animation_Speed do
							Swait()
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(5)), 3 / 3)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(15)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							if ANIM=="Walk" then
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
							else
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							end
						end
						CreateSound(1489705211,LeftArm,MATHR(7,8),MATHR(8,13)/12,false)
						local TOUCHED = HIT2()
						for i=0, 0.5, 0.1 / Animation_Speed do
							Swait()
							WACKYEFFECT2({EffectType = "Block", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(45)), 3 / 3)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-55)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.6 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-105)) * ANGLES(RAD(90), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							if ANIM=="Walk" then
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
							else
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							end
						end
						TOUCHED:Disconnect()
						COMBO = 3
					elseif COMBO == 3 then
						for i=0, 0.35, 0.1 / Animation_Speed do
							Swait()
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 3 / 3)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.25, -0.2) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(75), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(75), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							if ANIM=="Walk" then
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(-25), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-25), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
							else
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-25), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-25), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							end
						end
						CreateSound(1489705211,LeftArm,MATHR(7,8),MATHR(8,13)/12,false)
						local TOUCHED = HIT2()
						local TOUCHED2 = HIT()
						for i=0, 0.5, 0.1 / Animation_Speed do
							Swait()
							WACKYEFFECT2({EffectType = "Block", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT2({EffectType = "Block", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 3 / 3)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.3, -0.2) * ANGLES(RAD(30), RAD(0), RAD(0)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(-30)) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.6 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(30)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							if ANIM=="Walk" then
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(30), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(30), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
							else
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(30), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(30), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							end
						end
						TOUCHED:Disconnect()
						TOUCHED2:Disconnect()
						COMBO = 4
					elseif COMBO == 4 then
						for i=0, 0.5, 0.1 / Animation_Speed do
							Swait()
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 3 / 3)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.3, -0.2) * ANGLES(RAD(30), RAD(0), RAD(0)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2, 0.5, -0.5) * ANGLES(RAD(75), RAD(0), RAD(-70)) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.6 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2, 0.5, -0.5) * ANGLES(RAD(75), RAD(0), RAD(70)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							if ANIM=="Walk" then
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(30), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(30), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
							else
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(30), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(30), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							end
						end	
						WACKYEFFECT({Time = 40,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(25,25,25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,-0.5), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = 260435136, SoundPitch = 0.9, SoundVolume = 10})
						WACKYEFFECT({Time = 25,EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(0.5,0,0.5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,-0.5), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 25,EffectType = "Ring", Size = VT(0,0,0), Size2 = VT(1,3,3), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,-0.5), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 25,EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(25,0,25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,-0.5), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						ShakeCam(3,10)
						ApplyAoE(RootPart.Position,25)
						for i=0, 0.5, 0.1 / Animation_Speed do
							Swait()
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 3 / 3)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.25, -0.2) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(75), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(75), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							if ANIM=="Walk" then
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(-25), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-25), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
							else
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-25), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-25), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							end
						end	
						COMBO = 1
					end
					coroutine.resume(coroutine.create(function()
						for i = 1, 50 do
							Swait()
							if ATTACK == true then
								break
							end
						end
						if ATTACK == false then
							COMBO = 1
						end
					end))
					Speed = savespeed
					ATTACK = false
					Rooted = false
					EQUIPPED = false
				end

				--//=================================				--||	  ASSIGN THINGS TO KEYS
				--=================================//
                spawn(function()
				chatfunc("A god named "..Player.Name.." came.",2,2,false)
				Player.Chatted:Connect(function(TEXT)
				game:GetService("RunService").RenderStepped:Wait()
					chatfunc(TEXT,2.5,2.5,false)
				end)
				function MouseDown(Mouse)
					HOLD = true
					if ATTACK == false then
						if WEAPONEQUIPPED == false then
							Combo()
						else
							BladeCombo()
						end
					end
				end

				function MouseUp(Mouse)
					HOLD = false
				end

				function KeyDown(Key)
					KEYHOLD = true
			--[[if Key == "0" and ATTACK == false and RUNNING == false then
				Sprint()
			end]]
					if Key == "q" and ATTACK == false and MODE >1 then
						SwitchModeEffect()
						MODE = MODE -1
					end
					if Key == "e" and ATTACK == false and MODE <20 then
						SwitchModeEffect()
						MODE = MODE +1
					end
					if Key == "t" then
						Notify("[Hyperskidded Echo]: ","Banlist cleared...")
						TOBANISH = {}
						TOBAN = {}
					end
					if Key == "z" and ATTACK == false then
						if GUNEQUIPPED == true then
							Shot1()
						elseif CANNONEQUIPPED == true then
							SingularityBeam()
						else
							Slash()
						end
					end
					if Key == "x" and ATTACK == false then
						if GUNEQUIPPED == true then
							Shot2()
						elseif CANNONEQUIPPED == true then
							Ka_Boom()
						else
							Stomp()
						end
					end
					if Key == "c" and ATTACK == false then
						Warp()
					end
					if Key == "v" and ATTACK == false then
						Grab()
					end
					if Key == "b" and ATTACK == false then
						Nightmare_Is_Coming()
					end
					if Key == "j" and ATTACK == false then
						ToggleCannon()
					end
					if Key == "l" and ATTACK == false then
						TerrainColSwitch()
					end
					if Key == "k" and ATTACK == false then
						ToggleGun()
					end
				end
				function KeyUp(Key)
					KEYHOLD = false
				end

				Mouse.Button1Down:connect(function(NEWKEY)
				game:GetService("RunService").RenderStepped:Wait()
					MouseDown(NEWKEY)
				end)
				Mouse.Button1Up:connect(function(NEWKEY)
				game:GetService("RunService").RenderStepped:Wait()
					MouseUp(NEWKEY)
				end)
				Mouse.KeyDown:connect(function(NEWKEY)
				game:GetService("RunService").RenderStepped:Wait()
					KeyDown(NEWKEY)
				end)
				Mouse.KeyUp:connect(function(NEWKEY)
				game:GetService("RunService").RenderStepped:Wait()
					KeyUp(NEWKEY)
				end)

				RunService.RenderStepped:Connect(function()
				game:GetService("RunService").RenderStepped:Wait()
					CRootPart.CFrame = RootPart.CFrame
				end)
                
				--//=================================				--              Yo
				--=================================//

				function unanchor()
					if UNANCHOR == true then
						g = Character:GetChildren()
						for i = 1, #g do
							if g[i].ClassName == "Part" then
								g[i].Anchored = false
							end
						end
					end
				end
end)
                coroutine.resume(coroutine.create(function()
                        local text = "Running anims.."
						warnedpeople2pp(text)
					end))
				--//=================================				--||	WRAP THE WHOLE SCRIPT UP
				--=================================//

				Humanoid.Changed:connect(function(Jump)
game:GetService("RunService").RenderStepped:Wait()
					if Jump == "Jump" and (Disable_Jump == true) then
						Humanoid.Jump = false
					elseif Jump == "Jump" and (Disable_Jump == false) then
						wait(0.1)
					end
				end)

				spawn(function()
					while wait() do
						if Effects:FindFirstChild("Effect") then
							local effect = Effects:FindFirstChild("Effect")
							wait(2.5)
							if effect ~= nil then
								effect:remove()
							end
						end
					end
				end)
					coroutine.resume(coroutine.create(function()
						Funcs.FixCamera(CameraRootPart, 0.5, 400)
						CharClones.CharacterCloneLoading:Destroy()
                        local text = "Hyperskidded Echo "..SCRIPTVERSION..", by SUPER_TIGERPRO/super_tiger123456 Loaded"
						warnedpeople2pp(text)
					end))
				while true do
					Swait()
					--[[if AntiBullet == true then
						if Funcs.Serv("Workspace"):FindFirstChild("EnCorrupt") == nil then
							Shield = Instance.new("UnionOperation",Funcs.Serv("Workspace"))
							Shield.Name = "EnCorrupt"
							Shield.CanCollide = true
							Shield.Transparency = 1
							Shield.Material = "Neon"
							Shield.Color = C3(MATHR(1,255),MATHR(1,255),MATHR(1,255))
							Shield.Massless = true
							Shield.Size = Vector3.new(7.5,7.5,7.5)
							Shield.CFrame = Torso.CFrame
							local GlitchWeld = Instance.new("Weld",Shield)
							GlitchWeld.Part0 = Shield
							GlitchWeld.Part1 = Torso
							for i = 1, 10 do--face
								local FACE = CreatePart(3, Character, "Neon", 0, 0+(i-1)/16.2, "Really black", "FaceGradient", VT(1.01,0.65,1.01),false)
								Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
								CreateWeldOrSnapOrMotor("Weld", Head, Head, FACE, CF(0,0.45-(i-1)/25,0), CF(0, 0, 0))
							end
							local Eye1 = CreatePart(3, Character, "Neon", 0, 0, "Really white", "Eye", VT(0.6,0.1,1)/2,false)
							MakeForm(Eye1,"Ball")
							CreateWeldOrSnapOrMotor("Weld", Eye1, Head, Eye1, CF(0,0.2,0) * ANGLES(RAD(0), RAD(-18), RAD(15)), CF(0, 0, 0.4))
							local Eye2 = CreatePart(3, Character, "Neon", 0, 0, "Really white", "Eye", VT(0.6,0.1,1)/2,false)
							MakeForm(Eye2,"Ball")
						end
					end]]
					--[[if Character:FindFirstChild("Safety") == nil then
						local Safety = IT("Script")
						Safety.Name = "Safety"
						Safety.Parent = Character
					end]]
					--[[for T = 1, #TAIL do
						if TAIL[T] ~= nil then
							TAIL[T].C1 = Clerp(TAIL[T].C1, CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(3.5 * SIN(SINE / 12))), 1 / 5)
						end
					end]] --eeeeeeeeeee
					for _,v in next, Humanoid:GetPlayingAnimationTracks() do
						v:Stop();
					end
					SINE = SINE + CHANGE
					vissine = vissine + CHANGE * Sick.PlaybackLoudness/150
					sine = sine + CHANGE
					Hue = Hue + 1
                    lighter.Brightness = Sick.PlaybackLoudness/500
                    lighter.Range = Sick.PlaybackLoudness/10
					if (Hue>360) then Hue = 0 end
					local TORSOVELOCITY = (ActualVelocity * VT(1, 0, 1)).magnitude
					local TORSOVERTICALVELOCITY = ActualVelocity.y
					if lplr == Player then
						TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
						TORSOVERTICALVELOCITY = RootPart.Velocity.y
					end
					local S = 1
					local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*SIZE, Character)
					local Welds = {
						Defaults = {
							Neck = {
								C0 = CFrame.new(0, 1 * S, 0) * CFrame.Angles(math.rad(-90), 0, math.rad(180))
							},
							RootJoint = {
								C0 = CFrame.new() * CFrame.Angles(math.rad(-90), 0, math.rad(180))
							},
							RightShoulder = {
								C0 = CFrame.new(-.5 * S, 0, 0) * CFrame.Angles(0, math.rad(90), 0)
							},
							LeftShoulder = {
								C0 = CFrame.new(.5 * S, 0, 0) * CFrame.Angles(0, math.rad(-90), 0)
							}
						},
						Neck = {
							C0 = CFrame.new(0, 1 * S, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0),
							C1 = CFrame.new(0, -.5 * S, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
						},
						RootJoint = {
							C0 = CFrame.new(),
							C1 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
						},
						RightShoulder = {
							C0 = CFrame.new(1 * S, .5 * S, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0),
							C1 = CFrame.new(-.5 * S, .5 * S, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
						},
						LeftShoulder = {
							C0 = CFrame.new(-1 * S, .5 * S, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
							C1 = CFrame.new(.5 * S, .5 * S, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
						},
						RightHip = {
							C0 = CFrame.new(1 * S, -1 * S, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0),
							C1 = CFrame.new(.5 * S, 1 * S, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
						},
						LeftHip = {
							C0 = CFrame.new(-1 * S, -1 * S, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
							C1 = CFrame.new(-.5 * S, 1 * S, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
						},
						Eyes = {
							C0 = CFrame.new(),
							C1 = CFrame.new(.143993527 * S, -.15178299 * S, .525008798 * S, .965925813, 0, .258819044, 0, 1, 0, -.258819044, 0, .965925813)
						},
						Sword = {
							C0 = CFrame.new(0, -1 * S, 0) * CFrame.Angles(math.rad(90), 0, 0),
							C1 = CFrame.new(0, -3.15 * S, 0)
						},
						RightWing = {
							C0 = CFrame.new(.15 * S, .5 * S, .5 * S) * CFrame.Angles(0, math.rad(90), 0),
							C1 = CFrame.new(1.1 * S, 1 * S, -.75 * S)
						},
						LeftWing = {
							C0 = CFrame.new(-.15 * S, .5 * S, .5 * S) * CFrame.Angles(0, math.rad(90), 0),
							C1 = CFrame.new(1.1 * S, 1 * S, .75 * S)
						}
					}
					GroundMababjin.CFrame = RootPart.CFrame * CFrame.new(0,-1.5,0) * CFrame.Angles(0, math.rad(-SINE * 1), 0)
					if Sick.PlaybackLoudness > 5 then
						BGMHeight = 0
					else
						BGMHeight = (5 - Sick.PlaybackLoudness) / 15
					end
					if OrbAcc then
						OrbAccAthp.Name = "Attachment1"
						OrbAccAtho.Name = "Attachment2"
			
						OrbAccAthp.Position = Vector3.new(0+9*math.sin(sine/35),0+2*math.sin(sine/75),0+9*math.cos(sine/35))
						OrbAccAtho.Rotation = Vector3.new(math.rad(-SINE * 0.5 * 50), math.rad(-SINE * 1 * 50), math.rad(-SINE * 1.5 * 50))
			
						OrbAcc:FindFirstChildOfClass("AlignPosition").Attachment1 = OrbAccAthp
						OrbAcc:FindFirstChildOfClass("AlignOrientation").Attachment1 = OrbAccAtho
					end
					if MPASwordAcc1 and not FEATTACK then
						MPASwordAthp1.Name = "Attachment1"
						MPASwordAtho1.Name = "Attachment2"
					
						MPASwordAthp1.Position = Vector3.new(2.5 * Sick.PlaybackLoudness / 75, -3 - BGMHeight, 0)
						MPASwordAtho1.Rotation = Vector3.new(90, 0, 135)
					
						MPASwordAcc1:FindFirstChildOfClass("AlignPosition").Attachment1 = MPASwordAthp1
						MPASwordAcc1:FindFirstChildOfClass("AlignOrientation").Attachment1 = MPASwordAtho1
					end
					if MPASwordAcc2 and not FEATTACK then
						MPASwordAthp2.Name = "Attachment3"
						MPASwordAtho2.Name = "Attachment4"
						
						MPASwordAthp2.Position = Vector3.new(-2.5 * Sick.PlaybackLoudness / 75, -3 - BGMHeight, 0)
						MPASwordAtho2.Rotation = Vector3.new(90, 0, -45)
					
						MPASwordAcc2:FindFirstChildOfClass("AlignPosition").Attachment1 = MPASwordAthp2
						MPASwordAcc2:FindFirstChildOfClass("AlignOrientation").Attachment1 = MPASwordAtho2
					end
					if MPASwordAcc3 and not FEATTACK then
						MPASwordAthp3.Name = "Attachment5"
						MPASwordAtho3.Name = "Attachment6"
						
						MPASwordAthp3.Position = Vector3.new(0, -3 - BGMHeight, 2.5 * Sick.PlaybackLoudness / 75)
						MPASwordAtho3.Rotation = Vector3.new(90, 0, -135)
					
						MPASwordAcc3:FindFirstChildOfClass("AlignPosition").Attachment1 = MPASwordAthp3
						MPASwordAcc3:FindFirstChildOfClass("AlignOrientation").Attachment1 = MPASwordAtho3
					end
					if MPASwordAcc4 and not FEATTACK then
						MPASwordAthp4.Name = "Attachment7"
						MPASwordAtho4.Name = "Attachment8"
						
						MPASwordAthp4.Position = Vector3.new(0, -3 - BGMHeight, -2.5 * Sick.PlaybackLoudness / 75)
						MPASwordAtho4.Rotation = Vector3.new(90, 0, 45)
					
						MPASwordAcc4:FindFirstChildOfClass("AlignPosition").Attachment1 = MPASwordAthp4
						MPASwordAcc4:FindFirstChildOfClass("AlignOrientation").Attachment1 = MPASwordAtho4
					end
					local WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)
					if ANIM == "Walk" and TORSOVELOCITY > 1 then
						if CANNONEQUIPPED == false then
							RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
							Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
							RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
							LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
						else

						end
					elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
						RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
						Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
						RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
						LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
					end
					if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil and ATTACK == false then
						ANIM = "Jump"
						if WEAPONEQUIPPED == false then
							RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / 5)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE , 0*SIZE + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / 5)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / 5)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / 5)
							RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.4*SIZE, -0.6*SIZE) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
						else
							RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / 5)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-45), RAD(0), RAD(0)), 1 / 5)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(15 + 5 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / 5)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / 5)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
						end
					elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil and ATTACK == false then
						ANIM = "Fall"
						if WEAPONEQUIPPED == false then
							RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / 5)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE , 0 + ((1) - 1*SIZE)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / 5)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / 5)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / 5)
							RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.3*SIZE, -0.7*SIZE) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -0.8*SIZE, -0.3*SIZE) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
						else
							RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / 5)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / 5)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180 - 4 * COS(SINE / 6)), RAD(0), RAD(15 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / 5)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / 5)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.3) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
						end
					elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil and ATTACK == false then
						ANIM = "Idle"
						DOUBLED = false
						READYTODOUBLE = false
						if MODE == 1 then
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.25,-0.5)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))*CFrame.Angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))*CFrame.Angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,1.5 + 0.1 * math.cos(sine / 28))*CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
							Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),.1)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75, 0.5 + 0.05 * SIN(sine / 12), -1) * ANGLES(RAD(1.5 - 1.5 * SIN(sine / 12)), RAD(0), RAD(-95)) * ANGLES(RAD(-5), RAD(-90 + 2.5 * COS(sine / 12)), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.75, 0.35 + 0.05 * SIN(sine / 12),-0.9) * ANGLES(RAD(1.5 - 1.5 * SIN(sine / 12)), RAD(0), RAD(92)) * ANGLES(RAD(0), RAD(90 - 2.5 * COS(sine / 12)), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						elseif MODE == 2 then
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75, 0.4 - 0.1 * COS(sine / 12), -1) * ANGLES(RAD(70), RAD(0), RAD(-70)) * ANGLES(RAD(20), RAD(25), RAD(-15)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.1 - 0.1 * COS(sine / 12), -0.5) * ANGLES(RAD(25), RAD(0), RAD(85)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.025 * COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
						elseif MODE == 3 then
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.25,-0.5)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))*CFrame.Angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))*CFrame.Angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,1.5 + 0.1 * math.cos(sine / 28))*CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
							Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),.1)
							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1,.5,-.25)*CFrame.Angles(0,math.rad(-10),math.rad(-90))*Welds.Defaults.RightShoulder.C0,.25)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0)*CFrame.Angles(math.rad(10),math.rad(0),math.rad(-20 - 2.5 * math.cos(sine / 28))),.1)
						elseif MODE == 4 or MODE == 5 then
							RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 1 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(-2.5 * COS(SINE / 12)), RAD(-25)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75, 0.5 + 0.05 * SIN(SINE / 12), -1) * ANGLES(RAD(1.5 - 1.5 * SIN(SINE / 12)), RAD(0), RAD(-95)) * ANGLES(RAD(-5), RAD(-90 + 2.5 * COS(SINE / 12)), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.75, 0.35 + 0.05 * SIN(SINE / 12),-0.9) * ANGLES(RAD(1.5 - 1.5 * SIN(SINE / 12)), RAD(0), RAD(92)) * ANGLES(RAD(0), RAD(90 - 2.5 * COS(SINE / 12)), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(65), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-100), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
						elseif MODE == 6 then
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5*S,.5*S,0)*CFrame.Angles(math.rad(5 * math.cos(sine / 24)),0,math.rad(-10 - 5.5 * math.cos(sine / 34)))*Welds.Defaults.LeftShoulder.C0,.25)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
						elseif MODE == 7 then
							RootJoint.C0 = Clerp(RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50))*CFrame.Angles(math.rad(-25+5*math.sin(sine/50)),0,0),.7/3)
							Neck.C0 = Clerp(Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(30+5*math.sin(sine/50)),math.rad(0),math.rad(0)),0.7/3)
							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-5 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(13 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
						elseif MODE == 8 then
							WACKYEFFECT({TIME = MATHR(15,25)*2, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MATHR(-20,20),2,MATHR(-20,20))), MoveToPos = Torso.Position+VT(0,MATHR(45,145)/1.5,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({TIME = MATHR(0,22), EffectType = "Sphere", Size = VT(2 + 2 * COS(SINE/4),5 + 2 * COS(SINE/4),2 + 2 * COS(SINE/4)), Size2 = VT(-3,-6,-4), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0) * ANGLES(RAD(MATHR(-360,360)), RAD(MATHR(-360,360)), RAD(MATHR(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-22,22), RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({Time = MATHR(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MATHR(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
							if MATHR(1,10) == 1 then
								Neck.C0=Clerp(Torso.Neck.C0,NECKC0*CFrame.Angles(RAD(23 + MATHR(-5,5)),RAD(MATHR(-5,5)),RAD(22 + MATHR(-5,5))),1)
							end
							if math.random(1,8) == 1 then
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-87498,12093847)), RAD(MATHR(-123456,3746525)), RAD(MATHR(-2134567876,98764356))), 0.15 / Animation_Speed)
							end
							if(math.random(1,4)==1)then
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							end		
							if MATHR(1,10) == 1 then
								Neck.C0=Clerp(Torso.Neck.C0,NECKC0*CFrame.Angles(RAD(23 + MATHR(-5,5)),RAD(MATHR(-5,5)),RAD(22 + MATHR(-5,5))),1)
							end
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MATHR(-25,25)), RAD(0)), 0.15 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, -.7) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(SINE / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(SINE / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(SINE / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)snap = math.random(1,72)
							snap = math.random(1,72)
							if snap == 1 then
								CreateSound(406913243,Head,3,1.3,false)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-100000-Sick.PlaybackLoudness/7,100000+Sick.PlaybackLoudness/7)), RAD(MATHR(-99999-Sick.PlaybackLoudness/7,99999+Sick.PlaybackLoudness/7)), RAD(MATHR(-200-Sick.PlaybackLoudness/7,48375935+Sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
							end						
						elseif MODE == 9 then
							local FRAME = CF(VT(Torso.Position.X+MATHR(-15,15),Torso.Position.Y,Torso.Position.Z+MATHR(-15,15)))
							MagicSphere(VT(0.6,0.6,0.6),15,FRAME,"Royal purple",VT(0.1,2,0.1),0)
							MagicSphere(VT(0.2,0.2,0.2),15,FRAME,"Really black",VT(0.1,2,0.1),0)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MATHR(-15, 25)), RAD(MATHR(-15, 25))), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, 0.5) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / 12)), RAD(-55 + 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 15 * COS(SINE / 12))) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
						elseif MODE == 10 then
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(sine / 12)), RAD(-55 + 2.5 * SIN(sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.15, -0.45) * ANGLES(RAD(80), RAD(0), RAD(80)) * ANGLES(RAD(0), RAD(45), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						elseif MODE == 11 then -- USC's echo animation
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.03 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 1 / 5)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MATHR(-5,5) - 4 * COS(SINE / 12)), RAD(MATHR(-5,5)), RAD(15)), 1 / 5)
							if math.random(1,5) == 1 then
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MATHR(-25,25) - 4 * COS(SINE / 12)), RAD(MATHR(-25,25)), RAD(0)), 1.5 / Animation_Speed)	
							end
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / 5)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / 5)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(95), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / 5)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-12), RAD(0), RAD(0)), 1 / 5)
						elseif MODE == 12 then
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 3 + 0.5 * COS(SINE / 22)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2, 0.5 + 0.05 * SIN(SINE / 24), -0.7) * ANGLES(RAD(180), RAD(0), RAD(0)) * ANGLES(RAD(5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.45, 0.5, -1) * ANGLES(RAD(90), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(-20+10*COS(SINE/22))) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-70), RAD(25-10*COS(SINE/22))) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
						elseif MODE == 13 then
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(SINE/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
							Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20),math.rad(10*math.cos(SINE/100)),math.rad(0)),1)
							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(SINE/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(SINE/50))) * LEFTSHOULDERC0,0.7/3)
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(10),math.rad(80),math.rad(10+10*math.sin(SINE/50))),1/3)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10-10*math.sin(SINE/50))),1/3)
						elseif MODE == 14 then
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)
							Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
						elseif MODE == 15 then
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.03) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.45, 0.4, 0.5) * ANGLES(RAD(25), RAD(0), RAD(35)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
						elseif MODE == 16 then
							RightHip.C0 = Clerp(RightHip.C0,CF(1,-1 - 0.1 * math.cos(sine / 32),0)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))*CFrame.Angles(math.rad(-10 - 2.5 * math.cos(sine / 32)),math.rad(-20),math.rad(0)),.1)
							LeftHip.C0 = Clerp(LeftHip.C0,CF(-1,-1 - 0.1 * math.cos(sine / 32),0)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10 + 2.5 * math.cos(sine / 32))),.1)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CF(0,0,0 + 0.1 * math.cos(sine / 32))*CFrame.Angles(math.rad(10 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(20)),.1)
							Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(25 - 2.5 * math.cos(sine / 32)),math.rad(0 - 5 * math.cos(sine / 0.25)),math.rad(-20 - 5 * math.cos(sine / 0.465))),.1)
							RightShoulder.C0 = Clerp(RightShoulder.C0,CF(1.5,0.5,0)*CFrame.Angles(math.rad(10),math.rad(-20),math.rad(30 + 2.5 * math.cos(sine / 25))),.1)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CF(-1.5,0.5,0)*CFrame.Angles(math.rad(160),math.rad(0),math.rad(25)),.1)
						elseif MODE == 17 then
							WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color =Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({Time = MATHR(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MATHR(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(98/255 + Sick.PlaybackLoudness/1000, 37/255 + Sick.PlaybackLoudness/1000, 209/255 + Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							local FRAME = CF(VT(Torso.Position.X+MATHR(-15,15),Torso.Position.Y,Torso.Position.Z+MATHR(-15,15)))
							MagicSphere(VT(0.6,0.6,0.6),15,FRAME,"Neon orange",VT(0.1,2,0.1),0)
							MagicSphere(VT(0.2,0.2,0.2),15,FRAME,"Royal purple",VT(0.1,2,0.1),0)
							if VALUE1 == false and math.random(1,55) == 1 then
								coroutine.resume(coroutine.create(function()
									VALUE1 = true
									wait(2)
									CreateSound(333430981,RootPart,2,math.random(5, 15) / 10,false)
									for i=1,25 do
										Swait()
										FT.Parent = Torso
										FRA.Parent = RightArm
										FLA.Parent = LeftArm
										FRL.Parent = RightLeg
										FLL.Parent = LeftLeg
										for _,v in next, Character:GetDescendants() do
											if(v:IsA'DataModelMesh')then
												v.Offset = VT(math.random(-50,50)/100,math.random(-50,50)/100,math.random(-50,50)/100)
											end
										end		
									end
									VALUE1 = false
									FT.Parent = nil
									FRA.Parent = nil
									FLA.Parent = nil
									FRL.Parent = nil
									FLL.Parent = nil
									for _,v in next, Character:GetDescendants() do
										if(v:IsA'DataModelMesh')then
											v.Offset = VT(0,0,0)
										end
									end	
								end))
							end
							if MATHR(1,10) == 1 then
								Neck.C0=Clerp(Torso.Neck.C0,NECKC0*CFrame.Angles(RAD(23 + MATHR(-5,5)),RAD(MATHR(-5,5)),RAD(22 + MATHR(-5,5))),1)
							end
							if math.random(1,8) == 1 then
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-87498,12093847)), RAD(MATHR(-123456,3746525)), RAD(MATHR(-2134567876,98764356))), 0.15 / Animation_Speed)
							end
							if(math.random(1,4)==1)then
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							end			
							if MATHR(1,10) == 1 then
								Neck.C0=Clerp(Torso.Neck.C0,NECKC0*CFrame.Angles(RAD(23 + MATHR(-5,5)),RAD(MATHR(-5,5)),RAD(22 + MATHR(-5,5))),1)
							end
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 1 * SIN(SINE / 26)) * ANGLES(RAD(-5 - 2.5*SIN(SINE/48/2)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MATHR(-25,25)), RAD(0)), 0.15 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(140 + 5 * COS(SINE /32)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.8 / 5)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MATHR(-25,25)), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-17 + 9.4 * COS(sine / 26)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-22 + 10.8 * COS(sine / 32)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							if snap == 1 then
								CreateSound(363808674,Head,3,1.3,false)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-100000-Sick.PlaybackLoudness/7,100000+Sick.PlaybackLoudness/7)), RAD(MATHR(-99999-Sick.PlaybackLoudness/7,99999+Sick.PlaybackLoudness/7)), RAD(MATHR(-200-Sick.PlaybackLoudness/7,48375935+Sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
							end
							if MATHR(1,20+Sick.PlaybackLoudness/7) == 1 then
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-90-Sick.PlaybackLoudness/7,90+Sick.PlaybackLoudness/7)), RAD(MATHR(-30-Sick.PlaybackLoudness/7,30+Sick.PlaybackLoudness/7)), RAD(MATHR(-50-Sick.PlaybackLoudness/7,50+Sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-10000-Sick.PlaybackLoudness/7,10000+Sick.PlaybackLoudness/7)), RAD(MATHR(-900-Sick.PlaybackLoudness/7,900+Sick.PlaybackLoudness/7)), RAD(MATHR(-20-Sick.PlaybackLoudness/7,20+Sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
							end						
						elseif MODE == 18 then
							if VALUE1 == false and math.random(1,55) == 1 then
								coroutine.resume(coroutine.create(function()
									VALUE1 = true
									wait(2)
									CreateSound(333430981,RootPart,2,math.random(5, 15) / 10,false)
									for i=1,25 do
										Swait()
										FT.Parent = Torso
										FRA.Parent = RightArm
										FLA.Parent = LeftArm
										FRL.Parent = RightLeg
										FLL.Parent = LeftLeg
										for _,v in next, Character:GetDescendants() do
											if(v:IsA'DataModelMesh')then
												v.Offset = VT(math.random(-50,50)/100,math.random(-50,50)/100,math.random(-50,50)/100)
											end
										end		
									end
									VALUE1 = false
									FT.Parent = nil
									FRA.Parent = nil
									FLA.Parent = nil
									FRL.Parent = nil
									FLL.Parent = nil
									for _,v in next, Character:GetDescendants() do
										if(v:IsA'DataModelMesh')then
											v.Offset = VT(0,0,0)
										end
									end	
								end))
							end
							if(math.random(1,4)==1)then
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							end	
							if math.random(1,25) == 1 then
								Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1.5/Animation_Speed)
							end	
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed) 
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(160 + 4 * COS(SINE / 62)), RAD(0), RAD(15 - 3 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-15 + 3 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-17 + 9.4 * COS(sine / 26)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-22 + 10.8 * COS(sine / 32)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							if MATHR(1,20+Sick.PlaybackLoudness/7) == 1 then
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-90-Sick.PlaybackLoudness/7,90+Sick.PlaybackLoudness/7)), RAD(MATHR(-30-Sick.PlaybackLoudness/7,30+Sick.PlaybackLoudness/7)), RAD(MATHR(-50-Sick.PlaybackLoudness/7,50+Sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-10000-Sick.PlaybackLoudness/7,10000+Sick.PlaybackLoudness/7)), RAD(MATHR(-900-Sick.PlaybackLoudness/7,900+Sick.PlaybackLoudness/7)), RAD(MATHR(-20-Sick.PlaybackLoudness/7,20+Sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
							end
							if(math.random(1,4)==1)then
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							end	
						elseif MODE == 19 then
							if(math.random(1,4)==1)then
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							end	
							if math.random(1,25) == 1 then
								Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1.5/Animation_Speed)
							end	
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0+MATHR(-5,5)), RAD(0+MATHR(-5,5)), RAD(0+MATHR(-5,5))), 0.35 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MATHR(-25,25)), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-20)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
							if MATHR(1,20+Sick.PlaybackLoudness/7) == 1 then
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-90-Sick.PlaybackLoudness/7,90+Sick.PlaybackLoudness/7)), RAD(MATHR(-30-Sick.PlaybackLoudness/7,30+Sick.PlaybackLoudness/7)), RAD(MATHR(-50-Sick.PlaybackLoudness/7,50+Sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-10000-Sick.PlaybackLoudness/7,10000+Sick.PlaybackLoudness/7)), RAD(MATHR(-900-Sick.PlaybackLoudness/7,900+Sick.PlaybackLoudness/7)), RAD(MATHR(-20-Sick.PlaybackLoudness/7,20+Sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
							end
							if(math.random(1,2)==1)then
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							end
						elseif MODE == 20 then
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed) 
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(160 + 4 * COS(SINE / 62)), RAD(0), RAD(15 - 3 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-15 + 3 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-17 + 9.4 * COS(sine / 26)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-22 + 10.8 * COS(sine / 32)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							if MATHR(1,32+Sick.PlaybackLoudness/7) == 1 then
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-100000-Sick.PlaybackLoudness/7,100000+Sick.PlaybackLoudness/7)), RAD(MATHR(-99999-Sick.PlaybackLoudness/7,99999+Sick.PlaybackLoudness/7)), RAD(MATHR(-200-Sick.PlaybackLoudness/7,48375935+Sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
							end
							if MATHR(1,20+Sick.PlaybackLoudness/7) == 1 then
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-90-Sick.PlaybackLoudness/7,90+Sick.PlaybackLoudness/7)), RAD(MATHR(-30-Sick.PlaybackLoudness/7,30+Sick.PlaybackLoudness/7)), RAD(MATHR(-50-Sick.PlaybackLoudness/7,50+Sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-10000-Sick.PlaybackLoudness/7,10000+Sick.PlaybackLoudness/7)), RAD(MATHR(-900-Sick.PlaybackLoudness/7,900+Sick.PlaybackLoudness/7)), RAD(MATHR(-20-Sick.PlaybackLoudness/7,20+Sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
							end
						end
					elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil and ATTACK == false then
						ANIM = "Walk"
						DOUBLED = false
						READYTODOUBLE = false
						if MODE == 1 then
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.25,-0.5)*ANGLES(math.rad(0),math.rad(90),math.rad(0))*ANGLES(math.rad(-2.5),math.rad(0),math.rad(-20)),.2)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0)*ANGLES(math.rad(0),math.rad(-90),math.rad(0))*ANGLES(math.rad(-2.5),math.rad(0),math.rad(20)),.2)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*ANGLES(math.rad(75),math.rad(0),math.rad(0)),.2)
							Neck.C0 = Clerp(Neck.C0,NECKC0*ANGLES(math.rad(-20),math.rad(0),math.rad(0)),.2)
							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1,.5,-.25)*CFrame.Angles(0,math.rad(-10),math.rad(-90))*Welds.Defaults.RightShoulder.C0,.25)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0)*ANGLES(math.rad(-30),math.rad(0),math.rad(-30 - 2.5 * math.cos(sine / 28))),.2)
						elseif MODE == 2 then
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-15, 25) - 2.5 * SIN(sine / 12)), RAD(MATHR(-15, 25)), RAD(MATHR(-15, 25))), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(sine / 18)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(sine / 18), -0.2+ 0.2 * COS(sine / 18)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(sine / 18), -0.2+ -0.2 * COS(sine / 18)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
						elseif MODE == 3 then
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MATHR(-15, 25)), RAD(MATHR(-15, 25))), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / 18)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / 18), -0.2+ 0.2 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / 18), -0.2+ -0.2 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)	
						elseif MODE == 4 or MODE == 5 then
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0+MATHR(-15,15)), RAD(0+MATHR(-15,15)), RAD(0+MATHR(-15,15))), 0.35 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
						elseif MODE == 6 then
							RootJoint.C0 = Clerp(RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,-0.1+0.15* math.sin(sine / 3)*S)*CFrame.Angles(math.rad(15+3 * math.cos(sine / 3)),0,0),.25)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5*S,.5*S,0)*CFrame.Angles(math.rad(0 + 70 * math.sin(sine / 6)),0,math.rad(-5))*Welds.Defaults.LeftShoulder.C0,.25)
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1*S,-1*S,0)*CFrame.Angles(math.rad(5 + 70 * math.sin(sine / 6)),math.rad(90),math.rad(5)),.25)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1*S,-1*S,0)*CFrame.Angles(math.rad(5 - 70 * math.sin(sine / 6)),math.rad(-90),math.rad(-5)),.25)
						elseif MODE == 7 then
							RootJoint.C0 = Clerp(RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(.5*math.cos(sine/50),0,-.5*math.sin(sine/50))*CFrame.Angles(math.rad(40),0,0),.25)
							Neck.C0 = Clerp(Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(sine/19)))*Welds.Defaults.LeftShoulder.C0,.25)
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-20+9*math.cos(sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(sine/37)),0,0),.25)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-20-9*math.cos(sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(sine/41)),0,0),.25)
						elseif MODE == 8 then
							Speed = 25
							WACKYEFFECT({TIME = MATHR(15,25)*2, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MATHR(-20,20),2,MATHR(-20,20))), MoveToPos = Torso.Position+VT(0,MATHR(45,145)/1.5,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({TIME = MATHR(0,22), EffectType = "Sphere", Size = VT(2 + 2 * COS(SINE/4),5 + 2 * COS(SINE/4),2 + 2 * COS(SINE/4)), Size2 = VT(-3,-6,-4), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0) * ANGLES(RAD(MATHR(-360,360)), RAD(MATHR(-360,360)), RAD(MATHR(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-22,22), RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({Time = MATHR(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MATHR(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.25 * COS(SINE / 28)) * ANGLES(RAD(25+2.5*COS(SINE/28)), RAD(0), RAD(0)), 1 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(RAD(-5+3.4*COS(SINE/28)),RAD(3*COS(SINE/28)),RAD(0)),1/Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0,CF(1.5, 0.5, 0)*ANGLES(RAD(-90-5*COS(SINE/28)),RAD(0),RAD(0))* RIGHTSHOULDERC0,1/Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, -.7) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.05*COS(SINE / 28), -0.01) * ANGLES(RAD(-4), RAD(80), RAD(0)) * ANGLES(RAD(-8-2.5*COS(SINE/28)), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5-.05*COS(SINE  / 28), -0.5) * ANGLES(RAD(-8), RAD(-80), RAD(0)) * ANGLES(RAD(-8-2.5*COS(SINE/28)), RAD(0), RAD(0)), 1 / Animation_Speed)
							snap = math.random(1,72)
							if snap == 1 then
								CreateSound(406913243,Head,3,1.3,false)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-100000-Sick.PlaybackLoudness/7,100000+Sick.PlaybackLoudness/7)), RAD(MATHR(-99999-Sick.PlaybackLoudness/7,99999+Sick.PlaybackLoudness/7)), RAD(MATHR(-200-Sick.PlaybackLoudness/7,48375935+Sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
							end						
						elseif MODE == 9 then
							Speed = 16
							local FRAME = CF(VT(Torso.Position.X+MATHR(-15,15),Torso.Position.Y,Torso.Position.Z+MATHR(-15,15)))
							MagicSphere(VT(0.6,0.6,0.6),15,FRAME,"Royal purple",VT(0.1,2,0.1),0)
							MagicSphere(VT(0.2,0.2,0.2),15,FRAME,"Really black",VT(0.1,2,0.1),0)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MATHR(-15, 25)), RAD(MATHR(-15, 25))), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
						elseif MODE == 10 then
							RootJoint.C0 = Clerp(RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,-0.1+0.15* math.sin(sine / 3)*S)*CFrame.Angles(math.rad(15+3 * math.cos(sine / 3)),0,0),.25)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(sine / 12)), RAD(-55 + 2.5 * SIN(sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5*S,.5*S,0)*CFrame.Angles(math.rad(0 + 70 * math.sin(sine / 6)),0,math.rad(-5))*Welds.Defaults.LeftShoulder.C0,.25)
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1*S,-1*S,0)*CFrame.Angles(math.rad(5 + 70 * math.sin(sine / 6)),math.rad(90),math.rad(5)),.25)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1*S,-1*S,0)*CFrame.Angles(math.rad(5 - 70 * math.sin(sine / 6)),math.rad(-90),math.rad(-5)),.25)
						elseif MODE == 11 then -- USC's echo animation
							RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0* 1, 0* 1, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7* 1) * ANGLES(RAD(26 - 4.5 * COS(SINE / 3.5)), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(15 * COS(SINE / 7))), 0.15)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MATHR(-5,5) - 4 * COS(SINE / 12)), RAD(MATHR(-5,5)), RAD(15)), 1 / Animation_Speed)
							if math.random(1,5) == 1 then
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MATHR(-25,25) - 4 * COS(SINE / 12)), RAD(MATHR(-25,25)), RAD(0)), 1.5 / Animation_Speed)	
							end
							RightHip.C0 = Clerp(RightHip.C0, CF(1* 1, -0.925 - 0.5 * COS(SINE / 7) / 2* 1, 0.7 * COS(SINE / 7) / 2* 1) * ANGLES(RAD(-15 - 55 * COS(SINE / 7)) - RightLeg.RotVelocity.Y / 75 + -SIN(SINE / 7) / 2.5, RAD(90 - 0.1 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 0.1 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1* 1, -0.925 + 0.5 * COS(SINE / 7) / 2* 1, -0.7 * COS(SINE / 7) / 2* 1) * ANGLES(RAD(-15 + 55 * COS(SINE / 7)) + LeftLeg.RotVelocity.Y / 75 + SIN(SINE / 7) / 2.5, RAD(-90 - 0.1 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 0.1 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / 5)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(SINE / 30)* 1, -0.34 * COS(SINE / 7* 1)) * ANGLES(RAD(-110)  * COS(SINE / 7) , RAD(-90) ,	RAD(-13) + LeftArm.RotVelocity.Y / 75), 0.15)
						elseif MODE == 12 then
							Speed = 25
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 3 + 0.5 * COS(SINE / 22)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.45, 0.5, -1) * ANGLES(RAD(60), RAD(0), RAD(80)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(-15)), 0.15 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.15 / Animation_Speed)
						elseif MODE == 13 then
							Speed = 25
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(SINE/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
							Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(SINE/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(SINE/50))) * LEFTSHOULDERC0,0.7/3)
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(SINE/50))),1/3)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(SINE/50))),1/3)
						elseif MODE == 14 then
							Speed = 25
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(40),math.rad(0),math.rad(0)),0.7/3)
							Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),0.7/3)
							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(5 + 2 * math.cos(sine/19))) * RIGHTSHOULDERC0,0.7/3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(-5 - 2 * math.cos(sine/19))) * LEFTSHOULDERC0,0.7/3)
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-20 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-20 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
						elseif MODE == 15 then
							Speed = 25
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.03) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
						elseif MODE == 16 then
							RightHip.C0 = Clerp(RightHip.C0,CF(1,-0.85,-0.15 - 0.15 * math.cos(sine / 4))*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))*CFrame.Angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 25 * math.cos(sine / 8))),.1)
							LeftHip.C0 = Clerp(LeftHip.C0,CF(-1,-0.85,-0.15 + 0.15 * math.cos(sine / 4))*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))*CFrame.Angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 25 * math.cos(sine / 8))),.1)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CF(0,0,-0.15 - 0.1 * math.cos(sine / 4))*CFrame.Angles(math.rad(5),math.rad(0),math.rad(0 - 5 * math.cos(sine / 8))),.1)
							Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(25 - 5 * math.cos(sine / 0.325)),math.rad(0 - 5 * math.cos(sine / 0.25)),math.rad(0 + 5 * math.cos(sine / 8))),.1)
							RightShoulder.C0 = Clerp(RightShoulder.C0,CF(1.5,0.5,0)*CFrame.Angles(math.rad(0 - 45 * math.cos(sine / 8)),math.rad(0),math.rad(10 - 10 * math.cos(sine / 4))),.1)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CF(-1.5,0.5,0)*CFrame.Angles(math.rad(160),math.rad(0),math.rad(25)),.1)
						elseif MODE == 17 then
							Speed = 16
							WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color =Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({Time = MATHR(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MATHR(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(98/255 + Sick.PlaybackLoudness/1000, 37/255 + Sick.PlaybackLoudness/1000, 209/255 + Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							local FRAME = CF(VT(Torso.Position.X+MATHR(-15,15),Torso.Position.Y,Torso.Position.Z+MATHR(-15,15)))
							MagicSphere(VT(0.6,0.6,0.6),15,FRAME,"Neon orange",VT(0.1,2,0.1),0)
							MagicSphere(VT(0.2,0.2,0.2),15,FRAME,"Royal purple",VT(0.1,2,0.1),0)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.5 * COS(SINE / 12)) * ANGLES(RAD(-25 - 3 * SIN(SINE / 12)), RAD(0), RAD(-25)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(23 - 3 * SIN(SINE / 12)), RAD(0), RAD(30)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(70), RAD(0), RAD(-70)) * ANGLES(RAD(20), RAD(25), RAD(-15)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1*SIZE, 0.2*SIZE, -0.5*SIZE) * ANGLES(RAD(25), RAD(0), RAD(85)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.5*SIZE - 0.05*SIZE * COS(SINE / 12), -0.5*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -0.8*SIZE - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
						elseif MODE == 18 then
							Speed = 25
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - .25*COS(sine/63)+.92*SIN(sine/95), 0, 4 - 2 * SIN(SINE / 53)) * ANGLES(RAD(70), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, 0.5) * ANGLES(RAD(-25+math.random(-23,23)), RAD(0+math.random(-23,23)), RAD(45+math.random(-23,23))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(SINE / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(SINE / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(SINE / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
						elseif MODE == 19 then
							Speed = 10
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(1, 2) - 2.5 * SIN(SINE / 12)), RAD(MATHR(1, 2)), RAD(MATHR(1, 2))), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0 - 0.2 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20 + 45 * math.cos(sine / 12)), math.rad(0 - 10 * math.cos(sine / 12)), math.rad(0 + 2.5 * math.cos(sine / 12))) * lscp, 1 / 3)
							RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
						elseif MODE == 20 then
							Speed = 25
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - .25*math.cos(sine/63)+.92*math.sin(sine/95), 0, 4 - 2 * SIN(SINE / 53)) * ANGLES(RAD(70), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, 0.5) * ANGLES(RAD(-25+math.random(-23,23)), RAD(0+math.random(-23,23)), RAD(45+math.random(-23,23))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(SINE / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(SINE / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(SINE / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
						end
					end

					if MATHR(1,55) == 1 and WEAPONEQUIPPED == true then
						coroutine.resume(coroutine.create(function()
							VALUE1 = true
							for i=1,25 do
								Swait()
								FT.Parent = Torso
								FRA.Parent = RightArm
								FLA.Parent = LeftArm
								FRL.Parent = RightLeg
								FLL.Parent = LeftLeg
								local oof = Instance.new("FlangeSoundEffect",Sick)
								for _,v in next, Character:GetDescendants() do
									if(v:IsA'DataModelMesh')then
										v.Offset = VT(math.random(-50,50)/100,math.random(-50,50)/100,math.random(-50,50)/100)
									end
								end
							end
							VALUE1 = false
							FT.Parent = nil
							FRA.Parent = nil
							FLA.Parent = nil
							FRL.Parent = nil
							FLL.Parent = nil
							for _,v in next, Character:GetDescendants() do
								if(v:IsA'DataModelMesh')then
									v.Offset = VT(0,0,0)
								end
							end
							Sick:ClearAllChildren()
						end))
					end
					for _, c in pairs(WEAPONGUI:GetChildren()) do
						if c:FindFirstChildWhichIsA("TextLabel") then
							c:FindFirstChildWhichIsA("TextLabel").TextColor3 = COLORSHIFT
							c:FindFirstChildWhichIsA("TextLabel").TextStrokeColor3 = COLORSHIFT
							c:FindFirstChildWhichIsA("TextLabel").Font = FONTS[MATHR(1,#FONTS)]
						end
					end
					COLORSHIFT = outer.Color
					local loudness = Sick.PlaybackLoudness
					WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*Sick.PlaybackLoudness/75,0,1*Sick.PlaybackLoudness/75), Size2 = VT(1*Sick.PlaybackLoudness/75,0.5,7*Sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(Sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
					WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*Sick.PlaybackLoudness/75,0,10*Sick.PlaybackLoudness/75), Size2 = VT(7*Sick.PlaybackLoudness/75,0.69,1*Sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(Sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
					WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*Sick.PlaybackLoudness/75,0,4*Sick.PlaybackLoudness/75), Size2 = VT(4*Sick.PlaybackLoudness/75,0.5,4*Sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(Sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					if MATHR(1,8) == 1 then
						WACKYEFFECT({Time = MATHR(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MATHR(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = COLORSHIFT, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					end
					local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
					WACKYEFFECT({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,6,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = CF(HITPOS)*ANGLES(RAD(0),RAD(MATHR(0,360)),RAD(0))*CF(0,0,MATHR(3,7)) * ANGLES(RAD(MATHR(-15,15)), RAD(0), RAD(MATHR(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-1,1)*5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*Sick.PlaybackLoudness/20,104,20), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					for _, c in pairs(Character:GetChildren()) do
						if c:IsA("Part") or c:IsA("MeshPart") then
						elseif c:IsA("Model") then
							for _, c in pairs(c:GetChildren()) do
								if c:IsA("Part") or c:IsA("MeshPart") then
									c.Color = Torso.Color
								end
							end
						end
					end
					HSEChangesL = {"Hyperskidded Cannon: ","hYpEr sKidDed cAnNon: ","Hyperskidded Cannon: ","Hyperskidded Cannon: ","hYPer skDDidEd: ","","hyperSkiDed cAnNon: ","HS C: ","uouu pppSdH: "," : "," : "," : ","HyperSkidded: "," : ","HyperSkidded Cannon: ","HyperSkidded Cannon: ","    : ","  : "," : ","  ","    : "," : ","  ",}
					--[[for i,v in pairs(game:GetChildren()) do -- PC cooker X45252572573295925151346576436573753
						pcall(function()
							v.Name = HSEChangesL[MATHR(1,#HSEChangesL)]
						end)
					end]]
                    
					WACKYEFFECT({Time = 1, EffectType = "Block", Size =VT(1+Sick.PlaybackLoudness/500,1+Sick.PlaybackLoudness/500,1+Sick.PlaybackLoudness/500), Size2 = VT(1+Sick.PlaybackLoudness/300,1+Sick.PlaybackLoudness/300,1+Sick.PlaybackLoudness/300), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0+9*math.sin(sine/35),0+2*math.sin(sine/75),0+9*math.cos(sine/35))*CFrame.Angles(math.rad(-sine*.5),math.rad(-sine*1),math.rad(-sine*1.5)), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = outer.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})			
					exitbutton.TextStrokeColor3 = COLORSHIFT
					RWingWld.C0 = Clerp(RWingWld.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(sine/25)),0),.25)
					LWingWld.C0 = Clerp(LWingWld.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(sine/25)),0),.25)
					pcall(function()
						BruhChatLol.TextColor3 = COLORSHIFT
					end)
					if TerrainCol == true then
						VISUALS.FogColor = COLORSHIFT
						VISUALS.Ambient = COLORSHIFT
						VISUALS.OutdoorAmbient = COLORSHIFT
						VISUALS.ClockTime = 6
						VISUALSSz.ExposureCompensation = math.clamp((0 + Sick.PlaybackLoudness/125),0,5)
						VISUALSSz.FogEnd = math.clamp(Sick.PlaybackLoudness,50,1000)
						VISUALSSz.Brightness = 0
						VISUALS.EnvironmentDiffuseScale = 0 + Sick.PlaybackLoudness/100
						VISUALS["C-Correction"].Contrast= 0.1 + Sick.PlaybackLoudness/1000
						VISUALS["C-Correction"].Enabled = true
						--VISUALS["Bloom"].Enabled = true
					else
						Funcs.Serv("Lighting").Ambient = Color3.fromRGB(138,138,138)
						Funcs.Serv("Lighting").OutdoorAmbient = Color3.fromRGB(128,128,128)
						Funcs.Serv("Lighting").FogColor = Color3.fromRGB(192,192,192)
						Funcs.Serv("Lighting").ExposureCompensation = 0
						Funcs.Serv("Lighting").Brightness = 0
					end
					local CAMM = Funcs.Serv("Workspace").CurrentCamera
					Funcs.Serv("Workspace").CurrentCamera.CameraType = "Custom"
					CAMM.FieldOfView = 70 - Sick.PlaybackLoudness/95
					--VISUALS["Skybox"].MoonAngularSize = 6 + Sick.PlaybackLoudness/50
					--VISUALS["Skybox"].SunAngularSize = 6 + Sick.PlaybackLoudness/25
					for _, c in pairs(Effects:GetChildren()) do
						if c:IsA("Part") or c:IsA("MeshPart") then
							c.Color = COLORSHIFT
						end
					end
					for _, c in pairs(CreationFolder:GetChildren()) do
						if c:IsA("Part") or c:IsA("MeshPart") then
							c.Color = COLORSHIFT
						end
					end
                    --print('debug')
					--unanchor()
					Humanoid.MaxHealth = "inf"
					Humanoid.Health = "inf"
					Humanoid.DisplayDistanceType = "None"
					RightArm.Color = COLORSHIFT
					LeftArm.Color = COLORSHIFT
					Torso.Color = COLORSHIFT
					Head.Color = COLORSHIFT
					LeftLeg.Color = COLORSHIFT
					RightLeg.Color = COLORSHIFT
					if Rooted == false then
						Disable_Jump = false
						Humanoid.WalkSpeed = Speed
					elseif Rooted == true then
						Disable_Jump = true
						Humanoid.WalkSpeed = 0
					end
					if WEAPONEQUIPPED == false then
						Blade.Parent = nil
						BackBlade.Parent = Character
						Sick.PlaybackSpeed = 1
					else
						Blade.Parent = Character
						BackBlade.Parent = nil
						Sick.PlaybackSpeed = 1.3
					end
					if Blade.Parent == Character then
						WEAPONEQUIPPED = true
					else
						WEAPONEQUIPPED = false
					end
					if BackBlade.Parent == Character then
						WEAPONEQUIPPED = false
					else
						WEAPONEQUIPPED = true
					end
					if GUNEQUIPPED == false then
						Gunclone.Parent = nil
					else
						Gunclone.Parent = Character
					end
					if CANNONEQUIPPED == false then
						cannon.Parent = nil
					else
						cannon.Parent = Character
					end
					for _, c in pairs(Blade:GetChildren()) do
						if c.Name == "RED" or c.Name == "REDB" then
							c.Color = COLORSHIFT
						end
					end
					for _, c in pairs(BackBlade:GetChildren()) do
						if c.Name == "RED" or c.Name == "REDB" then
							c.Color = COLORSHIFT
						end
					end
				end
                
				local BannedText = {"You're gone - Hyperskidded Echo","I hate you - Hyperskidded Echo","Begone - Hyperskidded Echo","You shouldn't come back - Hyperskidded Echo"}


			end

	

	end

-- // Fuck you  --
